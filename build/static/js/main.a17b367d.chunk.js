(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{101:function(e,t,o){},157:function(e,t,o){"use strict";o.r(t);var n=["D. An entry point in a Java application consists of a main() method with a single String[] argument, return type of void, and modifiers public and static. The name of the variable in the input argument does not matter. Option A is missing the static modifier, Option B is missing the String[] argument, and Option C has the wrong access modifier and method name. Only Option D fulfills these requirements. Note that the modifier final is optional and may be added to an entry point method.","A. The diagram is an example of object-oriented design in Java, making Option B a true statement. Options C and D are also true, as they follow from the inheritance model in the diagram. Option A is the correct answer, since platform independence has nothing to do with the diagram.","C. The proper extension for a Java compiled bytecode file is .class, making Option C the correct answer.","B. The fact that the Date class exists in both packages does not impact the ability to import both packages, so lines 1 and 2 compile without issue, and Option A is incorrect. Line 4 will not compile because the Date class used is ambiguous, making Option B correct and Option D incorrect. Finally, Option C is incorrect because line 5 does compile, as the fully qualified name of the class is used.","A. Options B, C, and D are each attributes of traditional object-oriented programming. Option A is incorrect as an object-oriented project tends to group data and the actions related to that data into a single object.","D. Only local variables have such a small scope, making Option D the correct answer.","B. The package java.lang is imported into every Java class, so Option B is correct. The other options must be explicitly imported. Option A exists but must be explicitly imported. Options C and D do not exist in the standard Java runtime.","C. Java accepts Options A, B, and D as valid comments. Note that the /* */ syntax can have additional (and uneven) star (*) characters as shown in B and D. Option C is incorrect as hashtag (#) is not a valid comment character in Java.","D. A valid .java file may define any number of classes or interfaces but have at most one public class. It can also not define any public classes. For these reasons, Option A, B, and C are incorrect, leaving Option D as the only correct answer.","B. Notice in this question that main() is not a static method, therefore it can access both class and instance variables. Since there are two class variables and two instance variables defined, Option B is the correct answer.","B. A class will compile if it has unused or redundant import statements, making Option A and C incorrect. Option D is also incorrect as the compiler must be able to locate the class of the import statement. The correct answer is Option B. Removing unused import statements does not cause a class to become unable to be compiled.","A. The code does not compile because of line 5, making Option A the correct answer. For this question, it helps to understand variable scope. The main() method is static and does not have access to any class instance variables. The birds variable is not static and requires a class instance variable to access. Therefore, the code does not compile when the static method attempts to access a non-static variable without an instance of the class.","D. The java command can only execute compiled .class files, so I is false. Java is most certainly object oriented, one of the key design principles, so II is also false. The javac command compiles into bytecode, which must be run in a Java virtual machine (JVM), and is not native machine code, so III is false as well. Since none of the statements are true, Option D is the correct answer.","D. A class can start with a comment, an optional package statement, or an import statement if there is no package statement. It cannot start with a variable definition, making Option D the correct answer.","C. Classes may be defined without a package declaration and are placed in the default package, so Option A is incorrect. Option B is a completely false statement as no such file is required in Java. Option C is correct as it is one of the primary reasons for organizing your application into packages. Option D is incorrect as package-private allows access to methods and variables to be limited to those classes within the same package.","B. The compilation command requires the full or relative name of the file, including the .java extension, making Options A and C incorrect. The execution command requires the class name without a filename extension, making Option D incorrect. Option B is the only correct set of compilation and execution commands.","D. Encapsulation is the technique of removing access to a class\u2019s instance variables from processes outside the class, making Option D the correct answer.","D. The height variable is declared within the if-then statement block. Therefore, it cannot be referenced outside the if-then statement and the code does not compile.","A. A Java bytecode file is a binary encoded set of instructions designed to be run on any computer with a compatible JVM, making Option A the only correct answer. By compatible JVM, we mean one capable of running the class file. For example, a Java 6 JVM may have trouble executing a Java 8 compiled file. Option B is incorrect, and is more a facet of machine language compiled programming classes. Option C is also incorrect as binary data is not particularly human readable. Finally, Option D is incorrect as the compiled file can be distributed without its .java source file and execute without issue.","D. Unlike with some other programming languages, the proper way to terminate a line of code is with a semicolon (;), making D the only correct answer.","C. The code compiles and runs without issue, so Options A and B are incorrect. The question relies on your ability to understand variable scope. The variable today has local scope to the method in which it is executed. The variable tomorrow is re-declared in the method, but the reference used on line 7 is to the instance variable with a value of 10. Finally, the variable tomorrow is static. While using an instance reference to access a static variable is not recommended, it does not prevent the variable from being read. The result is line 7 evaluates and prints (20 + 10 + 1) = 31, making C the correct answer.","C. Line 1 is missing the class keyword. Line 2 contains two types for the same variable. Line 3 is a valid definition for a method, making C the correct answer. Finally, line 4 contains an access modifier, private, after the return type, which is not allowed. In addition, void is an invalid type for variables.","D. Platform independence is the property of Java that allows it to be run on a variety of different devices.","A. Options B, C, and D are each correct statements about JVMs. Option A is incorrect. Not only is it not a statement about JVMs, it is actually false as Java bytecode can often be easily decoded/decompiled.","B. There is no such thing as package variables, so Option A is incorrect. Option C is incorrect as the variable is only in scope within a specific instance of the class. Option D is also incorrect as the variable is only in scope for a single method that it is defined in. Option B is the only correct answer as class variables are in scope within the program.","C. Option A is incorrect as the sub-package recurring is not included by the import statements. Option B is also incorrect as it uses the plural directors instead of the singular director used in the import statements. Option D is incorrect as the wildcard is applied to the sub-package movie.director, not the package movie. Finally, Option C is correct as it is a valid class accessible from the wildcard import.","D. Java classes are defined in this order: package statement, import statements, class declaration, making Option D the only correct answer. Note that not all of these statements are required. For example, a class may not have a package statement, but if it does, it must come first in the file.","D. The import statements for stars.* and stars.Blackhole are redundant import statements, since only the class Blackhole is used, and therefore one of them can be safely removed. The import statements java.lang.* and java.lang.Object are both not required as java.lang is automatically imported in every Java class. Therefore, three of the four import statements can be safely removed, making the correct answer Option D.",'C. The application prints the third argument of the input methods. Note that double quotes "" group input arguments. Therefore, the third argument of Option A is White-tailed deer. The third argument of Option B is 3. The third argument of Option C is White-tailed, making it the correct answer. Finally, Option D only has two input arguments, leading to an ArrayIndexOutOfBoundsException trying to read the third argument at runtime.',"B. The javac command compiles a .java file into a .class bytecode file, making Option B the correct answer.","B. Java is object oriented, not procedural, so Option A is a false statement. Java allows method overloading in subclasses, so Option B is correct. Operator overloading is permitted in languages like C++, not Java, so Option C is also untrue. Finally, Option D is not a true statement as the JVM manages the location of objects in memory that can change and is transparent to the Java application.","D. Option A is incorrect as the return type of the method cannot be null. Option B is also incorrect as the return type cannot be void if the method uses a return statement. Option C is incorrect too as the class keyword is replaced with int. Option D is correct because it\u2019s the only answer that allows the code to compile without issue. Note that other values are possible for this question. For example, either int or long can be entered in the last blank. The key here is that only one of the available answer choices allows the code to compile.","A. The code compiles so Option D is incorrect. The input to the constructor is ignored, making the assignment of end to be 4. Since start is 2, the subtraction of 4 by 2 results in the application printing 2, followed by 5, making Option A the correct answer.","D. Option A is a false statement, while Options B and C are actually arguments against using inheritance. Option D is one of the most important reasons Java supports inheritance, to allow increased code reuse among classes.","A. The double slash (//) syntax can have any number of slashes as a comment, so long as it starts with two of them, making Option A the correct answer. The (#) is not a comment character in Java, regardless of whether it is followed by a (!), so Option B is incorrect. Option C is incorrect as a single slash (/) is not a valid comment in Java. Finally, Option D is incorrect as Option A is a valid comment.","B. An entry point in a Java application consists of a main() method with a single String[] argument, return type of void, and modifiers public and static. Option D is the typical syntax for this method, although Options A and C are also valid forms of this method. Note that the modifier final is optional and may be added to the method signature. Furthermore, the main() method may take a vararg or array. Option B is the only invalid declaration as it does not take an array as an argument.","B. The line of code cannot be inserted at a1 because no variables are allowed outside of the class declaration in this file, making Options A and D incorrect. The line of code can also not be inserted at a3 as local variables defined within methods cannot have access modifiers such as public, making Option C incorrect. The code can be inserted independently at a2 and a4 as instance variables can be defined anywhere in the class outside a method. Therefore, Option B is the correct choice.","A. Option A is the only correct answer as a class definition is the only required component in a Java class file. Note that we said a Java class file here; Java also allows interfaces and enums to be defined in a file. A package statement and import statements are optional for declaring a class, making Options B and C incorrect. A class may also be defined with package-level access in a file, making Option D an incorrect answer.","D. The proper extension for a Java compiled bytecode file is .java, making Option D the correct answer.","C. Remember that java.lang is automatically imported in all Java classes, therefore both java.lang.Math and pocket.complex.Math are both imported into this class. Importing both sets of packages does not cause any compilation issues, making Option A incorrect. Line 3 is unnecessary import but including it does not prevent the class from compiling, making Option B incorrect. While both versions of Math may be imported into the class, the usage of the Math class requires a package name. Because of this, line 6 does not compile as the class reference is ambiguous, making Option C the correct answer and Option D incorrect.","A. Options B and C are accessible within the class as they are covered by the import statements. Option D is also fine as java.lang.Object is available without an explicit import. The only class not automatically accessible within the class without the full package name is dog.puppy.female.KC as the import statements do not include sub-packages; therefore, Option A is the correct answer.","B. Object-oriented programming is the technique of structuring data into objects, which may contain data and a set of actions that operate on the data, making Option B the correct answer.","A. All of the import statements in this class are required. Removing any of them would cause the class to not compile, making Option A the correct answer.","C. The numLock variable is not accessible in the static main() method without an instance of the Keyboard class; therefore, the code does not compile, and Option C is the correct answer.","D. The code compiles and runs without issue, so Option A is incorrect. The question involves understanding the value and scope of each variable at the print() statement. The variables feet and tracks are locally scoped and set to 4 and 15, respectively, ignoring the value of tracks of 5 in the instance of the class. Finally, the static variable s.wheels has a value of 1. The result is the combined value is 20, making Option D the correct answer.","B. First off, the color variable defined in the instance and set to red is ignored in the method printColor() as local scope overrides instance scope, so Option A is incorrect. The value of color passed to the printColor() method is blue, but that is lost by the assignment to purple, making Option B the correct answer and Option C incorrect. Option D is incorrect as the code compiles and runs without issue.","C. The javac command takes a text-based .java file and returns a binary bytecode .class file, making II a true statement. The java command uses a period (.) to separate packages, not a slash (/), making I a true statement and III a false statement. For these reasons, Option C is the correct answer.","D. The application compiles without issue, so Option C is incorrect. The application does not execute though, as the main() method does not have the correct method signature. It is missing the required input argument, an array of String. Trying to execute the application without a proper entry point produces an error, making Option D the correct answer.","C. Option A does not compile because it is missing the closing bracket for the class. Option D does also not compile as void is not a valid type for a variable. Regardless, Options A and D are incorrect as they are missing the getRating() method. Note that Option A also uses an abbreviation for numberOfPages. Option B is incorrect as it is missing the numberOfPages attribute. Option C is the correct answer as it properly defines the attribute numberOfPages and method getRating().","C. Garbage collection can happen at any time while an application is running, especially if the available memory suddenly becomes low, making Option A incorrect. Option B is also incorrect, since it is trivial to create a Java application with an infinite loop that never terminates. Option D is incorrect because the computer must be able to run the JVM in order to execute a Java class. Option C is the only correct answer, as the JVM does require an entry point method to begin executing the application."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"Which of the following method signatures is a valid declaration of an entry point in a Java\xa0application?",code:null,answers:["public void main(String[] args)","public static void main()","private static void start(String[] mydata)","public static final void main(String[] mydata)"]},{title:"The following class diagram demonstrates the relationship between Gold and Silver, which extend the Metal class. Assume the attributes are all declared public. Which statement about the diagram is not true?",code:null,answers:["The diagram demonstrates platform independence in Java.","The diagram demonstrates object-oriented design in Java.","The Gold and Silver classes inherit weight and color attributes from the Metal class.","Gold does not inherit the luster attribute."]},{title:"What is the proper filename extension for a Java bytecode compiled file?",code:null,answers:[".java",".bytecode",".class",".dll"]},{title:"Given that a Date class exists in both the java.util and java.sql packages, what is the result of compiling the following class?",code:"<code>1: import java.util.*;</code>\n<code>2: import java.sql.*;</code>\n<code>3: public class BirthdayManager {</code>\n<code>4:    private Date rob = new Date();</code>\n<code>5:    private java.util.Date sharon = new java.util.Date();</code>\n<code>6: }</code>",answers:["The code does not compile because of lines 1 and 2.","The code does not compile because of line 4.","The code does not compile because of line 5.","The code compiles without issue."]},{title:"Which of the following is not a facet of traditional object-oriented programming languages?",code:null,answers:["Objects are grouped as procedures, separate from the data they act on.","An object can take many forms via casting.","An object can hold data, referred to as attributes.","An object can perform actions, via methods."]},{title:"Which variables have a scope limited to a method?",code:null,answers:["Interface variables","Class variables","Instance variables","Local variables"]},{title:"Which package is imported into every Java class by default?",code:null,answers:["java.util","java.lang","system.lang","java.system"]},{title:"Which of the following is not a valid code comment in Java?",code:null,answers:["// Add 5 to the result","/*** TODO: Fix bug 12312 ***/","# Add configuration value","/* Read file from system ****/"]},{title:"Which statement about a valid .java file is true?",code:null,answers:["It can only contain one class declaration.","It can contain one public class declaration and one public interface definition.","It must define at least one public class.","It may define at most one public class."]},{title:"Given the following application, fill in the missing values in the table starting from the top and going downward.",code:'<code>package competition;</code>\n<code>public class Robot {</code>\n<code>   static String weight = "A lot";</code>\n<code>   /* default */ double ageMonths = 5, ageDays = 2;</code>\n<code><span epub:type="pagebreak" id="Page_6"></span>   private static boolean success = true;</code>\n<code>   public void main(String[] args) {</code>\n<code>      final String retries = "1";</code>\n<code>      // P1</code>\n<code>   }</code>\n<code>}</code>',answers:["2, 0, 1","2, 2, 1","1, 0, 1","0, 2, 1"]},{title:"Which statement about import statements is true?",code:null,answers:["The class will not compile if it contains unused import statements.","Unused import statements can be removed from the class without causing a class to become unable to be compiled.","The class will not compile if a duplicate import statement is present.","If a class contains an import statement for a class used in the program that cannot be found, it can still compile."]},{title:"What is the result of compiling and executing the following class?",code:"<code>1: public class ParkRanger {</code>\n<code>2:    int birds = 10;</code>\n<code>3:    public static void main(String[] data) {</code>\n<code>4:       int trees = 5;</code>\n<code>5:       System.out.print(trees+birds);</code>\n<code>6:    }</code>\n<code>7: }</code>",answers:["It does not compile.","It compiles but throws an exception at runtime.","It compiles and outputs 5.","It compiles and outputs 15."]},{title:"Which statements about Java are true?",code:null,answers:["I only","III only","II and III","None are true."],ol:["The java command can execute .java and .class files.","Java is not object oriented.","The javac command compiles directly into native machine code."]},{title:"Which of the following lines of code is not allowed as the first line of a Java class file?",code:null,answers:["import widget.*;","// Widget Manager","package sprockets;","int facilityNumber;"]},{title:"Which one of the following statements is true about using packages to organize your code in\xa0Java?",code:null,answers:["Every class is required to include a package declaration.","To create a new package, you need to add a package.init file to the directory.","Packages allow you to limit access to classes, methods, or data from classes outside the package.","It is not possible to restrict access to objects and methods within a package."]},{title:"Given that the current directory is /user/home, with an application Java file in  /user/home/Manager.java that uses the default package, which are the correct commands to compile and run the application in Java?",code:null,answers:["javac Manager     java Manager","javac Manager.java     java Manager","javac Manager     java Manager.class","javac Manager.java     java Manager.class"]},{title:"Structuring a Java class such that only methods within the class can access its instance  variables is referred to as _______.",code:null,answers:["platform independence","object orientation","inheritance","encapsulation"]},{title:"What is the output of the following code snippet?",code:'<code>String tree = "pine";</code>\n<code>int count = 0;</code>\n<code>if (tree.equals("pine")) {</code>\n<code>   int height = 55;</code>\n<code>   count = count + 1;</code>\n<code>}</code>\n<code>System.out.print(height + count);</code>',answers:["1","55","56","It does not compile."]},{title:"Which of the following is true of a Java bytecode file?",code:null,answers:["It can be run on any computer with a compatible JVM.","It can only be executed on the same type of computer that it was created on.","It can be easily read and modified in a standard text editor.","It requires the corresponding .java that created it to execute."]},{title:"What is the correct character for terminating a statement in Java?",code:null,answers:["A colon (:)","An end-of-line character","A tab character","A semicolon (;)"]},{title:"What is the result of compiling and executing the following class?",code:"<code>1: public class Tolls {</code>\n<code>2:    private static int yesterday = 1;</code>\n<code>3:    int tomorrow = 10;</code>\n<code>4:    public static void main(String[] args) {</code>\n<code>5:       Tolls tolls = new Tolls();</code>\n<code>6:       int today=20, tomorrow = 40;</code>\n<code>7:       System.out.print(today + tolls.tomorrow + tolls.yesterday);</code>\n<code>8:    }</code>\n<code>9: }</code>",answers:["The code does not compile due to line 6.","The code does not compile due to line 7.","31","61"]},{title:"Given the following class definition, which is the only line that does not contain a  compilation error?",code:"<code>1: public ThisClassDoesNotCompile {</code>\n<code>2:    double int count;</code>\n<code>3:    void errors() {}</code>\n<code>4:    static void private limit; }</code>",answers:["Line 1","Line 2","Line 3","Line 4"]},{title:"Which of the following features allows a Java class to be run on a wide variety of computers and devices?",code:null,answers:["Encapsulation","Object oriented","Inheritance","Platform independence"]},{title:"Which of the following is not a property of a JVM?",code:null,answers:["It prevents Java bytecode from being easily decoded/decompiled.","It supports platform independence.","It manages memory for the application.","It translates Java instructions to machine instructions."]},{title:"Which of the following variables are always in scope for the entire program?",code:null,answers:["Package variables","Class variables","Instance variables","Local variables"]},{title:"Given the following wildcard import statements, which class would be included in the import?",code:"<code>import television.actor.*;</code>\n<code>import movie.director.*;</code>",answers:["television.actor.recurring.Marie","movie.directors.John","television.actor.Package","movie.NewRelease"]},{title:"Which is the correct order of statements for a Java class file?",code:null,answers:["import statements, package statement, class declaration","package statement, class declaration, import statement","class declaration, import statements, package declaration","package statement, import statements, class declaration"]},{title:"Given the following class definition, what is the maximum number of import statements that can be discarded and still have the code compile? For this question, assume that the Blackhole class is defined only in the stars package.",code:"<code>package planetarium;</code>\n<code>import java.lang.*;</code>\n<code>import stars.*;</code>\n<code>import java.lang.Object;</code>\n<code>import stars.Blackhole;</code>\n<code>&nbsp;</code>\n<code>public class Observer {</code>\n<code>   public void find(Blackhole blackhole) {}</code>\n<code>}</code>",answers:["Zero","One","Two","Three"]},{title:"Given the following class definition, which command will cause the application to output the message White-tailed?",code:"<code>package forest;</code>\n<code>public class Deer {</code>\n<code>   public static void main(String... deerParams) {</code>\n<code>      System.out.print(theInput[2]);</code>\n<code>   }</code>\n<code>}</code>",answers:['java forest.Deer deer 5 "White-tailed deer"','java forest.Deer "White-tailed deer" deer 3',"java forest.Deer Red deer White-tailed deer",'java forest.Deer My "deer White-tailed"']},{title:"Which of the following is a true statement?",code:null,answers:["The java command compiles a .java file into a .class file.","The javac command compiles a .java file into a .class file.","The java command compiles a .class file into a .java file.","The javac command compiles a .class file into a .java file."]},{title:"Which of the following statements about Java is true?",code:null,answers:["Java is a procedural programming language.","Java allows method overloading.","Java allows operator overloading.","Java allows direct access to objects in memory."]},{title:"Given the following code, what values inserted in order into the blank lines, allow the code to compile?",code:"<code> _______agent;</code>\n<code>public  _______Banker {</code>\n<code>   private static  _______getMaxWithdrawal() {</code>\n<code>      return 10;</code>\n<code>   }</code>\n<code>}</code>",answers:["import, class, null","import, interface, void","package, int, int","package, class, long"]},{title:"What is the output of the following application?",code:'<code>public class Airplane {</code>\n<code>   static int start = 2;</code>\n<code>   final int end;</code>\n<code>   public Airplane(int x) {</code>\n<code>      x = 4;</code>\n<code>      end = x;</code>\n<code>   }</code>\n<code>   public void fly(int distance) {</code>\n<code>      System.out.print(end-start+" ");</code>\n<code>      System.out.print(distance);</code>\n<code>   }</code>\n<code>   public static void main(String... start) {</code>\n<code>      new Airplane(10).fly(5);</code>\n<code>   }</code>\n<code>}</code>',answers:["2 5","8 5","6 5","The code does not compile."]},{title:"What is one of the most important reasons that Java supports extending classes via inheritance?",code:null,answers:["Inheritance requires that a class that extends another class be in the same package.","The program must spend extra time/resources at runtime jumping through multiple layers of inheritance to determine precise methods and variables.","Method signature changes in parent classes may break subclasses that use overloaded methods.","Developers minimize duplicate code in new classes by sharing code in a common parent class."]},{title:"Which of the following is a valid code comment in Java?",code:null,answers:["//////// Walk my dog","#! Go team!","/ Process fails at runtime /","None of the above"]},{title:"Which of the following method signatures is not a valid declaration of an entry point in a Java application?",code:null,answers:["public static void main(String... arguments)","public static void main(String arguments)","public static final void main(String[] arguments)","public static void main(String[] arguments)"]},{title:"Given the file Magnet.java below, which of the marked lines can you independently insert the line public String color; into and still have the code compile?",code:"<code>// line a1</code>\n<code>public class Magnet {</code>\n<code>   // line a2</code>\n<code>   public void attach() {</code>\n<code>      // line a3</code>\n<code>   }</code>\n<code>   // line a4</code>\n<code>}</code>",answers:["a1 and a3","a2 and a4","a2, a3, and a4","a1, a2, a3, and a4"]},{title:"What is required to define a valid Java class file?",code:null,answers:["A class declaration","A package statement","At least one import statement","The public modifier"]},{title:"What is the proper filename extension for a Java source file?",code:null,answers:[".jav",".class",".source",".java"]},{title:"Given that a Math class exists in both the java.lang and pocket.complex packages, what is the result of compiling the following class?",code:"<code>1: package pocket;</code>\n<code>2: import pocket.complex.*;</code>\n<code>3: import java.util.*;</code>\n<code>4: public class Calculator {</code>\n<code>5:   public static void main(String[] args) {</code>\n<code>6:      System.out.print(Math.floor(5));</code>\n<code>7:   }</code>\n<code>8: }</code>",answers:["The code does not compile because of line 2.","The code does not compile because of line 3.","The code does not compile because of line 6.","The code compiles without issue."]},{title:"Given a class that uses the following import statements, which class would not be automatically accessible within the class without using its full package name?",code:"<code>import dog.*;</code>\n<code>import dog.puppy.*;</code>",answers:["dog.puppy.female.KC","dog.puppy.Georgette","dog.Webby","java.lang.Object"]},{title:" _______is the technique of structuring programming data as a unit consisting of attributes, with actions defined on the unit.",code:null,answers:["Encapsulation","Object orientation","Platform independence","Polymorphism"]},{title:"Given the following class definition, what is the maximum number of import statements that can be discarded and still have the code compile? For this question, assume that the Broccoli class is in the food.vegetables package, and the Apple class is the food.fruit package.",code:"<code>package food;</code>\n<code>import food.vegetables.*;</code>\n<code>import food.fruit.*;</code>\n<code>import java.util.Date;</code>\n<code>&nbsp;</code>\n<code>public class Grocery {</code>\n<code>   Apple a; Broccoli b;  Date c;</code>\n<code>}</code>",answers:["0","1","2","3"]},{title:"Given the following application, what is the expected output?",code:'<code>public class Keyboard {</code>\n<code>   private boolean numLock = true;</code>\n<code>   static boolean capLock = false;</code>\n<code>   public static void main(String... shortcuts) {</code>\n<code>      System.out.print(numLock+" "+capLock);</code>\n<code>   }</code>\n<code>}</code>',answers:["true false","false false","It does not compile.","It compiles but throws an exception at runtime."]},{title:"What is the result of compiling and executing the following class?",code:"<code>public class RollerSkates {</code>\n<code>   static int wheels = 1;</code>\n<code>   int tracks = 5;</code>\n<code>   public static void main(String[] arguments) {</code>\n<code>      RollerSkates s = new RollerSkates();</code>\n<code>      int feet=4, tracks = 15;</code>\n<code>      System.out.print(feet + tracks + s.wheels);</code>\n<code>   }</code>\n<code>}</code>",answers:["The code does not compile.","5","10","20"]},{title:"What is the result of compiling and executing the following class?",code:'<code>package sports;</code>\n<code>public class Bicycle {</code>\n<code>   String color = "red";</code>\n<code>   private void printColor(String color) {</code>\n<code>      color = "purple";</code>\n<code>      System.out.print(color);</code>\n<code>   }</code>\n<code>   public static void main(String[] rider) {</code>\n<code>      new Bicycle().printColor("blue");</code>\n<code>   }</code>\n<code>}</code>',answers:["red","purple","blue","It does not compile."]},{title:"Which statements about calling the compilation command javac and the execution command java are true?",code:null,answers:["I only","II only","I and II","I, II, and III"],ol:["java may use a period . to separate packages.","javac takes a .java file and returns a .class file.","java may use a slash (/) to separate packages."]},{title:"What is the result of compiling and executing the following application?",code:"<code>package forecast;</code>\n<code>public class Weather {</code>\n<code>   private static boolean heatWave = true;</code>\n<code>   public static void main() {</code>\n<code>      boolean heatWave = false;</code>\n<code>      System.out.print(heatWave);</code>\n<code>   }</code>\n<code>}</code>",answers:["true","false","It does not compile.","It compiles but throws an error at runtime."]},{title:"Given the following class diagram, which Java implementation most closely matches this structure?",code:null,answers:["public class Book { \xa0\xa0\xa0public int numOfPages;","public class Book { \xa0\xa0\xa0public String getRating() {return null;} }","public class Book { \xa0\xa0\xa0public int numberOfPages; \xa0\xa0\xa0public String getRating() {return null;} }","public class Book { \xa0\xa0\xa0void numberOfPages; }"]},{title:"Which statement about the JVM is true?",code:null,answers:["The JVM schedules garbage collection on a predictable schedule.","The JVM ensures that the application will always terminate.","The JVM requires a properly defined entry point method to execute the application.","A Java compiled code can be run on any computer."]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),ol:e.ol,explain:n[t]}});i[1].imageUrl="./images/image-oca-ch1-2.png",i[9].imageUrl="./images/image-oca-ch1-10.png",i[48].imageUrl="./images/image-oca-ch1-49.png",t.default=i},158:function(e,t,o){"use strict";o.r(t);var n=["A. Option A does not compile because Java does not allow declaring different types as part of the same declaration. The other three options show various legal combinations of combining multiple variables in the same declarations with optional default values.",'D. The table variable is initialized to "metal". However, chair is not initialized. In Java, initialization is per variable and not for all the variables in a single declaration. Therefore, the second line tries to reference an uninitialized local variable and does not compile, which makes Option D correct.',"B. Instance variables have a default value based on the type. For any non-primitive, including String, that type is a reference to null. Therefore Option B is correct. If the variable was a local variable, Option C would be correct.","B. An identifier name must begin with a letter, $, or _. Numbers are only permitted for subsequent characters. Therefore, Option B is not a valid variable name.","B. In Java, class names begin with an uppercase letter by convention. Then they use lowercase with the exception of new words. Option B follows this convention and is correct. Option A follows the convention for variable names. Option C follows the convention for constants. Option D doesn\u2019t follow any Java conventions.","C. Objects have instance methods while primitives do not. Since int is a primitive, you cannot call instance methods on it. Integer and String are both objects and have instance methods. Therefore, Option C is correct.","C. Underscores are allowed between any two digits in a numeric literal. Underscores are not allowed at the beginning or end of the literal, making Option C the correct answer.","C. Option A is incorrect because int is a primitive. Option B is incorrect because it is not the name of a class in Java. While Option D is a class in Java, it is not a wrapper class because it does not map to a primitive. Therefore, Option C is correct.","C. There is no class named integer. There is a primitive int and a class Integer. Therefore, the code does not compile, and Option C is correct. If the type was changed to Integer, Option B would be correct.","C. The new keyword is used to call the constructor for a class and instantiate an instance of the class. A primitive cannot be created using the new keyword. Dealing with references happens after the object created by new is returned.","D. Java uses the suffix f to indicate a number is a float. Java automatically widens a type, allowing a float to be assigned to either a float or a double. This makes both lines p1 and p3 compile. Line p2 does compile without a suffix. Line p4 does not compile without a suffix and therefore is the answer.","A. A byte is smaller than a char, making Option C incorrect. bigint is not a primitive, making Option D incorrect. A double uses twice as much memory as a float variable, therefore Option A is correct.","D. The instance variables, constructor, and method names can appear in any order within a class declaration.","B. Java does not allow multiple Java data types to be declared in the same declaration, making Option B the correct answer. If double was removed, both hot and cold would be the same type. Then the compiler error would be on x3 because of a reference to an uninitialized variable.","C. Lines 2 and 7 illustrate instance initializers. Line 6 is a static initializer. Lines 3\u20135 are a constructor.","A. Since defaultValue is a local variable, it is not automatically initialized. That means the code will not compile with any type. Therefore, Option A is correct. If this was an instance variable, Option C would be correct as int and short would be initialized to 0 while double would be initialized to 0.0.","A. The finalize() method may not be called, such as if your program crashes. However, it is guaranteed to be called no more than once.","D. String is a class, but it is not a wrapper class. In order to be a wrapper class, the class must have a one-to-one mapping with a primitive.","C. Lines 15\u201317 create the three objects. Lines 18\u201319 change the references so link2 and link3 point to each other. The lines 20\u201321 wipe out two of the original references. This means the object with name as x is inaccessible.","C. Options A and D are incorrect because byte and short do not store values with decimal points. Option B is tempting. However, 3.14 is automatically a double. It requires casting to float or writing 3.14f in order to be assigned to a float. Therefore, Option C is correct.","B. Integer is the name of a class in Java. While it is bad practice to use the name of a class as your local variable name, this is legal. Therefore, k1 does compile. It is not legal to use a reserved word as a variable name. All of the primitives including int are reserved words. Therefore, k2 does not compile, and Option B is the answer. Line k4 doesn\u2019t compile either, but the question asks about the first line to not compile.","B. Dot notation is used for both reading and writing instance variables, assuming they are in scope. It cannot be used for referencing local variables, making Option B the correct answer.","C. Class names follow the same requirements as other identifiers. Underscores and dollar signs are allowed. Numbers are allowed, but not as the first character of an identifier. Therefore, Option C is correct. Note that class names begin with an uppercase letter by convention, but this is not a requirement.","D. This question is tricky as it appears to be about primitive vs. wrapper classes. Looking closely, there is an underscore right before the decimal point. This is illegal as the underscore in a numeric literal can only appear between two digits.","C. Local variables do not have a default initialization value. If they are referenced before being set to a value, the code does not compile. Therefore, Option C is correct. If the variable was an instance variable, Option B would be correct. Option D is tricky. A local variable will compile without an initialization if it isn\u2019t referenced anywhere or it is assigned a value before it is referenced.","C. Since defaultValue is an instance variable, it is automatically initialized to the corresponding value for that type. For double, that value is 0.0. By contrast, it is 0 for int, long, and short. Therefore Option C is correct.","B. Option B is an example of autoboxing. Java will automatically convert from primitive to wrapper class types and vice versa. Option A is incorrect because you can only call methods on an object. Option C is incorrect because this method is used for converting to a wrapper class from a String. Option D is incorrect because autoboxing will convert the primitive to an object before adding it to the ArrayList.","C. Java does not allow calling a method on a primitive. While autoboxing does allow the assignment of an Integer to an int, it does not allow calling an instance method on a primitive. Therefore, the last line does not compile.","D. In order to call a constructor, you must use the new keyword. It cannot be called as if it was a normal method. This rules out Options A and B. Further, Option C is incorrect because the parentheses are required.","A. Option A (I) correctly assigns the value to both variables. II does not compile as dog does not have a type. Notice the semicolon in that line, which starts a new statement. III compiles but only assigns the value to dog since a declaration only assigns to one variable rather than everything in the declaration. IV does not compile because the type should only be specified once per declaration.","C. The wrapper class for int is Integer and the wrapper class for char is Character. All other primitives have the same name. For example, the wrapper class for boolean is Boolean.","A. Assuming the variables are not primitives, they allow a null assignment. The other statements are false.","A. An example of a primitive type is int. All the primitive types are lowercase, making Option A correct. Unlike object reference variables, primitives cannot reference null. String is not a primitive as evidenced by the uppercase letter in the name and the fact that we can call methods on it. You can create your own classes, but not primitives.","D. While you can suggest to the JVM that it might want to run a garbage collection cycle, the JVM is free to ignore your suggestion. Option B is how to make this suggestion. Since garbage collection is not guaranteed to run, Option D is correct.","C. All three references point to the String apple. This makes the other two String objects eligible for garbage collection and Option C correct.","B. A constructor can only be called with a class name rather than a primitive, making Options A and C incorrect. The newly constructed Double object can be assigned to either a double or Double thanks to autoboxing. Therefore, Option B is correct.","B. First line 2 runs and sets the variable using the declaration. Then the instance initializer on line 6 runs. Finally, the constructor runs. Since the constructor is the last to run of the three, that is the value that is set when we print the result, so Option B is correct.","C. Objects are allowed to have a null reference while primitives cannot. int is a primitive, so assigning null to it does not compile. Integer and String are both objects and can therefore be assigned a null reference. Therefore, Option C is correct.","C. An instance variable can only be referenced from instance methods in the class. A static variable can be referenced from any method. Therefore, Option C is correct.","B. Underscores are allowed between any two digits in a numeric literal. Underscores are not allowed adjacent to a decimal point, making Option B the correct answer.","A. These four types represent nondecimal values. While you don\u2019t need to know the exact sizes, you do need to be able to order them from largest to smallest. A byte is smallest. A short comes next, followed by int and then long. Therefore, Option A is correct.","A. Java uses dot notation to reference instance variables in a class, making Option A correct.","B. If there was a finalize() method, this would be a different story. However, the method here is finalizer. Tricky! That\u2019s just a normal method that doesn\u2019t get called automatically. Therefore clean is never output.","A. Options B and C do not compile. In Java, braces are for arrays rather than instance variables. Option A is the correct answer. It uses dot notation to access the instance variable. It also shows that a private variable is accessible in the same class and that a narrower type is allowed to be assigned to a wider type.","B. The parseInt() methods return a primitive. The valueOf() methods return a wrapper class object. In real code, autoboxing would let you assign the return value to either a primitive or wrapper class. In terms of what gets returned directly, Option B is correct.","B. On line 9, all three objects have references. The elena and zoe objects have a direct reference. The diana object is referenced through the elena object. On line 10, the reference to the diana object is replaced by a reference to the zoe object. Therefore, the diana object is eligible to be garbage collected, and Option B is correct.","C. Options A and B are static methods rather than constructors. Option D is a method that happens to have the same name as the class. It is not a constructor because constructors don\u2019t have return types.","A. Remember that garbage collection is not guaranteed to run on demand. If it doesn\u2019t run at all, Option B would be output. If it runs at the requested point, Option C would be output. If it runs right at the end of the main() method, Option D would be output. Option A is the correct answer because play is definitely called twice. Note that you are unlikely to see all these scenarios if you run this code because we have not used enough memory for garbage collection to be worth running. However, you still need to be able to answer what could happen regardless of it being unlikely.","B. Each wrapper class has a constructor that takes the primitive equivalent. The methods mentioned in Options A, C, and D do not exist.","C. The main() method calls the constructor which outputs a. Then the main method calls the run() method. The run() method calls the constructor again, which outputs a again. Then the run() method calls the Sand() method, which happens to have the same name as the constructor. This outputs b. Therefore, Option C is correct."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"Which of the following declarations does not compile?",code:null,answers:["double num1, int num2 = 0;","int num1, num2;","int num1, num2 = 0;","int num1 = 0, num2 = 0;"]},{title:"What is the output of the following?",code:'<code>public static void main(String... args) {</code>\n<code>   String chair, table = "metal";</code>\n<code>   chair = chair + table;</code>\n<code>   System.out.println(chair);</code>\n<code>}</code>',answers:["metal","metalmetal","nullmetal","The code does not compile."]},{title:"Which is correct about an instance variable of type String?",code:null,answers:["It defaults to an empty string.","It defaults to null.","It does not have a default value.","It will not compile without initializing on the declaration line."]},{title:"Which of the following is not a valid variable name?",code:null,answers:["_blue","2blue","blue$","Blue"]},{title:"Which of these class names best follows standard Java naming conventions?",code:null,answers:["fooBar","FooBar","FOO_BAR","F_o_o_B_a_r"]},{title:"How many of the following methods compile?",code:'<code>public String convert(int value) {</code>\n<code>&nbsp;  return value.toString();</code>\n<code>}</code>\n<code>public String convert(Integer value) {</code>\n<code>&nbsp;  return value.toString();</code>\n<code><span epub:type="pagebreak" id="Page_19"></span>}</code>\n<code>public String convert(Object value) {</code>\n<code>&nbsp;  return value.toString();</code>\n<code>}</code>',answers:["None","One","Two","Three"]},{title:"Which of the following does not compile?",code:null,answers:["int num = 999;","int num = 9_9_9;","int num = _9_99;","None of the above; they all compile."]},{title:"Which of the following is a wrapper class?",code:null,answers:["int","Int","Integer","Object"]},{title:"What is the result of running this code?",code:'<code>public class Values {</code>\n<code>   integer a = Integer.valueOf("1");</code>\n<code>   public static void main(String[] nums) {</code>\n<code>      integer a = Integer.valueOf("2");</code>\n<code>      integer b = Integer.valueOf("3");</code>\n<code>      System.out.println(a + b);</code>\n<code>  }</code>\n<code>}</code>',answers:["4","5","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which best describes what the new keyword does?",code:null,answers:["Creates a copy of an existing object and treats it as a new one","Creates a new primitive","Instantiates a new object","Switches an object reference to a new one"]},{title:"Which is the first line to trigger a compiler error?",code:"<code>double d1 = 5f;    // p1</code>\n<code>double d2 = 5.0;   // p2</code>\n<code>float f1 = 5f;     // p3</code>\n<code>float f2 = 5.0;    // p4</code>",answers:["p1","p2","p3","p4"]},{title:"Which of the following lists of primitive types are presented in order from smallest to largest data type?",code:null,answers:["byte, char, float, double","byte, char, double, float","char, byte, float, double","char, double, float, bigint"]},{title:"Which of the following is not a valid order for elements in a class?",code:null,answers:["Constructor, instance variables, method names","Instance variables, constructor, method names","Method names, instance variables, constructor","None of the above: all orders are valid."]},{title:"Which of the following lines contains a compiler error?",code:'<code>String title = "Weather";                // line x1</code>\n<code>int hot, double cold;                    // line x2</code>\n<code>System.out.println(hot + " " + title);   // line x3</code>',answers:["x1","x2","x3","None of the above"]},{title:"How many instance initializers are in this code?",code:'<code>1:  public class Bowling {</code>\n<code>2:     { System.out.println(); }</code>\n<code>3:     public Bowling () {</code>\n<code>4:        System.out.println();</code>\n<code>5:     }</code>\n<code>6:     static { System.out.println(); }</code>\n<code><span epub:type="pagebreak" id="Page_21"></span>7:     { System.out.println(); }</code>\n<code>8:  }</code>\n<code>&nbsp;</code>',answers:["None","One","Two","Three"]},{title:"Of the types double, int, and short, how many could fill in the blank to have this code output 0?",code:"<code>public static void main(String[] args) {</code>\n<code>    _______defaultValue;</code>\n<code>   System.out.println(defaultValue);</code>\n<code>}</code>",answers:["None","One","Two","Three"]},{title:"What is true of the finalize() method?",code:null,answers:["It may be called zero or one times.","It may be called zero or more times.","It will be called exactly once.","It may be called one or more times."]},{title:"Which of the following is not a wrapper class?",code:null,answers:["Double","Integer","Long","String"]},{title:"Suppose you have the following code. Which of the images best represents the state of the references right before the end of the main method, assuming garbage collection hasn\u2019t run?",code:'<code>1:  public class Link {</code>\n<code>2:     private String name;</code>\n<code>3:     private Link next;</code>\n<code>4:     public Link(String name, Link next) {</code>\n<code>5:       this.name = name;</code>\n<code>6:       this.next = next;</code>\n<code>7:     }</code>\n<code><span epub:type="pagebreak" id="Page_22"></span>8:     public void setNext(Link next) {</code>\n<code>9:       this.next = next;</code>\n<code>10:    }</code>\n<code>11:    public Link getNext() {</code>\n<code>12:       return next;</code>\n<code>13:    }</code>\n<code>14:    public static void main(String... args) {</code>\n<code>15:       Link link1 = new Link("x", null);</code>\n<code>16:       Link link2 = new Link("y", link1);</code>\n<code>17:       Link link3 = new Link("z", link2);</code>\n<code>18:       link2.setNext(link3);</code>\n<code>19:       link3.setNext(link2);</code>\n<code>20:       link1 = null;</code>\n<code>21:       link3 = null;</code>\n<code>22:    }</code>\n<code>23: }</code>',answers:["Option A","Option B","Option C","Option D"]},{title:"Which type can fill in the blank?",code:"<code> _______&nbsp;&nbsp;pi = 3.14;</code>",answers:["byte","float","double","short"]},{title:"What is the first line in the following code to not compile?",code:"<code>public static void main(String[] args) {</code>\n<code>   int Integer = 0;        // k1</code>\n<code>   Integer int = 0;        // k2</code>\n<code>   Integer ++;             // k3</code>\n<code>   int++;                  // k4</code>\n<code>}</code>",answers:["k1","k2","k3","k4"]},{title:"Suppose foo is a reference to an instance of a class. Which of the following is not true about foo.bar?",code:null,answers:["bar is an instance variable.","bar is a local variable.","It can be used to read from bar.","It can be used to write to bar."]},{title:"Which of the following is not a valid class declaration?",code:null,answers:["class building {}","class Cost$ {}","class 5MainSt {}","class _Outside {}"]},{title:"Which of the following can fill in the blanks to make this code compile?",code:"<code> _______d = new_______ (1_000_000_.00);</code>",answers:["double, double","double, Double","Double, double","None of the above"]},{title:"Which is correct about a local variable of type String?",code:null,answers:["It defaults to an empty string.","It defaults to null.","It does not have a default value.","It will not compile without initializing on the declaration line."]},{title:"Of the types double, int, long, and short, how many could fill in the blank to have this code output 0?",code:"<code>static  _______defaultValue;</code>\n<code>&nbsp;</code>\n<code>&nbsp;</code>\n<code>   public static void main(String[] args) {</code>\n<code>      System.out.println(defaultValue);</code>\n<code>   }</code>",answers:["One","Two","Three","Four"]},{title:"Which of the following is true about primitives?",code:null,answers:["You can call methods on a primitive.","You can convert a primitive to a wrapper class object simply by assigning it.","You can convert a wrapper class object to a primitive by calling valueOf().","You can store a primitive directly into an ArrayList."]},{title:"What is the output of the following?",code:'<code>Integer integer = new Integer(4);</code>\n<code>System.out.print(integer.byteValue());</code>\n<code>&nbsp;</code>\n<code>System.out.print("-");</code>\n<code>&nbsp;</code>\n<code>int i = new Integer(4);</code>\n<code>System.out.print(i.byteValue());</code>',answers:["4-0","4-4","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Given the following code, fill in the blank to have the code print bounce.",code:'<code>public class TennisBall {</code>\n<code>   public TennisBall() {</code>\n<code>      System.out.println("bounce");</code>\n<code>   }</code>\n<code>   public static void main(String[] slam) {</code>\n<code>       _____________________</code>\n<code>   }</code>\n<code>}</code>',answers:["TennisBall;","TennisBall();","new TennisBall;","new TennisBall();"]},{title:"Which of the following correctly assigns animal to both variables?",code:null,answers:["I","I, II","I, III","I, II, III, IV"],ol:['String cat = "animal", dog = "animal";','String cat = "animal"; dog = "animal";','String cat, dog = "animal";','String cat, String dog = "animal";']},{title:"Which two primitives have wrapper classes that are not merely the name of the primitive with an uppercase letter?",code:null,answers:["byte and char","byte and int","char and int","None of the above"]},{title:"Which of the following is true about String instance variables?",code:null,answers:["They can be set to null.","They can never be set from outside the class they are defined in.","They can only be set in the constructor.","They can only be set once per run of the program."]},{title:"Which statement is true about primitives?",code:null,answers:["Primitive types begin with a lowercase letter.","Primitive types can be set to null.","String is a primitive.","You can create your own primitive types."]},{title:"How do you force garbage collection to occur at a certain point?",code:null,answers:["Call System.forceGc()","Call System.gc()","Call System.requireGc()","None of the above"]},{title:"How many of the String objects are eligible for garbage collection right before the end of the main method?",code:'<code>public static void main(String[] fruits) {</code>\n<code>   String fruit1 = new String("apple");</code>\n<code>   String fruit2 = new String("orange");</code>\n<code>   String fruit3 = new String("pear");</code>\n<code>&nbsp;</code>\n<code>   fruit3 = fruit1;</code>\n<code>   fruit2 = fruit3;</code>\n<code>   fruit1 = fruit2;</code>\n<code>}</code>',answers:["None","One","Two","Three"]},{title:"Which of the following can fill in the blanks to make this code compile?",code:"<code> _______d = new_______ (1_000_000.00);</code>",answers:["double, double","double, Double","Double, double","None of the above"]},{title:"What does the following output?",code:'<code>1:  public class InitOrder {</code>\n<code>2:     public String first = "instance";</code>\n<code>3:     public InitOrder() {</code>\n<code>4:        first = "constructor";</code>\n<code>5:     }</code>\n<code>6:     { first = "block";  }</code>\n<code>7:     public void print() {</code>\n<code>8:        System.out.println(first);</code>\n<code>9:     }</code>\n<code>10:    public static void main(String... args) {</code>\n<code>11:      new InitOrder().print();\t</code>\n<code>12:    }</code>\n<code>13: }</code>',answers:["block","constructor","instance","The code does not compile."]},{title:"How many of the following lines compile?",code:"<code>int i = null;</code>\n<code>Integer in = null;</code>\n<code>String s = null;</code>",answers:["None","One","Two","Three"]},{title:"Which pairs of statements can accurately fill in the blanks in this table?",code:null,answers:["Blank 1: an instance method only, Blank 2: a static method only","Blank 1: an instance or static method, Blank 2: a static method only","Blank 1: an instance method only, Blank 2: an instance or static method","Blank 1: an instance or static method, Blank 2: an instance or static method"]},{title:"Which of the following does not compile?",code:null,answers:["double num = 2.718;","double num = 2._718;","double num = 2.7_1_8;","None of the above; they all compile."]},{title:"Which of the following lists of primitive numeric types is presented in order from smallest to largest data type?",code:null,answers:["byte, short, int, long","int, short, byte, long","short, byte, int, long","short, int, byte, long"]},{title:"Fill in the blank to make the code compile:",code:'<code>package animal;</code>\n<code>public class Cat {</code>\n<code>  public String name;</code>\n<code>  public static void main(String[] meow) {</code>\n<code>    Cat cat = new Cat();</code>\n<code>    ______________ = "Sadie";</code>\n<code>  }</code>\n<code>}</code>',answers:["cat.name","cat-name","cat.setName","cat[name]"]},{title:"Which of the following is the output of this code, assuming it runs to completion?",code:'<code>package store;</code>\n<code>public class Toy {</code>\n<code>   public void play() {</code>\n<code>      System.out.print("play-");</code>\n<code>   }</code>\n<code>   public void finalizer() {</code>\n<code>      System.out.print("clean-");</code>\n<code>   }</code>\n<code>   public static void main(String[] fun) {</code>\n<code>      Toy car = new Toy();</code>\n<code>      car.play();</code>\n<code>      System.gc();</code>\n<code>      Toy doll = new Toy();</code>\n<code>      doll.play();</code>\n<code>   }</code>\n<code>}</code>',answers:["play-","play-play-","play-clean-play-","play-play-clean-clean-"]},{title:"Which is the most common way to fill in the blank to implement this method?",code:"<code>public class Penguin {</code>\n<code>&nbsp;</code>\n<code>   private double beakLength;</code>\n<code>&nbsp;</code>\n<code>   public static void setBeakLength(Penguin p, int b) {</code>\n<code>      _____________________________</code>\n<code>   }</code>\n<code>}</code>",answers:["p.beakLength = b;","p['beakLength'] = b;","p[beakLength] = b;","None of the above"]},{title:"Fill in the blanks to indicate whether a primitive or wrapper class can be assigned without the compiler using the autoboxing feature.",code:'<code> _______first = Integer.parseInt("5");</code>\n<code> _______second = Integer.valueOf("5");</code>',answers:["int, int","int, Integer","Integer, int","Integer, Integer"]},{title:"How many objects are eligible for garbage collection right before the end of the main method?",code:"<code>1:   public class Person {</code>\n<code>2:      public Person youngestChild;</code>\n<code>3:</code>\n<code>4:      public static void main(String... args) {</code>\n<code>5:         Person elena = new Person();</code>\n<code>6:         Person diana = new Person();</code>\n<code>7:         elena.youngestChild = diana;</code>\n<code>8:         diana = null;</code>\n<code>9:         Person zoe = new Person();</code>\n<code>10:        elena.youngestChild = zoe;</code>\n<code>11:        zoe = null;</code>\n<code>12:     }</code>\n<code>13:   }</code>",answers:["None","One","Two","Three"]},{title:"Which is a valid constructor for this class?",code:"<code>public class TennisBall {</code>\n<code>}</code>",answers:["public TennisBall static create() { return new TennisBall(); }","public TennisBall static newInstance() { return new TennisBall():}","public TennisBall() {}","public void TennisBall() {}"]},{title:"Which of the following is not a possible output of this code, assuming it runs to completion?",code:'<code>package store;</code>\n<code>public class Toy {</code>\n<code>   public void play() {</code>\n<code>      System.out.print("play-");</code>\n<code>   }</code>\n<code>   public void finalize() {</code>\n<code>      System.out.print("clean-");</code>\n<code>   }</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Toy car = new Toy();</code>\n<code>      car.play();</code>\n<code>      System.gc();</code>\n<code>      Toy doll = new Toy();</code>\n<code>      doll.play();</code>\n<code>   }</code>\n<code>}</code>',answers:["play-","play-play-","play-play-clean-","play-play-clean-clean-"]},{title:"Which converts a primitive to a wrapper class object without using autoboxing?",code:null,answers:["Call the asObject() method","Call the constructor of the wrapper class","Call the convertToObject() method","Call the toObject() method"]},{title:"What is the output of the following?",code:'<code>package beach;</code>\n<code>public class Sand {</code>\n<code>   public Sand() {</code>\n<code>      System.out.print("a");</code>\n<code>   }</code>\n<code>   public void Sand() {</code>\n<code>      System.out.print("b");</code>\n<code>   }</code>\n<code>   public void run() {</code>\n<code>      new Sand();</code>\n<code>      Sand();</code>\n<code>   }</code>\n<code>   public static void main(String... args) {</code>\n<code>      new Sand().run();</code>\n<code>   }</code>\n<code>}</code>',answers:["a","ab","aab","None of the above"]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t],ol:e.ol}});i[18].imageUrl="./images/image-oca-ch2-19.png",i[38].imageUrl="./images/image-oca-ch2-39.png",t.default=i},159:function(e,t,o){"use strict";o.r(t);var n=["B. A switch statement supports the primitive types byte, short, char, and int and the classes String, Character, Byte, Short, and Integer. It also supports enumerated types. Floating-point types like float and double are not supported, therefore Option B is the correct answer.","A. Remember that in ternary expressions, only one of the two right-most expressions are evaluated. Since meal>6 is false, \u2013\u2013tip is evaluated and ++tip is skipped. The result is that tip is changed from 2 to 1, making Option A the correct answer. The value of total is 6, since the pre-increment operator was used on tip, although you did not need to know this to solve the question.",'C. The first assignment creates a new String "john" object. The second line explicitly uses the new keyword, meaning a new String object is created. Since these objects are not the same, the == test on them evaluates to false. The equals() test on them returns true because the values they refer to are equivalent. Therefore, the correct answer is C.',"D. This code does not compile because it has two else statements as part of a single if-then statement. Notice that the second if statement is not connected to the last else statement. For this reason, Option D, none of the above, is the correct answer.","C. A default statement inside a switch statement is optional and can be placed in any order within the switch\u2019s case statements, making Options A and B incorrect. Option D is an incorrect statement as a switch statement can be composed of a single default statement and no case statements. Option C is correct because a default statement does not take a value, unlike a case statement.","B. The initial assignment of thatNumber follows the first branch of the ternary expression. Since 5 >= 5 evaluates to true, a value of 3 is assigned to thatNumber. In the next line, the pre-increment operator increments the value of thatNumber to 4 and returns a value of 4 to the expression. Since 4 < 4 evaluates to false, the if-then block is skipped. This leaves the value of thatNumber as 4, making Option B the correct answer.","B. The break statement exits a switch statement, skipping all remaining branches, making Option B the correct answer. In Option A, exit is not a statement in Java. In Option C, goto is a reserved word but unused in Java. Finally, in Option D, continue is a statement but only used for loops.","C. Option A is incorrect as only one of the two right-hand expressions is evaluated at runtime. Parentheses are often helpful for reading ternary expressions but are not required, making Option B incorrect. Option C is a correct statement about ternary operators as they are commonly used to replace short if-then-else statements. Finally, Option D is incorrect as only boolean expressions are permitted in the left-most operand of a ternary expression.","C. On line 4, candidateA and candidateB are numbers, but the && operation can only be applied to boolean expressions. Therefore, the code does not compile because of line 4, making C the correct answer. All of the other lines are correct. Note that if line 4 is fixed, line 3 does not produce a NullPointerException at runtime. The conditional || and the preceding null check allows the code to only call intValue() if candidateA is not null.","A. The first step is to determine whether or not the if-then statement\u2019s expression is executed. The expression 6 % 3 evaluates to 0, since there is no remainder, and since 0 >= 1 is false, the expression triceratops++ is not called. Notice there are no brackets {} in the if-then statement. Despite the triceratops\u2013\u2013 line being indented, it is not part of the if-then statement. Recall that Java does not use indentation to determine the beginning or end of a statement. Therefore, triceratops\u2013\u2013 is always executed, resulting in a value of 2 for triceratops and making Option A the correct answer.","D. Option A is incorrect because else statements are entirely optional. Option B is also incorrect. The target of an if-then statement is not evaluated if the boolean test is false. Option C is incorrect. While an if-then statement is often used to test whether an object is of a particular type in order to cast it, it is not required to cast an object. Option D is correct as an if-then statement may execute a single statement or a block of code {}.","D. For this question, it helps to notice that the second if-then statement is not connected to the first if-then statement, as there is no else joining them. When this code executes, the first if-then statement outputs Not enough since flair is >= 15 and < 37. The second if-then statement is then evaluated. Since flair is not 37, the expression Too many is outputted. Since two statements are outputted, Option D, none of the above, is the correct answer.","B. A case value must be a constant expression, such as a literal or final variable, so Options A and C are true statements about case values. A case statement may be terminated by a break statement, but it is not required, making Option B the false statement and correct answer. Option D is also a true statement about case values.","D. The question is about boolean operators. Since Options A and B are numeric operators, they can be instantly disregarded. The question then simplifies to which boolean expression, && or ||, corresponds to the truth table that only evaluates to true if both operands are true. Only the conjunctive logical && operator represents this relationship, making Option D the correct answer.","C. The value of jumps and hops is unimportant because this code does not compile, making Option C the correct answer. Unlike some other programming languages, Java does not automatically convert integers to boolean values for use in if-then statements. The statement if(jumps) evaluates to if(0), and since 0 is not a boolean value, the code does not compile. Note that the value of the jumps variable is irrelevant in this example; no integer evaluates to a boolean value in Java.","B. Prefix operators modify the variable and evaluate to the new value, while postfix operators modify the variable but return the original value. Therefore, Option B is the correct answer.","B. For this problem, it helps to recognize that parentheses take precedence over the operations outside the parentheses. Once we replace the variables with values, the expression becomes: 3+2*(2+3). We then calculate the value inside the parentheses to get 3+2*5. Since the multiplication operator has higher precedence than addition, we evaluate it first, resulting in 3+10 = 13, making Option B the correct answer.","B. Any value that can be implicitly promoted to int will work for the case statement with an int input. Since switch statements do not support long values, and long cannot be converted to int without a possible loss of data, Option B is the correct answer.","D. While parentheses are recommended for ternary operations, especially embedded ones, they are not required, so Option C is incorrect. The code does not compile because day is an int, not a boolean expression, in the second ternary operation, making Option D the correct answer. Remember that in Java, numeric values are not accepted in place of boolean expressions in if-then statements or ternary operations.","C. While the code involves numerous operations, none of that matters for solving this problem. The key to solving it is to notice that the line that assigns the leaders variable has an uneven number of parentheses. Without balanced parentheses, the code will not compile, making Option C the correct answer.",'B. Remember that Java evaluates + from left to right. The first two values are both numbers, so the + is evaluated as numeric addition, resulting in a reduction to 11 + "7" + 8 + 9. The next two terms, 11 + "7", are handled as string concatenation since one of the terms is a String. This allows us to reduce the expression to "117" + 8 + 9. Likewise, the final two terms are each evaluated one at a time with the String on the left. Therefore, the final value is 11789, making Option B the correct answer.',"B. The subtraction - operator is used to find the difference between two numbers, while the modulus % operator is used to find the remainder when one number is divided by another, making Option B the correct answer. The other options use operators that do not match this description.","B. The code compiles without issue, making Option D incorrect. The focus of this question is showing how the division and modulus of two numbers can be used to reconstitute one of the original operands. In this example, partA is the integer division of the two numbers. Since 3 does not divide 11 evenly, it is rounded down to 3. The variable partB is the remainder from the first expression, which is 2. The newDog variable is an expression that reconstitutes the original value for dog using the division value and the remainder. Note that due to operator precedence, the multiplication * operation is evaluated before the addition + operation. The result is the original value of 11 for dog is outputted by this program.","B. The code compiles without issue, so Option D is incorrect. In this question\u2019s switch statement, there are no break statements. Once the matching case statement, 30, is reached, all remaining case statements will be executed. The variable eaten is increased by 1, then 2, then reduced by 1, resulting in a final value of 2, making Option B the correct answer.","C. Ternary operations require both right-hand expressions to be of compatible data types. In this example, the first right-hand expression of the outer ternary operation is of type String, while the second right-hand expression is of type int. Since these data types are incompatible, the code does not compile, and Option C is the correct answer.","A. For this question, remember that if two String objects evaluate to true using ==, then they are the same object. If they are the same String object, equals() will trivially return true. Option A correctly reflects this principle. Option B is incorrect as two String objects that are not the same may still be equivalent in terms of equals(). For example, apples == new String(apples) evaluates to false, but equals() will evaluate to true on these String objects. Likewise, Options C and D are also incorrect because two String objects that are equivalent in terms of equals() may be different objects.","B. The statement compiles and runs without issue, making Options C and D incorrect. Since we are given that myTestVariable is not null, the statement will always evaluate to false, making Option B the correct answer. Note that if myTestVariable was null, then the code would still compile but throw a NullPointerException calling equals() at runtime.","D. The code does not compile, making Option D the correct answer. The reason the code does not compile is due to the test in the second if-then statement. The expression (streets && intersections > 1000) is invalid because streets is not a boolean expression and cannot be used as the left-hand side of the conjunctive logical && operator. The line of code is designed to resemble the corrected expression (streets > 1000 && intersections > 1000. Notice the fixed expression requires two relational > operators. If the second if-then statement was corrected, then the application would compile and produce two 1\u2019s, making Option C the correct answer.","B. The & and && (AND) operators are not interchangeable, as the conjunctive & operator always evaluates both sides of the expression, while the conditional conjunctive && operator only evaluates the right-hand side of the expression if the left side is determined to be true. This is why conditional operators are often referred to as short-circuit operators, skipping the right-hand side expression at runtime. For these reasons, Option B is the correct answer. Note that Option C is an incorrect statement as well, since it describes disjunctive (OR) operators.","C. The code compiles, so Option A is incorrect. Since w starts out true, the third line takes the first right-hand side of the ternary expression returning and assigning 5 to x (post-increment operator) while incrementing y to 6. Note that the second right-hand side of the ternary expression y\u2013\u2013 is not evaluated since ternary operators only evaluate one right-hand expression at runtime. On the fourth line, the value of w is set to !z. Since z is false, the value of w remains true. The final line outputs the value of (5+6) and (true ? 5 : 10), which is 11 5, making Option C the correct answer.",'A. The first assignment actually uses two String objects, the literal "bob" and the String created with the new keyword. Regardless, only the second object is assigned to the variable bob. The second variable, notBob, is assigned a reference to the value of the bob variable. This means that not only does the equals() test pass, but they are actually the same object, so the == test is true as well. Therefore, the correct answer is Option A.',"B. The question is about operator precedence and order of operation. The multiplication * and modulus % operators have the highest precedence, although what is inside the parentheses needs to be evaluated first. We can reduce the expression to the following: 12 + 6 * 3 % 2. Since multiplication * and modulus % have the same operator precedence, we evaluate them from left to right as follows: 12 + 6 * 3 % 2 \u2192 12 + 18 % 2 \u2192 12 + 0 \u2192 12. We see that despite all of the operators on the right-hand side of the expression, the result is zero, leaving us a value of 12, making Option B the correct answer.","D. The XOR ^ operator evaluates to true if p and q differ and false if they are the same. Therefore, the missing values are true and false, making Option D the correct answer.","C. The key to understanding this question is to remember that the conditional conjunction && operator only executes the right-hand side of the expression if the left-hand side of the expression is true. If data is an empty array, then the expression ends early and nothing is output. The second part of the expression will return true if data\u2019s first element is sound or logic. Since we know from the first part of the statement that data is of length at least one, no exception will be thrown. The final part of the expression with data.length<2 doesn\u2019t change the output when data is an array of size one. Therefore, sound and logic are both possible outputs. For these reasons, Option C is the only result that is unexpected at runtime.","C. In Option A, the division operator / incorrectly comes after the decrement \u2013\u2013 operator. In Option B, the subtraction operator - incorrectly comes after the modulus % operator. In Option D, the division operator / incorrectly comes after the subtraction - operator. The correct answer is Option C, where all three operators have the same order of precedence.","D. The exclusive or (XOR) ^ operator requires evaluating both operands to determine the result. For this reason, Options A and B are incorrect. For Option B, you can\u2019t have a short-circuit operation if both operands are always read, therefore ^^ does not exist. Option C is an incorrect statement as the ^ operator only returns true if exactly one operand is true. Finally, Option D is correct as the ^ is only applied to boolean values in Java.","C. The diagram represents the overlap of x and y, corresponding to when one of them is true. Therefore, x || y, Option C, most closely matches this relationship. Note that z is unused in the diagram and therefore is not required in any expression.","D. The value of a case statement must be constant, a literal value, or final variable. Since red is missing the final attribute, no variable type allows the code to compile, making Option D the correct answer.","C. The question is asking which operator represents greater than or equal to and which operator is strictly less than. The >= and < correspond to these operators, respectively. Therefore, Option C is the correct answer. Note that the question does not specify which order the operators needed to appear in, only to select the two operators that match the question description.","B. The code compiles and runs without issue, making Options C and D incorrect. The key here is understanding operator precedence and applying the parentheses to override precedence correctly. The first expression is evaluated as follows: 10 * (2 + (3 + 2) / 5) \u2192 10 * (2 + 5 / 5) \u2192 10 * (2 + 1) \u2192 10 * 3, with a final value of 30 for turtle. Since turtle is not less than 5, a value of 25 is assigned to hare. Since turtle is not less than hare, the last expression evaluates to Turtle wins!, which is outputted to the console, making Option B the correct answer.",'A. All of the terms of getResult() in this question evaluate to 0, since they are all less than or equal to 5. The expression can therefore be reduced to 0+0+0+0+"". Since Java evaluates the + operator from left to right, the four operands on the left are applied using numeric addition, resulting in the expression 0+"". This expression just converts the value to a String, resulting in an output of 0, making Option A the correct answer.',"A. The code compiles without issue, so Option D is incorrect. The key here is that the if-then statement in the runTest() method uses the assignment operator (=) instead of the (==) operator. The result is that spinner is assigned a value of true, and the statement (spinner = roller) returns the newly assigned value. The method then returns up, making Option A the correct answer. If the (==) operator had been used in the if-then statement, then the process would have branched to the else statement, with down being returned by the method.","D. The conditional disjunction (OR) || operator is true if either of the operands are true, while the logical complement (!) operator reverses or flips a boolean value, making Option D the correct answer. The other options use operators that do not match this description. In particular, Options A and C include operators that can only be applied to numerical values, not boolean ones.","A. While parentheses are recommended for ternary operations, especially embedded ones, they are not required, so Option C is incorrect.. The first ternary operation evaluates characters <= 4 as false, so the second ternary operation is executed. Since story > 1 is true, the final value of movieRating is 2.0, making Option A the correct answer.","B. Barring any JVM limitations, a switch statement can have any number of case statements (including none) but at most one default statement, with Option B correctly identifying this relationship.","A. The application uses the conditional conjunction && operator to test if weather[0] is null, but unfortunately this test does not work on zero-length arrays. Therefore, it is possible this code will throw an ArrayIndexOutOfBoundsException at runtime. The second part of the expression evaluates to true if the first input of weather matches sunny. The final part of the expression, && !false, is a tautology in that it is always true and has no impact on the expression. Either an exception will be thrown or text will be output, based on the value of weather, therefore Option A is the correct answer.","D. The question looks a lot more difficult than it is. In fact, to solve it you don\u2019t have to compute anything! You just have to notice that the logical complement operator (!), which can only be applied to boolean values, is being applied to a numeric value. Therefore, the answer is that the expression wouldn\u2019t compile or run, making Option D the correct answer.","C. The disjunctive logical || operator evaluates to true if either operand is true. Another way to look at it is that it only evaluates to false if both operands are false. Therefore, the missing values are both true, making Option C the correct answer.","A. In Option B, the subtraction operator - incorrectly comes after the decrement \u2013\u2013 operator. In Option C, the division operator / incorrectly comes after the increment ++ operator. In Option D, the modulus operator % incorrectly comes after the increment ++ operator. The correct answer is Option A, where the subtraction - and addition + operators are followed by the division / and multiplication * operators.","C. The key to solving this problem is remembering that the type of the value returned by a ternary operation is determined by the expressions on the right-hand side. On line p1, the expressions are of type int, but the assignment is to the variable game, of type String. Since the assignment is invalid, the code does not compile, and Option C is correct."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"Which of the following variable types is not permitted in a switch statement?",code:null,answers:["String","double","int","char"]},{title:"What is the value of tip after executing the following code snippet?",code:"<code>int meal = 5;</code>\n<code>int tip = 2;</code>\n<code>int total = meal + (meal&gt;6 ? ++tip : \u2010\u2010tip);</code>",answers:["1","2","3","6"]},{title:"What is the output of the following application?",code:'<code>package registration;</code>\n<code>public class NameCheck {</code>\n<code>   public static void main(String... data) {</code>\n<code>      String john = "john";</code>\n<code>      String jon = new String(john);</code>\n<code>      System.out.print((john==jon)+" "+(john.equals(jon)));</code>\n<code>   }</code>\n<code>}</code>',answers:["true true","true false","false true","false false"]},{title:"What is the output of the following application?",code:'<code>package planning;</code>\n<code>public class ThePlan {</code>\n<code>   public static void main(String[] input) {</code>\n<code>      int plan = 1;</code>\n<code>      plan = plan++ + --plan;</code>\n<code>      if(plan==1) {</code>\n<code>         System.out.print("Plan A");</code>\n<code>      } else { if(plan==2) System.out.print("Plan B");</code>\n<code>      } else System.out.print("Plan C");</code>\n<code>   }</code>\n<code>}</code>',answers:["Plan A","Plan B","Plan C","None of the above"]},{title:"Which of the following statements about a default branch in a switch statement is correct?",code:null,answers:["All switch statements must include a default statement.","The default statement is required to be placed after all case statements.","Unlike a case statement, the default statement does not take a value.","A default statement can only be used when at least one case statement is present."]},{title:"What is the value of thatNumber after the execution of the following code snippet?",code:"<code>long thatNumber = 5 &gt;= 5 ? 1+2 : 1*1;</code>\n<code>if(++thatNumber &lt; 4)</code>\n<code>   thatNumber += 1;</code>",answers:["3","4","5","The answer cannot be determined until runtime."]},{title:"Which statement immediately exits a switch statement, skipping all remaining case or default branches?",code:null,answers:["exit","break","goto","continue"]},{title:"Which statement about ternary expressions is true?",code:null,answers:["In some cases, both expressions to the right of the conditional operator in a ternary expression will be evaluated at runtime.","Ternary expressions require parentheses for proper evaluation.","The ternary expressions are a convenient replacement for an if-then-else statement.","Ternary expressions support int and boolean expressions for the left-most operand."]},{title:"What is the output of the following application?",code:'<code>package voting;</code>\n<code>1: public class Election {</code>\n<code>2:     public void calculateResult(Integer candidateA, Integer candidateB) {</code>\n<code>3:       boolean process = candidateA == null || candidateA.intValue() &lt; 10;</code>\n<code>4:       boolean value = candidateA &amp;&amp; candidateB;</code>\n<code>5:       System.out.print(process || value);</code>\n<code><span epub:type="pagebreak" id="Page_36"></span>6:    }</code>\n<code>7:    public static void main(String[] unused) {</code>\n<code>8:       new Election().calculateResult(null,203);</code>\n<code>9:    }</code>\n<code>10: }</code>',answers:["true","false","The code does not compile.","The code compiles but throws a NullPointerException on line 3 at runtime."]},{title:"What is the output of the following application?",code:"<code>package dinosaur;</code>\n<code>public class Park {</code>\n<code>   public final static void main(String... arguments) {</code>\n<code>      int pterodactyl = 6;</code>\n<code>      long triceratops = 3;</code>\n<code>      if(pterodactyl % 3 &gt;= 1)</code>\n<code>         triceratops++;</code>\n<code>         triceratops--;</code>\n<code>      System.out.print(triceratops);</code>\n<code>   }</code>\n<code>}</code>",answers:["2","3","4","The code does not compile."]},{title:"Which statement about if-then statements is true?",code:null,answers:["An if-then statement is required to have an else statement.","If the boolean test of an if-then statement evaluates to false, then the target clause of the if-then statement will still be evaluated.","An if-then statement is required to cast an object.","An if-then statement can execute a single statement or a block {}."]},{title:"What is the output of the following application?",code:'<code>package restaurant;</code>\n<code>public class Pieces {</code>\n<code>   public static void main(String[] info) {</code>\n<code>      int flair = 15;</code>\n<code>      if(flair &gt;= 15 &amp;&amp; flair &lt; 37) {</code>\n<code>         System.out.print("Not enough");</code>\n<code><span epub:type="pagebreak" id="Page_37"></span>      } if(flair==37) {</code>\n<code>         System.out.print("Just right");</code>\n<code>      } else {</code>\n<code>         System.out.print("Too many");</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["Not enough","Just right","Too many","None of the above"]},{title:"Which statement about case statements of a switch statement is not true?",code:null,answers:["A case value can be final.","A case statement must be terminated with a break statement.","A case value can be a literal expression.","A case value must match the data type of the switch variable, or be able to be promoted to that type."]},{title:"Given the following truth table, which operator for the boolean expressions x and y corresponds to this relationship?",code:null,answers:["--","++","||","&&"]},{title:"What is the output of the following code snippet?",code:'<code>int hops = 0;</code>\n<code>int jumps = 0;</code>\n<code>jumps = hops++;</code>\n<code>if(jumps)</code>\n<code>   System.out.print("Jump!");</code>\n<code>else</code>\n<code>   System.out.print("Hop!");</code>',answers:["Jump!","Hop!","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Fill in the blanks: The _____________ operator increases the value of a variable by 1 and returns the new value, while the _____________ operator decreases the value of a variable by 1 and returns the original value.",code:null,answers:["pre-increment [++v], pre-decrement [--v]","pre-increment [++v], post-decrement [v--]","post-increment [v++], pre-decrement [--v]","post-increment [v++], post-decrement [v--]"]},{title:"What is the output of the following application?",code:"<code>package jungle;</code>\n<code>public class TheBigRace {</code>\n<code>   public static void main(String[] in) {</code>\n<code>      int tiger = 2;</code>\n<code>      short lion = 3;</code>\n<code>      long winner = lion+2*(tiger + lion);</code>\n<code>      System.out.print(winner);</code>\n<code>   }</code>\n<code>&nbsp;</code>\n<code>}</code>",answers:["11","13","25","None of the above"]},{title:"Given the following code snippet, assuming dayOfWeek is an int, what variable type of saturday is not permitted?",code:'<code>final _________ saturday = 6;</code>\n<code>switch(dayOfWeek) {</code>\n<code>   default:</code>\n<code>      System.out.print("Another Weekday");</code>\n<code>      break;</code>\n<code>   case saturday:</code>\n<code>      System.out.print("Weekend!");</code>\n<code>}</code>',answers:["byte","long","int","None of the above"]},{title:"Given the following code snippet, what is the value of dinner after it is executed?",code:'<code>int time = 11;</code>\n<code>int day = 4;</code>\n<code>String dinner = time &gt; 10 ? day ? "Takeout" : "Salad" : "Leftovers";</code>',answers:["Takeout","Salad","The code does not compile but would compile if parentheses were added.","None of the above"]},{title:"What is the output of the following application?",code:'<code>package recreation;</code>\n<code>public class Dancing {</code>\n<code>   public static void main(String[] vars) {</code>\n<code>      int leaders = 10 * (2 + (1 + 2 / 5);</code>\n<code>      int followers = leaders * 2;</code>\n<code>      System.out.print(leaders + followers &lt; 10 ? "Too few" : "Too many");</code>\n<code>   }</code>\n<code>}</code>',answers:["Too few","Too many","The code does not compile.","The code compiles but throws a division by zero error at runtime."]},{title:"What is the output of the following application?",code:'<code>package schedule;</code>\n<code>public class PrintWeek {</code>\n<code>   public static final void main(String[] days) {</code>\n<code>      System.out.print(5 + 6 + "7" + 8 + 9);</code>\n<code>   }</code>\n<code>}</code>',answers:["56789","11789","11717","The code does not compile."]},{title:"Fill in the blanks: The______________  operator is used to find the difference between two numbers, while the______________  operator is used to find the remainder when one number is divided by another.",code:null,answers:["/, %","\u2013, %","%, <","\u2013, ||"]},{title:"What is the output of the following application?",code:"<code>package transporter;</code>\n<code>public class Rematerialize {</code>\n<code>   public static void main(String[] input) {</code>\n<code>      int dog = 11;</code>\n<code>      int cat = 3;</code>\n<code>      int partA = dog / cat;</code>\n<code>      int partB = dog % cat;</code>\n<code>      int newDog = partB + partA * cat;</code>\n<code>      System.out.print(newDog);</code>\n<code>   }</code>\n<code>}</code>",answers:["9","11","15","The code does not compile."]},{title:"What is the output of the following application?",code:"<code>package dessert;</code>\n<code>public class IceCream {</code>\n<code>   public final static void main(String... args) {</code>\n<code>      int flavors = 30;</code>\n<code>      int eaten = 0;</code>\n<code>      switch(flavors) {</code>\n<code>         case 30: eaten++;</code>\n<code>         case 40: eaten+=2;</code>\n<code>         default: eaten--;</code>\n<code>      }</code>\n<code>      System.out.print(eaten);</code>\n<code>   }</code>\n<code>}</code>",answers:["1","2","3","The code does not compile."]},{title:"What is the output of the following application?",code:'<code>package mode;</code>\n<code>public class Transportation {</code>\n<code>   public static String travel(int distance) {</code>\n<code>      return distance&lt;1000 ? "train" : 10;</code>\n<code>   }</code>\n<code>   public static void main(String[] answer) {</code>\n<code>      System.out.print(travel(500));</code>\n<code>   }</code>\n<code>}</code>',answers:["train","10","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Fill in the blanks: Given two non-null String objects with reference names apples______________ and oranges, if apples  oranges evaluates to true, then apples______________  oranges must also evaluate to true.",code:null,answers:["==, equals()","!=, equals()","equals(), ==","equals(), =!"]},{title:"For a given non-null String myTestVariable, what is the resulting value of executing the statement myTestVariable.equals(null)?",code:null,answers:["true","false","The statement does not compile.","The statement compiles but will produce an exception when used at runtime."]},{title:"How many 1s are outputted when the following application is compiled and run?",code:'<code>package city;</code>\n<code>public class Road {</code>\n<code>   public static void main(String... in) {</code>\n<code>      int intersections = 100;</code>\n<code><span epub:type="pagebreak" id="Page_42"></span>      int streets = 200;</code>\n<code>      if (intersections &lt; 150) {</code>\n<code>         System.out.print("1");</code>\n<code>      } else if (streets &amp;&amp; intersections &gt; 1000) {</code>\n<code>         System.out.print("2");</code>\n<code>      } if (streets &lt; 500)</code>\n<code>         System.out.print("1");</code>\n<code>      else</code>\n<code>         System.out.print("2");</code>\n<code>   }</code>\n<code>}</code>',answers:["None","One","Two","The code does not compile."]},{title:"Which statement about the logical operators & and && is true?",code:null,answers:["The & and && operators are interchangeable, always producing the same results at runtime.","The & operator always evaluates both operands, while the && operator may only evaluate the left operand.","Both expressions evaluate to true if either operand is true.","The & operator always evaluates both operands, while the && operator may only evaluate the right operand."]},{title:"What is the output of the following code snippet?",code:'<code>int x = 10, y = 5;</code>\n<code>boolean w = true, z = false;</code>\n<code>x = w ? y++ : y--;</code>\n<code>w = !z;</code>\n<code>System.out.print((x+y)+" "+(w ? 5 : 10));</code>',answers:["The code does not compile.","10 10","11 5","12 5"]},{title:"What is the output of the following application?",code:'<code>package bob;</code>\n<code>public class AreYouBob {</code>\n<code>   public static void main(String[] unused) {</code>\n<code><span epub:type="pagebreak" id="Page_43"></span>      String bob = new String("bob");</code>\n<code>      String notBob = bob;</code>\n<code>      System.out.print((bob==notBob)+" "+(bob.equals(notBob)));</code>\n<code>   }</code>\n<code>}</code>',answers:["true true","true false","false true","false false"]},{title:"What is the value of 12 + 6 * 3 % (1 + 1) in Java?",code:null,answers:["0","12","14","None of the above"]},{title:"Given the following truth table, the boolean variables p and q, and the expression p ^ q, what are the missing values in the truth table, starting with the first column?",code:null,answers:["false and true","false and false","true and true","true and false"]},{title:"Which of the following is not a possible result of executing the following application?",code:'<code>public class ConditionallyLogical {</code>\n<code>   public static void main(String... data) {</code>\n<code>      if(data.length&gt;=1</code>\n<code>            &amp;&amp; (data[0].equals("sound") || data[0].equals ("logic")) </code>\n<code>            &amp;&amp; data.length&lt;2) {</code>\n<code>         System.out.print(data[0]);</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["Nothing is printed.","sound is printed.","The application throws an exception at runtime.","logic is printed."]},{title:"Fill in the blanks: The operators +,______________ ,______________ ,______________  , and ++ are listed in the same or increasing level of operator precedence.",code:null,answers:["*, --, /","%, -, *","/, *, %","*, -, /"]},{title:"What statement about the ^ operator is correct?",code:null,answers:["If one of the operands of ^ is true, then the result is always true.","There is a conditional form of the operator, denoted as ^^.","If both operands of ^ are true, the result is true.","The ^ operator can only be applied to boolean values."]},{title:"Given the following Venn diagram and the variables, x, y, and z, which Java expression most closely represents the filled-in region of the diagram?",code:null,answers:["x || z","y || (y && z)","x || y","y && x"]},{title:"What variable type of red allows the following application to compile?",code:'<code>package tornado;</code>\n<code>public class Kansas {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      int colorOfRainbow = 10;</code>\n<code>      ________ red = 5;</code>\n<code><span epub:type="pagebreak" id="Page_45"></span>      switch(colorOfRainbow) {</code>\n<code>         default:</code>\n<code>            System.out.print("Home");</code>\n<code>            break;</code>\n<code>         case red:</code>\n<code>            System.out.print("Away");</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["long","double","int","None of the above"]},{title:"Which two operators would be used to test if a number is equal to or greater than 5.21 but strictly less than 8.1?",code:null,answers:["> and <=",">= and >","< and >=","< and >"]},{title:"What is the output of the following application?",code:'<code>package transporter;</code>\n<code>public class TurtleVsHare {</code>\n<code>   public static void main(String[] arguments) {</code>\n<code>      int turtle = 10 * (2 + (3 + 2) / 5);</code>\n<code>      int hare = turtle &lt; 5 ? 10 : 25;</code>\n<code>      System.out.print(turtle &lt; hare ? "Hare wins!" : "Turtle wins!");</code>\n<code>   }</code>\n<code>}</code>',answers:["Hare wins!","Turtle wins!","The code does not compile.","The code compiles but throws a division by zero error at runtime."]},{title:"What is the output of the following application?",code:'<code>public class CountEntries {</code>\n<code>   public static int getResult(int threshold) {</code>\n<code>      return threshold &gt; 5 ? 1 : 0;</code>\n<code><span epub:type="pagebreak" id="Page_46"></span>   }</code>\n<code>   public static final void main(String[] days) {</code>\n<code>      System.out.print(getResult(5)+getResult(1)</code>\n<code>         +getResult(0)+getResult(2)+"");</code>\n<code>   }</code>\n<code>}</code>',answers:["0","1","0000","1000"]},{title:"What is the output of the following application?",code:'<code>package yoyo;</code>\n<code>public class TestGame {</code>\n<code>   public String runTest(boolean spinner, boolean roller) {</code>\n<code>      if(spinner = roller) return "up";</code>\n<code>      else return roller ? "down" : "middle";</code>\n<code>   }</code>\n<code>   public static final void main(String pieces[]) {</code>\n<code>      final TestGame tester = new TestGame();</code>\n<code>      System.out.println(tester.runTest(false,true));</code>\n<code>   }</code>\n<code>}</code>',answers:["up","middle","down","The code does not compile."]},{title:"Fill in the blanks: The______________  operator is true if either of the operands are true, while the______________  operator flips a boolean value.",code:null,answers:["+, -","&&, !","|, -","||, !"]},{title:"Given the following code snippet, what is the value of movieRating after it is executed?",code:"<code>int characters = 5;</code>\n<code>int story = 3;</code>\n<code>double movieRating = characters &lt;= 4 ? 3 : story&gt;1 ? 2 : 1;</code>",answers:["2.0","3.0","The code does not compile but would compile if parentheses were added.","None of the above"]},{title:"Fill in the blanks: A switch statement can have______________  case statements and______________  default statements.",code:null,answers:["at most one, at least one","any number of, at most one","at least one, any number of","at least one, at most one"]},{title:"Which of the following is not a possible result of executing the following application?",code:'<code>&nbsp;</code>\n<code>public class OutsideLogic {</code>\n<code>   public static void main(String... weather) {</code>\n<code>      System.out.print(weather[0]!=null</code>\n<code>            &amp;&amp; weather[0].equals("sunny")</code>\n<code>            &amp;&amp; !false</code>\n<code>         ? "Go Outside" : "Stay Inside");</code>\n<code>   }</code>\n<code>}</code>',answers:["Nothing is printed.","The application throws an exception at runtime.","Go Outside is printed.","Stay Inside is printed."]},{title:"What is the value of (5 + (!2 + 8) * 3 - 3 % 2)/2 in Java?",code:null,answers:["2","11","16","None of the above"]},{title:"Given the following truth table, the boolean variables w and z, and the expression w || z, what are the missing values in the truth table, starting with the first row?",code:null,answers:["false and false","true and false","true and true","false and true"]},{title:"Fill in the blanks: The operators \u2013,______________ ,______________ ,______________  , and % are listed in the same or increasing level of operator precedence.",code:null,answers:["+, /, *","--, -, *","++, /, *","*, ++, %"]},{title:"What is the output of the following application?",code:'<code>public class Baby {</code>\n<code>   public static String play(int toy, int age) {</code>\n<code>      final String game;</code>\n<code>      if(toy&lt;2)</code>\n<code>         game = age &gt; 1 ? 1 : 10; // p1</code>\n<code>      else</code>\n<code>         game = age &gt; 3 ? "Ball" : "Swim"; // p2</code>\n<code>      return game;</code>\n<code>   }</code>\n<code>   public static void main(String[] variables) {</code>\n<code>      System.out.print(play(5,2));</code>\n<code>   }</code>\n<code>}</code>',answers:["Ball","Swim","The code does not compile due to p1.","The code does not compile due to p2."]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t]}});i[13].imageUrl="./images/image-oca-ch3-14.png",i[32].imageUrl="./images/image-oca-ch3-33.png",i[36].imageUrl="./images/image-oca-ch3-37.png",i[47].imageUrl="./images/image-oca-ch3-48.png",t.default=i},160:function(e,t,o){"use strict";o.r(t);var n=["B. Three dots (...) are the syntax for a method parameter of type varargs. It is treated like an array.","B. Array indexes are zero based in Java. A varargs parameter is simply another way of passing in data to a method. From within the method, it is treated just like you had written Frisbee[] f as the method parameter. Therefore, the first element uses the 0th index, and Option B is correct.","D. Trick question! While int is a primitive, all arrays are objects. One way to tell is that an array has a public instance variable called length. Another way is that you can assign it a variable of type Object. Therefore, Option D is correct.","C. The array braces are allowed to appear before or after the variable name, making the tiger and bear declarations correct. The braces are not allowed to appear before the type making the lion declaration incorrect. Therefore, Option C is correct.","C. From within a method, an array or varargs parameter is treated the same. However, there is a difference from the caller\u2019s point of view. A varargs parameter can receive either an array or individual values, making Options A and B compile. However, an array parameter can only take an array, which prevents Option C from compiling.","A. Arrays use the length variable to determine the number of elements, making Option A correct. For an ArrayList, Option D would have been the answer.","C. A two-dimensional array is declared by listing both sizes in separate pairs of braces. Option C correctly shows this syntax.","B. There is nothing wrong with this code. It correctly creates a seven-element array. The loop starts with index 0 and ends with index 6. Each line is correctly output. Therefore, Option B is correct.","B. Sorry. This is just something you have to memorize. The sort() and binarySearch() methods do sorting and searching, respectively.","B. The elements of the array are of type String rather than int. Therefore, we use alphabetical order when sorting. The character 1 sorts before the character 9, alphabetically making Option A incorrect. Shorter strings sort before longer strings when all the other characters are the same, making Option B the answer.","B. Array indices start with 0, making Options C and D incorrect. The length attribute refers to the number of elements in an array. It is one past the last valid array index. Therefore, Option B is correct.","C. When using an array initializer, you are not allowed to specify the size separately. The size is inferred from the number of elements listed. Therefore, tiger and ohMy are incorrect. When you\u2019re not using an array initializer, the size is required. An empty array initializer is allowed. Option C is correct because lion and bear are legal.","B. Since no elements are being provided when creating the arrays, a size is required. Therefore, lion and bear are incorrect. The braces containing the size are required to be after the type, making ohMy incorrect. The only one that is correct is tiger, making the correct answer Option B.","C. The binarySearch() method requires a sorted array in order to return a correct result. If the array is not sorted, the results of a binary search are undefined.","A. An ArrayList expands automatically when it is full. An array does not, making Option A the answer. The other three statements are true of both an array and an ArrayList.","C. This code creates a two-dimensional array of size 1\xd72. Lines m1 and m2 assign values to both elements in the outer array. Line m3 attempts to reference the second element of the outer array. Since there is no such position, it throws an exception, and Option C is correct.",'B. The code sorts before calling binarySearch(), so it meets the precondition for that method. The target string of "Mac" is the second element in the sorted array. Since array indices begin with zero, the second position is index 1, and Option B is correct.',"A. A multi-dimensional array is created with multiple sets of size parameters. The first line should be char[] ticTacToe = new char[3][3];. Therefore, Option A is the answer.","B. The first line creates one object; the array itself. While there are four references to null in that array, none of those are objects. The second line creates one object and points one of the array references to it. So far there are two objects: the array itself and one object it is referencing. The third line does the same, bringing up the object count to three. Therefore, Option B is correct.","B. As with a one-dimensional array, the braces must be after the type, making alpha and beta illegal declarations. For a multi-dimensional array, the braces are allowed to be before and/or after the variable name. They do not need to be in the same place. Therefore, the remaining three are correct, and Option B is correct.","B. Options A, C and D represent 3x3 2D arrays. Option B best represents the array in the code. It shows there are three different arrays of different lengths.","D. names.length is the number of elements in the array. The last valid index in the array is one less than names.length. In Java, arrays do not resize automatically. Therefore, the code throws an ArrayIndexOutOfBoundsException.","C. The code days.size() would be correct if this was an ArrayList. Since it is an array, days.length is the correct code. Therefore, the code does not compile, and Option C is the answer.","C. Since the braces in the declaration are before the variable names, the variable type boolean[][][] applies to both variables. Therefore, both bools and moreBools can reference a 3D array.","C. Calling toString() on an array doesn\u2019t output the contents of the array, making Option C correct. If you wanted Option A to be the answer, you\u2019d have to call Arrays.toString(strings).","B. Arrays begin with an index of 0. This array is a 3\xd73 array. Therefore. only indexes 0, 1. and 2 are valid. Line r2 throws an ArrayIndexOutOfBoundsException. Therefore. Option B is correct.","D. Three dots in a row is a varargs parameter. While varargs is used like an array from within the method, it can only be used as a method parameter. This syntax is not allowed for a variable, making Option D the answer.","D. Line 6 assigns an int to a cell in a 2D array. This is fine. Line 7 casts to a general Object[]. This is dangerous, but legal. Why is it dangerous, you ask? That brings us to line 8. The compiler can\u2019t protect us from assigning a String to the int[] because the reference is more generic. Therefore, line 8 throws an ArrayStoreException because the type is incorrect, and Option D is correct. You couldn\u2019t have assigned an int on line 8 either because obj[3] is really an int[] behind the scenes and not an int.",'C. The code sorts before calling binarySearch, so it meets the precondition for that method. The target string of "RedHat" is not found in the sorted array. If it was found, it would be between the second and third element. The rule is to take the negative index of where it would be inserted and subtract 1. It would need to be inserted as the third element. Since indexes are zero based, this is index 2. We take the negative, which is -2, and subtract 1, giving -3. Therefore, Option C is correct.',"B. Array indexes begin with zero. FirstName is the name of the class, not an argument. Therefore, the first argument is Wolfie, and Option B is correct.","C. The name of the program is Count and there are two arguments. Therefore, the program outputs 2, and Option C is correct.","B. This class is called with two arguments. The first one (seed) is stored in the variable one. Then the array is sorted, meeting the precondition for binary search. Binary search returns 1 because seed is the second element in the sorted array, and Java uses zero-based indexes. Option B is correct.","D. Options A and B show the braces can be before or after the variable name and produce the same array. Option C specifies the same array the long way with two arrays of length 1. Option D is the answer because it is different than the others. It instead specifies an array of length 1 where that element is of length 2.","C. Arrays are indexed using numbers, not strings, making Options A and B incorrect. Since array indexes are zero based, Option C is the answer.","D. In Java, arrays are indexed starting with 0. While it is unusual for the loop to start with 1, this does not cause an error. What does cause an error is the loop ending at data.length, because the <= operator is used instead of the < operator. The last loop index is 6, not 7. On the last iteration of the loop, the code throws an ArrayIndexOutOfBoundsException. Therefore, Option D is correct.","C. Array indexes begin with zero. FirstName is the name of the class, not an argument. The first and only argument is Wolfie. There is not a second argument, so Option C is correct.","D. This code is correct. Line r1 correctly creates a 2D array. The next three lines correctly assign a value to an array element. Line r3 correctly outputs 3 in a row!","D. Arrays expose a length variable. They do not have a length() method. Therefore, the code does not compile, and Option D is correct.","B. This one is tricky since the array braces are split up. This means that bools is a 3D array reference. The braces both before and after the variable name count. For moreBools, it is only a 2D array reference because there are only two pairs of braces next to the type. In other words, boolean[][] applies to both variables. Then bools gets another dimension from the braces right after the variable name. However, moreBools stays at 2D, making Option B correct.","B. Since no arguments are passed from the command line, this creates an empty array. Sorting an empty array is valid and results in an empty array. Therefore, Option B is correct.","D. Java requires having a sorted array before calling binarySearch. Since the array is not sorted, the result is undefined, and Option D is correct. It may happen that you get 1 as the result, but this behavior is not guaranteed. You need to know for the exam that this is undefined even if you happen to get the \u201cright\u201d answer.","B. Line 8 attempts to store a String in an array meant for an int. Line 8 does not compile, and Option B is correct. ","A. This array has two elements, making listing.length output 2. While each array element does not have the same size, this does not matter because we are only looking at the first element. The first element has one. This makes the answer Option A.","C. FirstName is the name of the class, not an argument. There are no other arguments, so names is an empty array. Therefore, Option C is correct.","A. In Java, arrays are indexed starting with 0. While it is unusual for the loop to start with 1, this does not cause an error. It does cause the code to output six lines instead of seven since the loop doesn\u2019t cover the first array element. Therefore, Option A is correct.","B. The name of the program is Count, and there is only one argument because double quotes are used around the value. That argument is a String with three characters: 1, a space, and 2. Therefore, the program outputs 1, and Option B is correct.",'A. Java requires having a sorted array before calling binarySearch(). You do not have to call Arrays.sort to perform the sort though. This array happens to already be sorted, so it meets the precondition. The target string of "Linux" is the first element in the array. Since Java uses zero-based indexing, the answer is Option A.',"A. From within a method, an array parameter and a varargs parameter are treated the same. From the caller, an array parameter is more restrictive. Both types can receive an array. However, only a varargs parameter is allowed to automatically turn individual parameters into an array. Therefore, statement I is correct and the answer is Option A.","B. All of the variables except nums2b point to a 4D array. Don\u2019t create a 4D array; it\u2019s confusing. The options show the braces can be before or after the variable in any combination. Option B is the answer because nums2b points to a 3D array. It only has three pairs of braces before the variable and none after. By comparison, nums2a has three pairs of braces before the variable and the fourth pair of braces after.","C. Binary search returns an int representing the index of a match or where a match would be. An int cannot be stored in a String variable. Therefore, the code does not compile and the answer is Option C."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"What symbol is used for a varargs method parameter?",code:null,answers:["..","...","--","---"]},{title:"Fill in the blank in the following code to get the first element from the varargs parameter.",code:"<code>public void toss (Frisbee... f) {</code>\n<code>   Frisbee first = ____________;</code>\n<code>}</code>",answers:["f","f[0]","f[1]","None of the above"]},{title:"Which of the following are primitives?",code:"<code>int[] lowercase = new int[0];</code>\n<code>Integer[] uppercase = new Integer[0];</code>",answers:["Only lowercase","Only uppercase","Bother lowercase and uppercase","Neither lowercase nor uppercase"]},{title:"How many of the following are legal declarations?",code:"<code>[]double lion;</code>\n<code>double[] tiger;</code>\n<code>double bear[];</code>",answers:["None","One","Two","Three"]},{title:"Given the following two methods, which method call will not compile?",code:"<code>public void printStormName(String... names) {</code>\n<code>   System.out.println(Arrays.toString(names));</code>\n<code>}</code>\n<code>public void printStormNames(String[] names) {</code>\n<code>   System.out.println(Arrays.toString(names));</code>\n<code>}</code>",answers:['printStormName("Arlene");','printStormName(new String[] { "Bret" });','printStormNames("Cindy");','printStormNames(new String[] { "Don" });']},{title:"How do you determine the number of elements in an array?",code:null,answers:["buses.length","buses.length()","buses.size","buses.size()"]},{title:"Which of the following create an empty two-dimensional array with dimensions 2\xd72?",code:null,answers:["int[][] blue = new int[2, 2];","int[][] blue = new int[2], [2];","int[][] blue = new int[2][2];","int[][] blue = new int[2 x 2];"]},{title:"How many lines does the following code output?",code:'<code>String[] days = new String[] { "Sunday", "Monday", "Tuesday",</code>\n<code>      "Wednesday", "Thursday", "Friday", "Saturday" };</code>\n<code>for (int i = 0; i &lt; days.length; i++)</code>\n<code>      System.out.println(days[i]);</code>',answers:["Six","Seven","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What are the names of the methods to do searching and sorting respectively on arrays?",code:null,answers:["Arrays.binarySearch() and Arrays.linearSort()","Arrays.binarySearch() and Arrays.sort()","Arrays.search() and Arrays.linearSort()","Arrays.search() and Arrays.sort()"]},{title:"What does this code output?",code:'<code>String[] nums = new String[] { "1", "9", "10" };</code>\n<code>Arrays.sort(nums);</code>\n<code>System.out.println(Arrays.toString(nums));</code>',answers:["[1, 9, 10]","[1, 10, 9]","[10, 1, 9]","None of the above"]},{title:"Which of the following references the first and last element in a non-empty array?",code:null,answers:["trains[0] and trains[trains.length]","trains[0] and trains[trains.length - 1]","trains[1] and trains[trains.length]","trains[1] and trains[trains.length - 1]"]},{title:"How many of the following are legal declarations?",code:'<code>String lion [] = new String[] {"lion"};</code>\n<code>String tiger [] = new String[1] {"tiger"};</code>\n<code>String bear [] = new String[] {};</code>\n<code>String ohMy [] = new String[0] {};</code>',answers:["None","One","Two","Three"]},{title:"How many of the following are legal declarations?",code:"<code>float[] lion = new float[];</code>\n<code>float[] tiger = new float[1];</code>\n<code>float[] bear = new[] float;</code>\n<code>float[] ohMy = new[1] float;</code>",answers:["None","One","Two","Three"]},{title:"Which statement most accurately represents the relationship between searching and sorting with respect to the Arrays class?",code:null,answers:["If the array is not sorted, calling Arrays.binarySearch() will be accurate, but slower than if it were sorted.","The array does not need to be sorted before calling Arrays.binarySearch() to get an accurate result.","The array must be sorted before calling Arrays.binarySearch() to get an accurate result.","None of the above"]},{title:"Which is not a true statement about an array?",code:null,answers:["An array expands automatically when it is full.","An array is allowed to contain duplicate values.","An array understands the concept of ordered elements.","An array uses a zero index to reference the first element."]},{title:"Which line of code causes an ArrayIndexOutOfBoundsException?",code:'<code>String[][] matrix = new String[1][2];</code>\n<code>matrix[0][0] = "Don\'t think you are, know you are.";       // m1</code>\n<code>matrix[0][1] = "I\'m trying to free your mind Neo";         // m2</code>\n<code>matrix[1][0] = "Is all around you ";                       // m3</code>\n<code>matrix[1][1] = "Why oh why didn\'t I take the BLUE pill?";  // m4</code>',answers:["m1","m2","m3","m4"]},{title:"What does the following output?",code:'<code>String[] os = new String[] { "Mac", "Linux", "Windows" };</code>\n<code>Arrays.sort(os);</code>\n<code>System.out.println(Arrays.binarySearch(os, "Mac"));</code>',answers:["0","1","2","The output is not defined."]},{title:"Which is the first line to prevent this code from compiling and running without error?",code:"<code>char[][] ticTacToe = new char[3,3];                  // r1</code>\n<code>ticTacToe[1][3] = 'X';                               // r2</code>\n<code>ticTacToe[2][2] = 'X';</code>\n<code>ticTacToe[3][1] = 'X';</code>\n<code>System.out.println(ticTacToe.length + \" in a row!\"); // r3</code>",answers:["Line r1","Line r2","Line r3","None of the above"]},{title:"How many objects are created when running the following code?",code:"<code>Integer[] lotto = new Integer[4];</code>\n<code>lotto[0] = new Integer(1_000_000);</code>\n<code>lotto[1] = new Integer(999_999);</code>",answers:["Two","Three","Four","Five"]},{title:"How many of the following are legal declarations?",code:"<code>[][] String alpha;</code>\n<code>[] String beta;</code>\n<code>String[][] gamma;</code>\n<code>String[] delta[];</code>\n<code>String epsilon[][];</code>",answers:["Two","Three","Four","Five"]},{title:"Which of the options in the graphic best represent the blocks variable?",code:"<code>char[][] blocks = new char[][] { { 'a', 'b', 'c' }, { 'd' }, { 'e', 'f' } };</code>",answers:["Option A","Option B","Option C","Option D"]},{title:"What happens when calling the following method with a non-null and non-empty array?",code:'<code>public static void addStationName(String[] names) {</code>\n<code>   names[names.length] = "Times Square";</code>\n<code>}</code>',answers:["It adds an element to the array the value of which is Times Square.","It replaces the last element in the array with the value Times Square.","It does not compile.","It throws an exception."]},{title:"How many lines does the following code output?",code:'<code>String[] days = new String[] { "Sunday", "Monday", "Tuesday",</code>\n<code>      "Wednesday", "Thursday", "Friday", "Saturday" };</code>\n<code>for (int i = 0; i &lt; days.size(); i++)</code>\n<code>      System.out.println(days[i]);</code>',answers:["Six","Seven","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"How many dimensions does the array reference moreBools allow?",code:"<code>boolean[][][] bools, moreBools;</code>",answers:["One dimension","Two dimensions","Three dimensions","None of the above"]},{title:"What is a possible output of the following code?",code:"<code>String[] strings = new String[2];</code>\n<code>System.out.println(strings);</code>",answers:["[null, null]","[,]","[Ljava.lang.String;@74a14482","None of the above"]},{title:"Which is the first line to prevent this code from compiling and running without error?",code:"<code>char[][] ticTacToe = new char[3][3];                 // r1</code>\n<code>ticTacToe[1][3] = 'X';                               // r2</code>\n<code>ticTacToe[2][2] = 'X';</code>\n<code>ticTacToe[3][1] = 'X';</code>\n<code>System.out.println(ticTacToe.length + \" in a row!\"); // r3</code>",answers:["Line r1","Line r2","Line r3","None of the above"]},{title:"What is the result of running the following as java Copier?",code:'<code>package duplicate;</code>\n<code>public class Copier {</code>\n<code>  public static void main(String... original) {</code>\n<code>      String... copy = original;</code>\n<code>      System.out.println(copy.length + " " + copy[0]);</code>\n<code>   }</code>\n<code>}</code>',answers:["0","0 followed by an exception","1 followed by an exception","The code does not compile."]},{title:"What is the result of running the following program?",code:'<code>1:   package fun;</code>\n<code>2:   public class Sudoku {</code>\n<code>3:      static int[][] game = new int[6][6];</code>\n<code>4:</code>\n<code>5:      public static void main(String[] args) {</code>\n<code>6:         game[3][3] = 6;</code>\n<code>7:         Object[] obj = game;</code>\n<code>8:         obj[3] = "X";</code>\n<code>9:         System.out.println(game[3][3]);</code>\n<code>10:     }</code>\n<code>11:  }</code>',answers:["X","The code does not compile.","The code compiles but throws a NullPointerException at runtime.","The code compiles but throws a different exception at runtime."]},{title:"What does the following output?",code:'<code>String[] os = new String[] { "Mac", "Linux", "Windows" };</code>\n<code>Arrays.sort(os);</code>\n<code>System.out.println(Arrays.binarySearch(os, "RedHat"));</code>',answers:["-1","-2","-3","The output is not defined."]},{title:"What is the output of the following when run as java FirstName Wolfie?",code:"<code>public class FirstName {</code>\n<code>   public static void main(String... names) {</code>\n<code>      System.out.println(names[0]);</code>\n<code>   }</code>\n<code>}</code>",answers:["FirstName","Wolfie","The code throws an ArrayIndexOutOfBoundsException.","The code throws a NullPointerException."]},{title:"What is the output of the following when run as java Count 1 2?",code:"<code>public class Count {</code>\n<code>   public static void main(String target[]) {</code>\n<code>      System.out.println(target.length);</code>\n<code>   }</code>\n<code>}</code>",answers:["0","1","2","The code does not compile."]},{title:"What is the output of the following when run as java unix.EchoFirst seed flower?",code:'<code>package unix;</code>\n<code>import java.util.*;</code>\n<code>public class EchoFirst {</code>\n<code>&nbsp;</code>\n<code>   public static void main(String[] args) {</code>\n<code>      String one = args[0];</code>\n<code>      Arrays.sort(args);</code>\n<code>      int result = Arrays.binarySearch(args, one);</code>\n<code><span epub:type="pagebreak" id="Page_58"></span>      System.out.println(result);</code>\n<code>  }</code>\n<code>}</code>',answers:["0","1","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which of these four array declarations produces a different array than the others?",code:null,answers:["int[][] nums = new int[2][1];","int[] nums[] = new int[2][1];","int[] nums[] = new int[][] { { 0 }, { 0 } };","int[] nums[] = new int[][] { { 0, 0 } };"]},{title:'How do you access the array element with the value of "z"?',code:null,answers:['dimensions["three"][2]','dimensions["three"][3]',"dimensions[2][2]","dimensions[3][3]"]},{title:"How many lines does the following code output?",code:'<code>String[] days = new String[] { "Sunday", "Monday", "Tuesday",</code>\n<code>      "Wednesday", "Thursday", "Friday", "Saturday" };</code>\n<code>for (int i = 1; i &lt;= days.length; i++)</code>\n<code>      System.out.println(days[i]);</code>',answers:["Six","Seven","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What is the output of the following when run as java FirstName Wolfie?",code:"<code>public class FirstName {</code>\n<code>   public static void main(String... names) {</code>\n<code>      System.out.println(names[1]);</code>\n<code>   }</code>\n<code>}</code>",answers:["FirstName","Wolfie","The code throws an ArrayIndexOutOfBoundsException.","The code throws a NullPointerException."]},{title:"Which is the first line to prevent this code from compiling and running without error?",code:"<code>char[][] ticTacToe = new char[3][3];                 // r1</code>\n<code>ticTacToe[0][0] = 'X';                               // r2</code>\n<code>ticTacToe[1][1] = 'X';</code>\n<code>ticTacToe[2][2] = 'X';</code>\n<code>System.out.println(ticTacToe.length + \" in a row!\"); // r3</code>",answers:["Line r1","Line r2","Line r3","None of the above"]},{title:"What is the output of the following when run as java Count 1 2?",code:"<code>public class Count {</code>\n<code>   public static void main(String target[]) {</code>\n<code>      System.out.println(target.length());</code>\n<code>   }</code>\n<code>}</code>\n<code>&nbsp;</code>",answers:["0","1","2","The code does not compile."]},{title:"How many dimensions does the array reference moreBools allow?",code:"<code>boolean[][] bools[], moreBools;</code>",answers:["One dimension","Two dimensions","Three dimensions","None of the above"]},{title:"What is the result of the following when called as java counting.Binary?",code:"<code>package counting;</code>\n<code>import java.util.*;</code>\n<code>public class Binary {</code>\n<code>&nbsp;</code>\n<code>   public static void main(String... args) {</code>\n<code>      Arrays.sort(args);</code>\n<code>      System.out.println(Arrays.toString(args));</code>\n<code>   }</code>\n<code>}</code>",answers:["null","[]","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What does the following output?",code:'<code>String[] os = new String[] { "Mac", "Linux", "Windows" };</code>\n<code>System.out.println(Arrays.binarySearch(os, "Linux"));</code>',answers:["0","1","2","The output is not defined."]},{title:"What is the result of running the following program?",code:'<code>1:   package fun;</code>\n<code>2:   public class Sudoku {</code>\n<code>3:      static int[][] game;</code>\n<code>4:</code>\n<code>5:      public static void main(String[] args) {</code>\n<code>6:         game[3][3] = 6;</code>\n<code>7:         Object[] obj = game;</code>\n<code>8:         game[3][3] = "X";</code>\n<code>9:         System.out.println(game[3][3]);</code>\n<code>10:     }</code>\n<code>11:  }</code>',answers:["X","The code does not compile.","The code compiles but throws a NullPointerException at runtime.","The code compiles but throws a different exception at runtime."]},{title:"What is the output of the following?",code:'<code>String[][] listing = new String[][] { { "Book" }, { "Game", "29.99" } };</code>\n<code>System.out.println(listing.length + " " + listing[0].length);</code>',answers:["2 1","2 2","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What is the output of the following when run as java FirstName?",code:"<code>public class FirstName {</code>\n<code>   public static void main(String[] names) {</code>\n<code>      System.out.println(names[0]);</code>\n<code>   }</code>\n<code>}</code>",answers:["FirstName","The code does not compile.","The code throws an ArrayIndexOutOfBoundsException.","The code throws a NullPointerException."]},{title:"How many lines does the following code output?",code:'<code>String[] days = new String[] { "Sunday", "Monday", "Tuesday",</code>\n<code>      "Wednesday", "Thursday", "Friday", "Saturday" };</code>\n<code>for (int i = 1; i &lt; days.length; i++)</code>\n<code>      System.out.println(days[i]);</code>',answers:["Six","Seven","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:'What is the output of the following when run as java Count "1 2"?',code:"<code>public class Count {</code>\n<code>   public static void main(String target[]) {</code>\n<code>      System.out.println(target.length);</code>\n<code>   }</code>\n<code>}</code>",answers:["0","1","2","The code does not compile."]},{title:"What does the following output?",code:'<code>String[] os = new String[] { "Linux", "Mac", "Windows" };</code>\n<code>System.out.println(Arrays.binarySearch(os, "Linux"));</code>',answers:["0","1","2","The output is not defined."]},{title:"Which of the following statements are true? ",code:null,answers:["I","II","Both I and II","Neither I nor II"],ol:["You can always change a method signature from call(String[] arg) to call(String... arg) without causing a compiler error in the calling code.","You can always change a method signature from call(String... arg) to call(String[] arg) without causing a compiler error in the existing code."]},{title:"Which of these four array references can point to an array that is different from the others?",code:null,answers:["int[][][][] nums1a, nums1b;","int[][][] nums2a[], nums2b;","int[][] nums3a[][], nums3b[][];","int[] nums4a[][][], numbs4b[][][];"]},{title:"What is the output of the following when run as java unix.EchoFirst seed flower?",code:"<code>package unix;</code>\n<code>import java.util.*;</code>\n<code>public class EchoFirst {</code>\n<code>&nbsp;</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Arrays.sort(args);</code>\n<code>      String result = Arrays.binarySearch(args, args[0]);</code>\n<code>      System.out.println(result);</code>\n<code>  }</code>\n<code>}</code>\n<code>&nbsp;</code>",answers:["0","1","The code does not compile.","The code compiles but throws an exception at runtime."]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t],ol:e.ol}});i[20].imageUrl="./images/image-oca-ch4-21.png",i[33].imageUrl="./images/image-oca-ch4-34.png",t.default=i},161:function(e,t,o){"use strict";o.r(t);var n=["D. A while loop has a condition that returns a boolean that controls the loop. It appears at the beginning and is checked before entering the loop. Therefore, Option D is correct. A traditional for loop also has a boolean condition that is checked before entering the loop. However, it is best known for having a counter variable, making Option B incorrect. Option A is incorrect because the boolean condition on a do-while loop is at the end of the loop. Option C is incorrect because there is no condition as part of the loop construct.","B. A traditional for loop is best known for having a loop variable counting up or down as the loop progresses. Therefore, Option B is correct. Options A and D are incorrect because do-while and while loops are known for their boolean conditions. Option C is incorrect because the for-each loop iterates through without an index.","A. A do-while loop checks the loop condition after execution of the loop body. This ensures it always executes at least once, and Option A is correct. Option B is incorrect because there are loops you can write that do not ever enter the loop body, such as for (int i=0;i<1;i++). Similarly, Option D is incorrect because a while loop can be written where the initial loop condition is false. Option C is incorrect because a for-each loop does not enter the loop body when iterating over an empty list.","C. While a traditional for loop often loops through an array, it uses an index to do so, making Option B incorrect. The for-each loop goes through each element, storing it in a variable. Option C is correct.","B. The continue keyword is used to end the loop iteration immediately and resume execution at the next iteration. Therefore, Option B is correct. Option A is incorrect because the break statement causes execution to proceed after the loop body. Options C and D are incorrect because these are not keywords in Java.","A. The break keyword is used to end the loop iteration immediately, skip any remaining executions of the loop, and resume execution immediately after the loop. Therefore, Option A is correct. Option B is incorrect because execution proceeds at the next execution of the current loop for continue. Options C and D are incorrect because these are not keywords in Java.","B. A traditional for loop is best known for having an initialization statement, condition statement, and update statement. Option B is correct.","C. With a traditional for loop, you control the order in which indexes are visited in code. This means you can loop through an array in ascending or descending order, and Option C is correct.","A. With a for-each loop, the loop order is determined for you. With an array, this means starting with index 0, and Option A is correct. A traditional for loop allows you to control the order and iterate in either order.","A. A do-while loop has a condition that returns a boolean at the end of the loop. Therefore, Option A is correct. Option D is incorrect because a while loop has this condition at the beginning of the loop. A traditional for loop is best known for having a loop variable, making Option B incorrect. Option C is incorrect because there is no condition as part of the loop construct.","B. A while loop requires a boolean condition. While singer is a variable, it is not a boolean. Therefore, the code does not compile, and Option B is correct.","B. This is a correct loop to go through an ArrayList or List starting from the end. It starts with the last index in the list and goes to the first index in the list. Option B is correct.","A. The first time through the loop, the index is 0 and glass, is output. The break statement then skips all remaining executions on the loop and the main() method ends. If there was no break keyword, this would be an infinite loop because there\u2019s no incrementor.",'A. Immediately after letters is initialized, the loop condition is checked. The variable letters is of length 0, which is not equal to 2 so the loop is entered. In the loop body, letters becomes length 1 with contents "a". The loop index is checked again and now 1 is not equal to 2. The loop is entered and letters becomes length 2 and contains "aa". Then the loop index is checked again. Since the length is now 2, the loop is completed and aa is output. Option A is correct.',"D. There are three arguments passed to the program. This means that i is 3 on the first iteration of the loop. The program prints args. Then i is incremented to 4. Which is also greater than or equal to 0. Since i never gets smaller, this code produces an infinite loop and the answer is Option D.",'B. Since count is a class variable that isn\u2019t specifically initialized, it defaults to 0. On the first iteration of the loop, "Washington", is 11 characters and count is set to 1. The if statement\u2019s body is not run. The loop then proceeds to the next iteration. This time, the post-increment operator uses index 1 before setting count to 2. "Monroe" is checked, which is only 6 characters. The break statement sends the execution to after the loop and 2 is output. Option B is correct.',"C. At first this code appears to be an infinite loop. However, the count variable is declared inside the loop. It is not in scope after the loop where it is referenced by the println(). Therefore, the code does not compile, and Option C is correct.","D. A for loop is allowed to have all three segments left blank. In fact, for(;;) {} is an infinite loop.","C. It is not possible to create an infinite loop using a for-each because it simply loops through an array or ArrayList. The other types allow infinite loops, such as, for example, do { } while(true), for(;;) and while(true). Therefore, Option C is correct. And yes, we know it is possible to create an infinite loop with for-each by creating your own custom Iterable. This isn\u2019t on the OCA or OCP exam though. If you think the answer is Option D, this is a great reminder of what not to read into on the real exam!","A. This is a correct loop to go through an ArrayList or List starting from the beginning. It starts with index 0 and goes to the last index in the list. Option A is correct.","D. Braces are optional around loops if there is only one statement. Parentheses are not allowed to surround a loop body though, so the code does not compile, and Option D is correct.","B. The for-each loop uses a variable and colon as the syntax, making Option B correct.","C. In this figure, we want to end the inner loop and resume execution at the letters label. This means we only want to break out of the inner loop. A break statement does just that. It ends the current loop and resumes execution immediately after the loop, making break; a correct answer. The break numbers; statement explicitly says which loop to end, which does the same thing, making it correct as well. By contrast, break letters; ends the outer loop, causing the code only to run the println() once. Therefore, two statements correctly match the diagram, and Option C is correct.","B. In this figure, we want to end the inner loop and resume execution at the letters label. The continue letters; statement does that. The other two statements resume execution at the inner loop. Therefore, only the second statement correctly matches the diagram, and Option B is correct.","C. A while loop checks the boolean condition before entering the loop. In this code, that condition is false, so the loop body is never run. No output is produced, and Option C is correct.","C. A for-each loop is allowed to be used with arrays and ArrayList objects. StringBuilder is not an allowed type for this loop, so Option C is the answer.","B. This is a correct do-while loop. On the first iteration of the loop, the if statement executes and prints inflate-. Then the loop condition is checked. The variable balloonInflated is true, so the loop condition is false and the loop completes.",'D. Immediately after letters is initialized, the loop condition is checked. The variable letters is of length 0, which is not equal to 3, so the loop is entered. In the loop body, letters becomes length 2 and contains "ab". The loop index is checked again and now 2 is not equal to 3. The loop is entered and letters becomes length 4 with contents "abab". Then the loop index is checked again. Since the length 4 is not equal to 3, the loop body is entered again. This repeats for 6, 8, 10, etc. The loop never ends, and Option D is correct.',"B. In a for loop, the segments are an initialization expression, a boolean conditional, and an update statement in that order. Therefore, Option B is correct.","B. On the first iteration through the outer loop, chars becomes 1 element. The inner loop is run once and count becomes 9. On the second iteration through the outer loop, chars becomes 2 elements. The inner loop runs twice so count becomes 7. On the third iteration through the outer loop, chars becomes 3 elements. The inner loop runs three times so count becomes 4. On the fourth iteration through the outer loop, chars becomes 4 elements. The inner loop runs four times so count becomes 0. Then both loops end. Therefore, Option B is correct.","A. On the first iteration of the outer loop, i starts out at 10. The inner loop sees that 10 > 3 and subtracts 3, making the 7 the new value of i. Since 7 > 3, we subtract 3 again, making i set to 4. Yet again 4 > 3, so i becomes 1. Then k is finally incremented to 1. The outer loop decrements i i, making it 0. The boolean condition sees that 0 is not greater than 0. The outer loop ends and 1 is printed out. Therefore, Option A is correct.","D. Options A and C do not compile as they do not use the correct syntax for a for-each loop. The for-each loop is only able to go through an array in ascending order. It is not able to control the order, making Option C incorrect. Therefore, Option D is the answer.","C. Since there are no brackets around the for statement, the loop body is only one line. The break statement is not in the loop. Since break cannot be used at the top level of a method, the code does not compile, and Option C is correct.","C. Multiple update expressions are separated with a comma rather than a semicolon. Tricky, we know. But it is an important distinction. This makes Option C correct.","D. There are three arguments passed to the program. This means that i is 3 on the first iteration of the loop. The program attempts to print args[3]. Since indexes are zero based in Java, it throws an ArrayIndexOutOfBoundsException.","B. The first time the loop condition is checked, the variable tie is null. The loop body executes, setting tie. Despite the indention, there are no brackets surrounding the loop body so the print does not run yet. Then the loop condition is checked and tie is not null. The print runs after the loop, printing out shoelace once, making Option B correct.","C. The code compiles as is. However, we aren\u2019t asked about whether the code compiles as is. Line 27 refers to a loop label. While the label is still present, it no longer points to a loop. This causes the code to not compile, and Option C is correct.","C. The continue statement is useless here since there is no code later in the loop to skip. The continue statement merely resumes execution at the next iteration of the loop, which is what would happen if the if-then statement was empty. Therefore, count increments for each element of the array. The code outputs 4, and Option C is correct.","C. A do-while loop requires a boolean condition. The builder variable is a StringBuilder and not a boolean. The code does not compile, and Option C is correct.","A. At first this code appears to be an infinite loop. However, there is a break statement. On line 6, count is set to 0. On line 9, it is changed to 1. Then the condition on line 10 runs. count is less than 2 so the inner loop continues. Then count is set to 2 on the next iteration of the inner loop. The loop condition on line 10 runs again and this time is false. The inner loop is completed. Then line 11 of the outer loop runs and sends execution to after the loop on line 13. At this point count is still 2, so Option A is correct.","C. Option A breaks out of the inner loop, but the outer loop is still infinite. Option B has the same problem. Option C is correct because it breaks out of both loops.","B. This code is correct. It initializes two variables and uses both variables in the condition check and the update statements. Since it checks the size of both arrays correctly, it prints the first two sets of elements, and Option B is correct.","B. Looping through the same list multiple times is allowed. The outer loop executes twice. The inner loop executes twice for each of those iterations of the outer loop. Therefore, the inner loop executes four times, and Option B is correct.","B. The initializer, which is alpha, runs first. Then Java checks the condition, which is beta, to see if loop execution should start. Since beta returns false, the loop is never entered, and Option B is correct.","B. The initializer, which is alpha, runs first. Then Java checks the condition, which is beta, to see if loop execution should start. Then the loop body, which is delta, runs. After the loop execution, the updater, which is gamma, runs. Then the loop condition, which is beta, is checked again. Therefore, Option B is correct.","C. Option A goes through five indexes on the iterations: 0, 1, 2, 3 and 4. Option B also goes through five indexes: 1, 2, 3, 4 and 5. Option D goes through five iterations as well, from 0 to 4. However, Option C goes through six iterations since the loop condition is at the end of the loop. Therefore it is not like the others, and Option C is the answer.","D. The first time the loop condition is checked, the variable tie is null. However, the loop body is empty due to the semicolon right after the condition. This means the loop condition keeps running with no opportunity for tie to be set. Therefore, this is an infinite loop, and Option D is correct.","C. Remember to look for basic errors before wasting time tracking the flow. In this case, the label of the loop is trying to use the keyword for. This is not allowed, so the code does not compile. If the label was valid, Option A would be correct.","D. On the first iteration of the loop, the if statement executes printing inflate-. Then the loop condition is checked. The variable baloonInflated is true, so the loop condition is true and the loop continues. The if statement no longer runs, but the variable never changes state again, so the loop doesn\u2019t end.","B. In a for loop, the type is only allowed to be specified once. A comma separates multiple variables since they are part of the same statement. Therefore, Option B is correct."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"Which type of loop is best known for its boolean condition that controls entry to the loop?",code:null,answers:["do-while loop","for (traditional)","for-each","while"]},{title:"Which type of loop is best known for using an index or counter?",code:null,answers:["do-while loop","for (traditional)","for-each","while"]},{title:"Which type of loop is guaranteed to have the body execute at least once?",code:null,answers:["do-while loop","for (traditional)","for-each","while"]},{title:"Which of the following can loop through an array without referring to the elements by index?",code:null,answers:["do-while loop","for (traditional)","for-each","while"]},{title:"What keyword is used to end the current loop iteration and proceed execution with the next iteration of that loop?",code:null,answers:["break","continue","end","skip"]},{title:"What keyword is used to proceed with execution immediately after a loop?",code:null,answers:["break","continue","end","skip"]},{title:"Which type of loop has three segments within parentheses?",code:null,answers:["do-while loop","for (traditional)","for-each","while"]},{title:"Which of the following statements is/are true?",code:null,answers:["Only I","Only II","Both statements","Neither statement"],ol:["A traditional for loop can iterate through an array starting from index 0.","A traditional for loop can iterate through an array starting from the end."]},{title:"Which of the following statements is/are true? ",code:null,answers:["Only I","Only II","Both statements","Neither statement"],ol:["A for-each loop can iterate through an array starting from index 0.","A for-each loop can iterate through an array starting from the end."]},{title:"Which type of loop has a boolean condition that is first checked after a single iteration through the loop?",code:null,answers:["do-while loop","for (traditional)","for-each","while"]},{title:"What does the following code output?",code:"<code>int singer = 0;</code>\n<code>while (singer)</code>\n<code>  System.out.println(singer++);</code>",answers:["0","The code does not compile.","The loops complete with no output.","This is an infinite loop."]},{title:"What does the following code output?",code:'<code>List&lt;String&gt; drinks = Arrays.asList("can", "cup");</code>\n<code>for (int container = drinks.size() - 1; container &gt;= 0; container\u2010\u2010)</code>\n<code>  System.out.print(drinks.get(container) + ",");</code>',answers:["can,cup,","cup,can,","The code does not compile.","None of the above"]},{title:"What does the following code output?",code:'<code>public static void main(String[] args) {</code>\n<code>   List&lt;String&gt; bottles = Arrays.asList("glass", "plastic");</code>\n<code>   for (int type = 0; type &lt; bottles.size();) {</code>\n<code>     System.out.print(bottles.get(type) + ",");</code>\n<code>     break;</code>\n<code>   }</code>\n<code>   System.out.print("end");</code>\n<code>}</code>',answers:["glass,end","glass,plastic,end","The code does not compile.","None of the above"]},{title:"What does the following code output?",code:'<code>String letters = "";</code>\n<code>while (letters.length() != 2)</code>\n<code>   letters+="a";</code>\n<code>System.out.println(letters);</code>',answers:["aa","aaa","The loops complete with no output.","This is an infinite loop."]},{title:"What is the result of the following when run with  java peregrine.TimeLoop September 3 1940?",code:'<code>package peregrine;</code>\n<code>public class TimeLoop {</code>\n<code>  public static void main(String[] args) {</code>\n<code>    for (int i = args.length; i&gt;=0; i++)</code>\n<code>       System.out.println("args");</code>\n<code>  }</code>\n<code>}</code>',answers:["args","argsargs","The code does not compile.","None of the above"]},{title:"What is the output of the following code?",code:'<code>package chicago;</code>\n<code>public class Loop {</code>\n<code>   private static int count;</code>\n<code>   private static String[] stops = new String[] { "Washington",</code>\n<code>       "Monroe", "Jackson", "LaSalle" };</code>\n<code>   public static void main(String[] args) {</code>\n<code>      while (count &lt; stops.length) {</code>\n<code>         if (stops[count++].length() &lt; 8) {</code>\n<code>            break;</code>\n<code>          }</code>\n<code>      }</code>\n<code>      System.out.println(count);</code>\n<code>   }</code>\n<code>}</code>',answers:["1","2","4","The code does not compile."]},{title:"What is the result of the following code?",code:"<code>do {</code>\n<code>   int count = 0;</code>\n<code>   do {</code>\n<code>      count++;</code>\n<code>   } while (count &lt; 2);</code>\n<code>      break;</code>\n<code>} while (true);</code>\n<code>System.out.println(count);</code>",answers:["2","3","The code does not compile.","This is an infinite loop."]},{title:"Which of the following segments of a for loop can be left blank?",code:"<code>for (segmentA; segmentB; segmentC) {</code>\n<code>}</code>",answers:["segmentA","segmentB","segmentC","All of the above"]},{title:"How many of the loop types (while, do while, traditional for, and enhanced for) allow you to write code that creates an infinite loop?",code:null,answers:["One","Two","Three","Four"]},{title:"What is the output of the following?",code:'<code>List&lt;String&gt; drinks = Arrays.asList("can", "cup");</code>\n<code>for (int container = 0; container &lt; drinks.size(); container++)</code>\n<code>   System.out.print(drinks.get(container) + ",");</code>',answers:["can,cup,","cup,can,","The code does not compile.","None of the above"]},{title:"What happens when running the following code?",code:'<code>do (</code>\n<code>   System.out.println("helium");</code>\n<code>) while (false);</code>',answers:["It completes successfully without output.","It outputs helium once.","It keeps outputting helium.","The code does not compile."]},{title:"Which of the following is equivalent to this code snippet given an array of String objects?",code:"<code>for (int i=0; i&lt;fun.length; i++)</code>\n<code>  System.out.println(fun[i]);</code>",answers:["for (String f = fun) System.out.println(f);","for (String f : fun) System.out.println(f);","for (String = fun) System.out.println(it);","None of the above"]},{title:"How many of these statements can be inserted after the println to have the code flow  follow the arrow in this diagram?",code:"<code>break;</code>\n<code>break letters;</code>\n<code>break numbers;</code>",answers:["None","One","Two","Three"]},{title:"Using the diagram in the previous question, how many of these statements can be inserted after the println to have the code flow follow the arrow in the diagram?",code:"<code>continue;</code>\n<code>continue letters;</code>\n<code>continue numbers;</code>",answers:["None","One","Two","Three"]},{title:"What does the following code output?",code:"<code>int singer = 0;</code>\n<code>while (singer &gt; 0)</code>\n<code>  System.out.println(singer++);</code>",answers:["0","The code does not compile.","The loops completes with no output.","This is an infinite loop."]},{title:"Which of the following types is taxis not allowed to be in order for this code to compile?",code:"<code>for (Object obj : taxis) {</code>\n<code>}</code>",answers:["ArrayList<Integer>","int[]","StringBuilder","All of these are allowed."]},{title:"What is the output of the following?",code:'<code>boolean balloonInflated = false;</code>\n<code>do {</code>\n<code>   if (!balloonInflated) {</code>\n<code>      balloonInflated = true;</code>\n<code>      System.out.print("inflate-");</code>\n<code>   }</code>\n<code>} while (! balloonInflated);</code>\n<code>System.out.println("done");</code>',answers:["done","inflate-done","The code does not compile.","This is an infinite loop."]},{title:"What does the following code output?",code:'<code>String letters = "";</code>\n<code>while (letters.length() != 3)</code>\n<code>   letters+="ab";</code>\n<code>System.out.println(letters);</code>',answers:["ab","abab","The loop completes with no output.","This is an infinite loop."]},{title:"What describes the order in which the three expressions appear in a for loop?",code:null,answers:["boolean conditional, initialization expression, update statement","initialization expression, boolean conditional, update statement","initialization expression, update statement, boolean conditional","None of the above"]},{title:"What is the result of the following?",code:'<code>int count = 10;</code>\n<code>List&lt;Character&gt; chars = new ArrayList&lt;&gt;();</code>\n<code>do {</code>\n<code>  chars.add(\'a\');</code>\n<code><span epub:type="pagebreak" id="Page_71"></span>  for (Character x : chars) count -=1;</code>\n<code>} while (count &gt; 0);</code>\n<code>System.out.println(chars.size());</code>',answers:["3","4","The code does not compile.","None of the above"]},{title:"What is the result of the following?",code:"<code>int k = 0;</code>\n<code>for (int i = 10; i &gt; 0; i\u2010\u2010) {</code>\n<code>  while (i &gt; 3) i \u2010= 3;</code>\n<code>  k += 1;</code>\n<code>}</code>\n<code>System.out.println(k);</code>",answers:["1","2","3","4"]},{title:"Which of the following is equivalent to this code snippet given an array of String objects?",code:"<code>for (int i=fun.length-1; i&gt;=0; i\u2010\u2010)</code>\n<code>  System.out.println(fun[i]);</code>",answers:["for (String f = fun) System.out.println(f);","for (String f : fun) System.out.println(f);","for (String f fun) System.out.println(it);","None of the above"]},{title:"What does the following code output?",code:'<code>public static void main(String[] args) {</code>\n<code>   List&lt;String&gt; bottles = Arrays.asList("glass", "plastic");</code>\n<code>   for (int type = 0; type &lt; bottles.size();)</code>\n<code>     System.out.print(bottles.get(type) + ",");</code>\n<code>     break;</code>\n<code>   System.out.print("end");</code>\n<code>}</code>',answers:["glass,end","glass,plastic,end","The code does not compile.","None of the above"]},{title:"What is the result of the following?",code:'<code>String[] nycTourLoops = new String[] { "Downtown", "Uptown", "Brooklyn" };</code>\n<code>String[] times = new String[] { "Day", "Night" };</code>\n<code>for (int i = 0, j = 0; i &lt; nycTourLoops.length</code>\n<code>   &amp;&amp; j &lt; times.length; i++; j++)</code>\n<code>{</code>\n<code>   System.out.print(nycTourLoops[i] + " " + times[j] + "-");</code>\n<code>}</code>',answers:["Downtown Day-","Downtown Day-Uptown Night-","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What is the result of the following when run with  java peregrine.TimeLoop September 3 1940?",code:"<code>package peregrine;</code>\n<code>public class TimeLoop {</code>\n<code>  public static void main(String[] args) {</code>\n<code>    for (int i = args.length; i&gt;=0; i\u2010\u2010)</code>\n<code>       System.out.println(args[i]);</code>\n<code>  }</code>\n<code>}</code>",answers:["September","1940","The code does not compile.","None of the above"]},{title:"What is the output of the following?",code:'<code>public class Shoelaces {</code>\n<code>  public static void main(String[] args) {</code>\n<code>    String tie = null;</code>\n<code>    while (tie == null)</code>\n<code>       tie = "shoelace";</code>\n<code>       System.out.print(tie);</code>\n<code>  }</code>\n<code>}</code>',answers:["null","shoelace","shoelaceshoelace","None of the above"]},{title:"The following code outputs a single letter x. What happens if you remove lines 25 and 28?",code:'<code>23:  String race = "";</code>\n<code>24:  loop:</code>\n<code>25:  do {</code>\n<code>26:     race += "x";</code>\n<code>27:     break loop;</code>\n<code>28:  } while (true);</code>\n<code>29:  System.out.println(race);</code>',answers:["It prints an empty string.","It still outputs a single letter x.","It no longer compiles.","It becomes an infinite loop."]},{title:"What is the output of the following code?",code:'<code>package chicago;</code>\n<code>public class Loop {</code>\n<code>   private static int count;</code>\n<code>   private static String[] stops = new String[] { "Washington",</code>\n<code>       "Monroe", "Jackson", "LaSalle" };</code>\n<code>   public static void main(String[] args) {</code>\n<code>      while (count &lt; stops.length) {</code>\n<code>         if (stops[count++].length() &lt; 8) {</code>\n<code>            continue;</code>\n<code>          }</code>\n<code>      }</code>\n<code>      System.out.println(count);</code>\n<code>   }</code>\n<code>}</code>',answers:["1","2","4","The code does not compile."]},{title:"What is the output of the following?",code:'<code>StringBuilder builder = new StringBuilder();</code>\n<code>String str = new String("Leaves growing");</code>\n<code>do {</code>\n<code>   System.out.println(str);</code>\n<code>} while (builder);</code>\n<code>System.out.println(builder);</code>',answers:["Leaves growing","This is an infinite loop.","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What is the result of the following code?",code:"<code>6:   int count = 0;</code>\n<code>7:   do {</code>\n<code>8:      do {</code>\n<code>9:         count++;</code>\n<code>10:     } while (count &lt; 2);</code>\n<code>11:     break;</code>\n<code>12:  } while (true);</code>\n<code>13:  System.out.println(count);</code>",answers:["2","3","The code does not compile.","This is an infinite loop."]},{title:"Fill in the blank so this code compiles and does not cause an infinite loop.",code:"<code>t: while (true) {</code>\n<code>   f: while(true) {</code>\n<code>      _____________</code>\n<code>   }</code>\n<code>}</code>",answers:["break;","break f;","break t;","None of the above"]},{title:"What is the result of the following?",code:'<code>String[] nycTourLoops = new String[] { "Downtown", "Uptown", "Brooklyn" };</code>\n<code>String[] times = new String[] { "Day", "Night" };</code>\n<code>for (int i = 0, j = 0; i &lt; nycTourLoops.length</code>\n<code>   &amp;&amp; j &lt; times.length; i++, j++)</code>\n<code>{</code>\n<code>   System.out.print(nycTourLoops[i] + " " + times[j] + "-");</code>\n<code>}</code>',answers:["Downtown Day-","Downtown Day-Uptown Night-","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"How many lines does the following code output?",code:'<code>import java.util.*;</code>\n<code>public class Exams {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      List&lt;String&gt; exams = Arrays.asList("OCA", "OCP");</code>\n<code>      for (String e1 : exams)</code>\n<code>         for (String e2 : exams)</code>\n<code>            System.out.println(e1 + " " + e2);</code>\n<code>   }</code>\n<code>}</code>',answers:["One","Four","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which of the following best describes the flow of execution in this for loop if beta always returns false?",code:"<code>for (alpha; beta; gamma) {</code>\n<code>  delta;</code>\n<code>}</code>",answers:["alpha","alpha, beta","alpha, beta, gamma","None of the above"]},{title:"Which of the following best describes the flow of execution in this for loop if the loop body is run exactly once?",code:"<code>for (alpha; beta; gamma) {</code>\n<code>  delta;</code>\n<code>}</code>",answers:["alpha, delta, gamma, beta","alpha, beta, delta, gamma, beta","alpha, delta, gamma, alpha, beta","alpha, beta, delta, gamma, alpha, beta"]},{title:"Which of the following iterates a different number of times than the others?",code:null,answers:["for (int k=0; k < 5; k++) {}","for (int k=1; k <= 5; k++) {}","int k=0; do { } while(k++ < 5)","int k=0; while (k++ < 5) {}"]},{title:"What is the output of the following?",code:'<code>public class Shoelaces {</code>\n<code>  public static void main(String[] args) {</code>\n<code>    String tie = null;</code>\n<code>    while (tie == null);</code>\n<code>       tie = "shoelace";</code>\n<code>       System.out.print(tie);</code>\n<code>  }</code>\n<code>}</code>',answers:["null","shoelace","shoelaceshoelace","None of the above"]},{title:"What is the output of the following?",code:"<code>12:  int result = 8;</code>\n<code>13:  for: while (result &gt; 7) {</code>\n<code>14:     result++;</code>\n<code>15:     do {</code>\n<code>16:        result--;</code>\n<code>17:     } while (result &gt; 5);</code>\n<code>18:     break for;</code>\n<code>19:  }</code>\n<code>20:  System.out.println(result);</code>",answers:["5","8","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What is the output of the following?",code:'<code>boolean baloonInflated = false;</code>\n<code>do {</code>\n<code>   if (!baloonInflated) {</code>\n<code>      baloonInflated = true;</code>\n<code>      System.out.print("inflate-");</code>\n<code>   }</code>\n<code>} while (baloonInflated);</code>\n<code>System.out.println("done");</code>',answers:["done","inflate-done","The code does not compile.","This is an infinite loop."]},{title:"Which of the following can fill in the blank to have the code compile successfully?",code:'<code>package nyc;</code>\n<code>public class TouristBus {</code>\n<code>  public static void main(String... args) {</code>\n<code>     String[] nycTourLoops = new String[] { "Downtown", "Uptown", "Brooklyn" };</code>\n<code>     String[] times = new String[] { "Day", "Night" };</code>\n<code>        for (_____________ i &lt; 1; i++, j++)</code>\n<code>           System.out.println(nycTourLoops[i] + " " + times[j]);</code>\n<code>  }</code>\n<code>}</code>\n<code>&nbsp;</code>',answers:["int i=0; j=0;","int i=0, j=0;","int i=0; int j=0;","int i=0, int j=0;"]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t],ol:e.ol}});i[22].imageUrl="./images/image-oca-ch5-23.png",t.default=i},162:function(e,t,o){"use strict";o.r(t);var n=["C. The protected modifier allows access by subclasses and members within the same package, while the package-private modifier allows access only to members in the same package. Therefore, the protected access modifier allows access to everything the package-private access modifier, plus subclasses, making Option C the correct answer. Options A, B, and D are incorrect because the first term is a more restrictive access modifier than the second term.","B. The super() statement is used to call a constructor in a parent class, while the this() statement is used to call a constructor in the same class, making Option B correct and Option A incorrect. Options C and D are incorrect because they are not constructors.","D. The sell() method does not compile because it does not return a value if both of the if-then statements\u2019 conditional expressions evaluate to false. While logically, it is true that price is either less than 10 or greater than or equal to 10, the compiler does not know that. It just knows that if both if-then statements evaluate to false, then it does not have a return value, therefore it does not compile.","D. The three overloaded versions of nested() compile without issue, since each method takes a different set of input arguments, making Options B and C incorrect. The code does not compile, though, due to the first line of the main() method, making Option A incorrect. The no-argument version of the nested() method does not return a value, and trying to output a void return type in the print() method throws an exception at runtime.","B. Java uses pass-by-value to copy primitives and references of objects into a method. That means changes to the primitive value or reference in the method are not carried to the calling method. That said, the data within an object can change, just not the original reference itself. Therefore, Option B is the correct answer, and Options C and D are incorrect. Option A is not a real term.","C. Option A is incorrect because the getter should return a value. Option B is incorrect because the setter should take a value. Option D is incorrect because the setter should start with set and should not return a value. Option C is a correct setter declaration because it takes a value, uses the void return type, and uses the correct naming convention.","B. Options A, C, and D are true statements about calling this() inside a constructor. Option B is incorrect because a constructor can only call this() or super() on the first line of the constructor, but never both in the same constructor. If both constructors were allowed to be called, there would be two separate calls to super(), leading to duplicate initialization of parent constructors, since the other constructor referenced by this() would also call super() (or be chained to one that eventually calls super()).","B. Option A is incorrect because the public access modifier starts with a lowercase letter. Options C and D are incorrect because the return types, void and String, are incompatible with the method body that returns an integer value of 10. Option B is correct and has package-private access. It also uses a return type of Long that the integer value of 10 can be easily assigned to without an explicit cast.","C. The only variables always available to all instances of the class are those declared static; therefore, Option C is the correct answer. Option A may seem correct, but public variables are only available if a reference to the object is maintained among all instances. Option B is incorrect because there is no local keyword in Java. Option D is also incorrect because a private instance variable is only accessible within the instance that created it.","A. First off, all of the lines compile but they produce various different results. Remember that the default initialization of a boolean instance variable is false, making outside false at line p1. Therefore, this(4) will cause rope to be set to 5, while this(5) will cause rope to be set to 6. Since 5 is the number we are looking for, Option A is correct, and Option C is incorrect. Option B is incorrect. While the statement does create a new instance of Jump, with rope having a value of 5, that instance is nested and the value of rope does not affect the surrounding instance of Jump that the constructor was called in. Option D is also incorrect. The value assigned to rope is 4, not the target 5.","B. Options A, C, and D are true statements. In particular, Option C allows us to write the equals() methods between two objects that compare private attributes of the class. Option D is true because protected access also provides package-private access. Option B is false. Package-private attributes are only visible if the two classes are in the same package, regardless of whether one extends the other.","D. The class data, stuff, is declared public, allowing any class to modify the stuff variable and making the implementation inherently unsafe for encapsulation. Therefore, there are no values that can be placed in the two blanks to ensure the class properly encapsulates its data, making Option D correct. Note that if stuff was declared private, Options A, B, and C would all be correct. Encapsulation does not require JavaBean syntax, just that the internal attributes are protected from outside access, which all of these sets of values do achieve.","C. Option A is incorrect because Java only inserts a no-argument constructor if there are no other constructors in the class. Option B is incorrect because the parent can have a default no-argument constructor, which is inserted by the compiler and accessible in the child class. Finally, Option D is incorrect. A class that contains two no-argument constructors will not compile because they would have the same signature. Finally, Option C is correct. If a class extends a parent class that does not include a no-argument constructor, the default no-argument constructor cannot be automatically inserted into the child class by the compiler. Instead, the developer must explicitly declare at least one constructor and explicitly define how the call to the parent constructor is made.","A. A method may contain at most one varargs parameter, and it must appear as the last argument in the list. For this reason, Option A is correct, and Options B, C, and D are incorrect.","C. To solve this problem, it helps to remember that Java is a pass-by-value language in which copies of primitives and object references are sent to methods. This also means that an object\u2019s data can be modified within a method and shared with the caller, but not the reference to the object. Any changes to the object\u2019s reference within the method are not carried over to the caller. In the slalom() method, the Ski object is updated with an age value of 18. Although, the last line of the slalom() method changes the variable value to null, it does not affect the mySkier object or reference in the main() method. Therefore, the mySkier object is not null and the age variable is set to 18, making Options A and D incorrect. Next, the name variable is reassigned to the Wendy object, but this does not change the reference in the main() method, so myName remains Rosie. Finally, the speed array is assigned a new object and updated. Since the array is updated after the reference is reassigned, it does not affect the mySpeed array in the main() method. The result is that mySpeed continues to have a single element with the default int value of 0. For these reasons, Option B is incorrect, and Option C is correct.","B. Options A and D would not allow the class to compile because two methods in the class cannot have the same name and arguments, but a different return value. Option C would allow the class to compile, but it is not a valid overloaded form of our findAverage() method since it uses a different method name. Option B is a valid overloaded version of the findAverage() method, since the name is the same but the argument list differs.","D. Implementing encapsulation prevents internal attributes of a class from being modified directly, so Option C is a true statement. By preventing access to internal attributes, we can also maintain class data integrity between elements, making Option B a true statement. Option A is also a true statement about encapsulation, since well-encapsulated classes are often easier to use. Option D is an incorrect statement. Encapsulation makes no guarantees about performance and concurrency.","A. Option B is incorrect because String values are immutable and cannot be modified. Options C and D are also incorrect since variables are passed by value, not reference, in Java. Option A is the correct answer. The contents of an array can be modified when passed to a method, since a copy of the reference to the object is passed. For example, the method can change the first element of a non-empty array.","B. Option A is not a valid syntax in Java. Option C would be correct if there was a static import, but the question specifically says there are not any. Option D is almost correct, since it is a way to call the method, but the question asks for the best way to call the method. In that regard, Option B is the best way to call the method, since we are given that two classes are in the same package, therefore the package name would not be required.","D. Options A and B are incorrect because a method with a non-void return type requires that the method return a value using the return statement. Option C is also incorrect since a method with a void return type can still call the return command with no values and exit the method. Therefore, Option D is the correct answer.","C. The finish() method modifies two variables that are marked final, score and result. The score variable is modified by the post-increment ++ operator, while the result variable is modified by the compound addition += operator. Removing both final modifiers allows the code to compile. For this reason, Option C is the correct answer.","D. The super() statement is used to call a constructor in the parent class, while super is used to reference a member of the parent class. The this() statement is used to call a constructor in the current class, while this is used to reference a member of the current class. For these reasons, Option D is the correct answer.","B. The method signature has package-private, or default, access; therefore, it is accessible to classes in the same package, making Option B the correct answer.","A. The access modifier of strength is protected, meaning subclasses and classes within the same package can modify it. Changing the value to private would improve encapsulation by making the Protect class the only one capable of directly modifying it. For these reasons, the first statement is correct. Alternatively, the second and third statements do not improve the encapsulation of the class. While having getters and setters for private variables is helpful, they are not required. Encapsulation is about protecting the data elements. With this in mind, it is clear the material variable is already protected. Therefore, Option A is the correct answer.","A. Option A is correct since method names may include the underscore _ character as well as the dollar $ symbol. Note that there is no rule that requires a method start with a lowercase character; it is just a practice adopted by the community. Option B is incorrect because the hyphen - character may not be part of a method name. Option C is incorrect since new is a reserved word in Java. Finally, Option D is incorrect. A method name must start with a letter, the dollar $ symbol, or an underscore _ character.","D. The code does not compile, regardless of what is inserted into the line because the method signature is invalid. The return type, int, should go before the method name and after any access, final, or static modifiers. Therefore, Option D is the correct answer. If the method was fixed, by swapping the order of int and static in the method declaration, then Option C would be the correct answer. Options A and B are still incorrect, though, since each uses a return type that cannot be implicitly converted to int.","B. Java uses pass-by-value, so changes made to primitive values and object references passed to a method are not reflected in the calling method. For this reason, Options A and C are incorrect statements. Option D is also an invalid statement because it is a special case of Option A. Finally, Option B is the correct answer. Changes to the data within an object are visible to the calling method since the object that the copied reference points to is the same.","C. The code contains a compilation problem in regard to the contents instance variable. The contents instance variable is marked final, but there is a setContents() instance method that can change the value of the variable. Since these two are incompatible, the code does not compile, and Option C is correct. If the final modifier was removed from the contents variable declaration, then the expected output would be of the form shown in Option A.","A. JavaBean methods use the prefixes get, set, and is for boolean values, making Option A the correct choice.","C. Option A is incorrect because the keywords static and import are reversed. The Closet class uses the method getClothes() without a reference to the class name Store, therefore a static import is required. For this reason, Option B is incorrect since it is missing the static keyword. Option D is also incorrect since static imports are used with members of the class, not a class name. Finally, Option C is the correct answer since it properly imports the method into the class using a static import.","D. In Java, the lack of an access modifier indicates that the member is package-private, therefore Option D is correct. Note that the default keyword is used for interfaces and switch statements, and is not an access modifier.","B. The code does not compile, so Option A is incorrect. The class contains two constructors and one method. The first method, Stars(), looks a lot like a no-argument constructor, but since it has a return value of void, it is a method, not a constructor. Since only constructors can call super(), the code does not compile due to this line. The only constructor in this class, which takes an int value as input, performs a pointless assignment, assigning a variable to itself. While this assignment has no effect, it does not prevent the code from compiling. Finally, the main() method compiles without issue since we just inserted the full package name into the class constructor call. This is how a class that does not use an import statement could call the constructor. Since the method is in the same class, and therefore the same package, it is redundant to include the package name but not disallowed. Because only one line causes the class to fail to compile, Option B is correct.","A. An instance method or constructor has access to all static variables, making Option A correct. On the other hand, static methods and static initializers cannot reference instance variables since they are defined across all instances, making Options B and C incorrect. Note that they can access instance variables if they are passed a reference to a specific instance, but not in the general case. Finally, Option D is incorrect because static final variables must be set when they are declared or in a static initialization block.","B. The method calculateDistance() requires a return type that can be easily converted to a short value. Options A, C, and D are incorrect because they each use a larger data type that requires an explicit cast. Option D also does not compile because the Short constructor requires an explicit cast to convert the value of 4, which is assumed to be an int, to a short, as shown in new Short((short)4). Option B is the correct answer since a byte value can be easily promoted to short and returned by the method.","C. Overloaded methods have the same name but a different list of parameters, making the first and third statements true. The second statement is false, since overloaded methods can have the same or different return types. Therefore, Option C is the correct answer.","C. The declaration of monday does not compile, because the value of a static final variable must be set when it is declared or in a static initialization block. The declaration of tuesday is fine and compiles without issue. The declaration of wednesday does not compile because there is no data type for the variable. Finally, the declaration of thursday does not compile because the final modifier cannot appear before the access modifier. For these reasons, Option C is the correct answer.","D. The Puppy class does not declare a constructor, so the default no-argument constructor is automatically inserted by the compiler. What looks like a constructor in the class is actually a method that has a return type of void. Therefore, the line in the main() method to create the new Puppy(2) object does not compile, since there is no constructor capable of taking an int value, making Option D the correct answer.","A. The public modifier allows access to members in the same class, package, subclass, or even classes in other packages, while the private modifier allows access only to members in the same class. Therefore, the public access modifier allows access to everything the private access modifier does, and more, making Option A the correct answer. Options B, C, and D are incorrect because the first term is a more restrictive access modifier than the second term.","A. The code compiles without issue, so Option D is incorrect. The key here is that Java uses pass by value to send object references to methods. Since the Phone reference p was reassigned in the first line of the sendHome() method, any changes to the p reference were made to a new object. In other words, no changes in the sendHome() method affected the object that was passed in. Therefore, the value of size was the same before and after the method call, making the output 3 and Option A the correct answer.","B. Options A and D are equivalent and would allow the code to compile. They both are proper ways to access a static method from within an instance method. Option B is the correct answer. The class would not compile because this.Drink has no meaning to the compiler. Finally, Option C would still allow the code to compile, even though it is considered a poor coding practice. While static members should be accessed in a static way, it is not required.","C. The method signature requires one int value, followed by exactly one String, followed by String varargs, which can be an array of String values or zero or more individual String values. Only Option C conforms to these requirements, making it the correct answer.","D. Option A is a statement about final static variables, not all static variables. Option B only applies to static variables marked private, not final. Option C is false because static imports can be used to reference both variables and methods. Option D is the correct answer because a static variable is accessible to all instances of the class.","A. Option A is the correct answer because the first line of a constructor could be this() or super(), making it an untrue statement. Option B is a true statement because the compiler will insert the default no-argument constructor if one is not defined. Option C is also a true statement, since zero or more arguments may be passed to the parent constructor, if the parent class defines such constructors. Option D is also true. The value of a final instance variable should be set when it is declared, in an initialization block, or in a constructor.","D. The last static initialization block accesses height, which is an instance variable, not a static variable. Therefore, the code will not compile no matter how many final modifiers are removed, making Option D the correct answer. Note that if the line height = 4; was removed, then no final modifiers would need to be removed to make the class compile.","D. Since a constructor call is not the first line of the RainForest() constructor, the compiler inserts the no-argument super() call. Since the parent class, Forest, does not define a no-argument super() constructor, the RainForest() constructor does not compile, and Option D is correct.","A. The code compiles without issue, so Option D is incorrect. In the main() method, the value 2 is first cast to a byte. It is then increased by one using the addition + operator. The addition + operator automatically promotes all byte and short values to int. Therefore, the value passed to the choose() in the main() method is an int. The choose(int) method is called, returning 5 and making Option A the correct answer. Note that without the addition operation in the main() method, byte would have been used as the parameter to the choose() method, causing the choose(short) to be selected as the next closest type and outputting 2, making Option B the correct answer.","C. The variable startTime can be automatically converted to Integer by the compiler, but Integer is not a subclass of Long. Therefore, the code does not compile due the wrong variable type being passed to the getScore() method on line m2, and Option C is correct.","A. Java methods must start with a letter, the dollar $ symbol, or underscore _ character. For these reasons, Options B and D are incorrect, and Option A is correct. Option C is incorrect. The hashtag (#) symbol cannot be included in a method name.","B. The protected modifier allows access by any subclass or class that is in the same package, therefore Option B is the correct answer.","D. A static import is used to import static members of another class. In this case, the withdrawal() and deposit() methods in the Bank class are not marked static. They require an instance of Bank to be used and cannot be imported as static methods. Therefore, Option D is correct. If the two methods in the Bank class were marked static, then Option A would be the correct answer since wildcards can be used with static imports to import more than one method. Option B reverses the keywords static and import, while Option C incorrectly imports a class, which cannot be imported via a static import."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"Fill in the blanks: The____________ access modifier allows access to everything the ____________access modifier does and more.",code:null,answers:["package-private, protected","protected, public","protected, package-private","private, package-private"]},{title:"What is the command to call one constructor from another constructor in the same class?",code:null,answers:["super()","this()","that()","construct()"]},{title:"What is the output of the following application?",code:"<code>package stocks;</code>\n<code>public class Bond {</code>\n<code>   private static int price = 5;</code>\n<code>   public boolean sell() {</code>\n<code>      if(price&lt;10) {</code>\n<code>         price++;</code>\n<code>         return true;</code>\n<code>      } else if(price&gt;=10) {</code>\n<code>         return false;</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] cash) {</code>\n<code>      new Bond().sell();</code>\n<code>      new Bond().sell();</code>\n<code>      new Bond().sell();</code>\n<code>      System.out.print(price);</code>\n<code>   }</code>\n<code>}</code>",answers:["5","6","8","The code does not compile."]},{title:"What is true about the following program?",code:"<code>package figures;</code>\n<code>public class Dolls {</code>\n<code>   public void nested() { nested(2,true); } // g1</code>\n<code>   public int nested(int level, boolean height) { return nested(level); }</code>\n<code>   public int nested(int level) { return level+1; }; // g2</code>\n<code>&nbsp;</code>\n<code>   public static void main(String[] outOfTheBox) {</code>\n<code>      System.out.print(new Dolls().nested());</code>\n<code>   }</code>\n<code>}</code>",answers:["It compiles successfully and prints 3 at runtime.","It does not compile because of line g1.","It does not compile because of line g2.","It does not compile for some other reason."]},{title:"Fill in the blank: Java uses ___________ to send data into a method.",code:null,answers:["pass-by-null","pass-by-value","both pass-by-value and pass-by-reference","pass-by-reference"]},{title:"Which of the following is a valid JavaBean method signature?",code:null,answers:["public void getArrow()","public void setBow()","public void setRange(int range)","public String addTarget(String target)"]},{title:"Which of the following statements about calling this() in a constructor is not true?",code:null,answers:["If this() is used, it must be the first line of the constructor.","If super() and this() are both used in the same constructor, super() must appear on the line immediately after this().","If arguments are provided to this(), then there must be a constructor in the class able to take those arguments.","If the no-argument this() is called, then the class must explicitly implement the  no-argument constructor."]},{title:"Which of the following can fill in the blank to make the class compile?",code:"<code>package ai;</code>\n<code>public class Robot {</code>\n<code>   ____________ compute() { return 10; }</code>\n<code>}</code>",answers:["Public int","Long","void","private String"]},{title:"Fill in the blank: A  ____________variable is always available to all instances of the class.",code:null,answers:["public","local","static","instance"]},{title:"Which line of code, inserted at line p1, causes the application to print 5?",code:"<code>package games;</code>\n<code>public class Jump {</code>\n<code>   private int rope = 1;</code>\n<code>   protected boolean outside;</code>\n<code>   public Jump() {</code>\n<code>      // p1</code>\n<code>      outside = true;</code>\n<code>   }</code>\n<code>   public Jump(int rope) {</code>\n<code>      this.rope = outside ? rope : rope+1;</code>\n<code>   }</code>\n<code>   public static void main(String[] bounce) {</code>\n<code>      System.out.print(new Jump().rope);</code>\n<code>   }</code>\n<code>}</code>",answers:["this(4);","new Jump(4);","this(5);","rope = 4;"]},{title:"Which of the following statements is not true?",code:null,answers:["An instance of one class may access an instance of another class\u2019s attributes if it has a reference to the instance and the attributes are declared public.","An instance of one class may access package-private attributes in a parent class, provided the parent class is not in the same package.","Two instances of the same class may access each other\u2019s private attributes.","An instance of one class may access an instance of another class\u2019s attributes if both classes are located in the same package and marked protected."]},{title:"Given the following class, what should be inserted into the two blanks to ensure the class data is properly encapsulated?",code:"<code>package storage;</code>\n<code>public class Box {</code>\n<code>   public String stuff;</code>\n<code>    ____________String____________ () {</code>\n<code>      return stuff;</code>\n<code>   }</code>\n<code>&nbsp;</code>\n<code>   public void setStuff(String stuff) {</code>\n<code>      this.stuff = stuff;</code>\n<code>   }</code>\n<code>}</code>",answers:["public and getStuff","private and isStuff","public and setStuff","None of the above"]},{title:"Which statement about a no-argument constructor is true?",code:null,answers:["The Java compiler will always insert a default no-argument constructor if you do not define a no-argument constructor in your class.","In order for a class to call super() in one of its constructors, its parent class must explicitly implement a no-argument constructor.","If a class extends another class that has only one constructor that takes a value, then the child class must explicitly declare at least one constructor.","A class may contain more than one no-argument constructor."]},{title:"Which of the following method signatures does not contain a compiler error?",code:null,answers:["public void sing(String key, String... harmonies)","public void sing(int note, String... sound, int music)","public void sing(String... keys, String... pitches)","public void sing(String... notes, String melodies)"]},{title:"Given the following application, which diagram best represents the state of the mySkier, mySpeed, and myName variables in the main() method after the call to the slalom() method?",code:'<code>package slopes;</code>\n<code>public class Ski {</code>\n<code>   private int age = 18;</code>\n<code>   private static void slalom(Ski racer, int[] speed, String name) {</code>\n<code>      racer.age = 18;</code>\n<code>      name = "Wendy";</code>\n<code>      speed = new int[1];</code>\n<code>      speed[0] = 11;</code>\n<code>      racer = null;</code>\n<code>   }</code>\n<code>   public static void main(String... mountain) {</code>\n<code>      final Ski mySkier = new Ski();</code>\n<code>      mySkier.age = 16;</code>\n<code>      final int[] mySpeed = new int[1];</code>\n<code>      final String myName = "Rosie";</code>\n<code>      slalom(mySkier,mySpeed,myName);</code>\n<code>   }</code>\n<code>}</code>',answers:["1","2","3","4"]},{title:"Given the class below, which method signature could be successfully added to the class as an overloaded version of the findAverage() method?",code:"<code>public class Calculations {</code>\n<code>   public Integer findAverage(int sum) { return sum; }</code>\n<code>}</code>",answers:["public Long findAverage(int sum)","public Long findAverage(int sum, int divisor)","public Integer average(int sum)","private void findAverage(int sum)"]},{title:"Which of the following is not a reason to use encapsulation when designing a class?",code:null,answers:["Promote usability by other developers.","Maintain class data integrity of data elements.","Prevent users from modifying the internal attributes of a class.","Increase concurrency and improve performance."]},{title:"Which of the following data types can be modified after they are passed to a method as an argument?",code:null,answers:["int[]","String","long","boolean"]},{title:"What is the best way to call the following method from another class in the same package, assuming the class using the method does not have any static imports?",code:"<code>package useful;</code>\n<code>public class MathHelper {</code>\n<code>   public static int roundValue(double d) {</code>\n<code>      // Implementation omitted</code>\n<code>   }</code>\n<code>}</code>",answers:["MathHelper:roundValue(5.92)","MathHelper.roundValue(3.1)","roundValue(4.1)","useful.MathHelper.roundValue(65.3)"]},{title:"Given a method with one of the following return types, which data type prevents the return statement from being used within the method?",code:null,answers:["byte","String","void","None of the above"]},{title:"How many final modifiers would need to be removed for this application to compile?",code:"<code>package end;</code>\n<code>public final class Games {</code>\n<code>   public final static int finish(final int score) {</code>\n<code>      final int win = 3;</code>\n<code>      final int result = score++ &lt; 5 ? 2 : win;</code>\n<code>      return result+=win;</code>\n<code>   }</code>\n<code>   public static void main(final String[] v) {</code>\n<code>      System.out.print(finish(Integer.parseInt(v[0])));</code>\n<code>   }</code>\n<code>}</code>",answers:["None","One","Two","The code will not compile regardless of the number of final modifiers that are removed."]},{title:"Fill in the blanks:  ____________is used to call a constructor in the parent class, while  ____________is used to reference a member of the parent class.",code:null,answers:["super and this()","super and super()","super() and this","super() and super"]},{title:"Given the following method signature, which classes can call it?",code:"<code>void run(String government)</code>",answers:["Classes in other packages","Classes in the same package","Subclasses in a different package","All classes"]},{title:"Which statement(s) about the following class would help to properly encapsulate the data in the class?",code:"<code>package shield;</code>\n<code>public class Protect {</code>\n<code>   private String material;</code>\n<code>   protected int strength;</code>\n<code>&nbsp;</code>\n<code>   public int getStrength() {</code>\n<code>      return strength;</code>\n<code>   }</code>\n<code>   public void setStrength(int strength) {</code>\n<code>      this.strength = strength;</code>\n<code>   }</code>\n<code>}</code>",answers:["I","II and III","I, II, and III","None, the data in the class is already encapsulated."],ol:["Change the access modifier of strength to private.","Add a getter method for material.","Add a setter method for material."]},{title:"Which of the following is a valid method name in Java?",code:null,answers:["Go_$Outside$2()","have-Fun()","new()","9enjoyTheWeather()"]},{title:"Which of the following lines of code can be inserted in the line below that would allow the class to compile?",code:"<code>package farm;</code>\n<code>public class Coop {</code>\n<code>   public final int static getNumberOfChickens() {</code>\n<code>      // INSERT CODE HERE</code>\n<code>   }</code>\n<code>}</code>",answers:["return 3.0;","return 5L;","return 10;","None of the above"]},{title:"Which of the following is a true statement about passing data to a method?",code:null,answers:["A change made to a primitive value passed to a method is reflected in the calling method.","A change made to the data within an object passed to a method is reflected in the calling method.","Reassigning an object reference passed to a method is reflected in the calling method.","A change made to a boolean value passed to a method is reflected in the calling method."]},{title:"What is a possible output of the following application?",code:'<code>package wrap;</code>\n<code>public class Gift {</code>\n<code>   private final Object contents;</code>\n<code>   protected Object getContents() {</code>\n<code>      return contents;</code>\n<code>   }</code>\n<code>   protected void setContents(Object contents) {</code>\n<code>      this.contents = contents;</code>\n<code>   }</code>\n<code>   public void showPresent() {</code>\n<code>      System.out.print("Your gift: "+contents);</code>\n<code>   }</code>\n<code>   public static void main(String[] treats) {</code>\n<code>      Gift gift = new Gift();</code>\n<code>      gift.setContents(gift);</code>\n<code>      gift.showPresent();</code>\n<code>   }</code>\n<code>}</code>',answers:["Your gift: wrap.Gift@29ca2745","Your gift: Your gift:","It does not compile.","It compiles but throws an exception at runtime."]},{title:"Which of the following is a valid JavaBean method prefix?",code:null,answers:["is","gimme","request","put"]},{title:"Given the following two classes, each in a different package, which line inserted below allows the second class to compile?",code:'<code>package clothes;</code>\n<code>public class Store {</code>\n<code>   public static String getClothes() { return "dress"; }</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>package wardrobe;</code>\n<code>// INSERT CODE HERE</code>\n<code>public class Closet {</code>\n<code>   public void borrow() {</code>\n<code>      System.out.print("Borrowing clothes: "+getClothes());</code>\n<code>   }</code>\n<code>}</code>',answers:["static import clothes.Store.getClothes;","import clothes.Store.*;","import static clothes.Store.getClothes;","import static clothes.Store;"]},{title:"What access modifier is used to mark class members package-private?",code:null,answers:["private","default","protected","None of the above"]},{title:"How many lines of the following program contain compilation errors?",code:'<code>package sky;</code>\n<code>public class Stars {</code>\n<code>   private int inThe = 4;</code>\n<code>   public void Stars() {</code>\n<code>      super();</code>\n<code>   }</code>\n<code><span epub:type="pagebreak" id="Page_90"></span>   public Stars(int inThe) {</code>\n<code>      this.inThe = this.inThe;</code>\n<code>   }</code>\n<code>   public static void main(String[] endless) {</code>\n<code>      System.out.print(new sky.Stars(2).inThe);</code>\n<code>   }</code>\n<code>}</code>',answers:["None","One","Two","Three"]},{title:"Which of the following statements is true?",code:null,answers:["An instance method is allowed to reference a static variable.","A static method is allowed to reference an instance variable.","A static initialization block is allowed to reference an instance variable.","A final static variable may be set in a constructor."]},{title:"Given the following method declaration, which line can be inserted to make the code\xa0compile?",code:"<code>public short calculateDistance(double lat1, double lon1,</code>\n<code>      double lat2, double lon2) {</code>\n<code>   // INSERT CODE HERE</code>\n<code>}</code>",answers:["return new Integer(3);","return new Byte((byte)6);","return 5L;","return new Short(4).longValue();"]},{title:"Which of the following statements about overloaded methods are true? ",code:null,answers:["I","I and II","I and III","I, II, and III"],ol:["Overloaded methods must have the same name.","Overloaded methods must have the same return type.","Overloaded methods must have a different list of parameters."]},{title:"How many lines of code would need to be removed for the following class to compile?",code:"<code>package work;</code>\n<code>public class Week {</code>\n<code>   private static final String monday;</code>\n<code>   String tuesday;</code>\n<code>   final static wednesday = 3;</code>\n<code>   final protected int thursday = 4;</code>\n<code>}</code>",answers:["One","Two","Three","The code will not compile regardless of the number of lines removed."]},{title:"What is the output of the following application?",code:"<code>package pet;</code>\n<code>public class Puppy {</code>\n<code>   public static int wag = 5;   // q1</code>\n<code>   public void Puppy(int wag) { // q2</code>\n<code>      this.wag = wag;</code>\n<code>   }</code>\n<code>   public static void main(String[] tail) {</code>\n<code>      System.out.print(new Puppy(2).wag); // q3</code>\n<code>   }</code>\n<code>}</code>",answers:["2","It does not compile because of line q1.","It does not compile because of line q2.","It does not compile because of line q3."]},{title:"Fill in the blanks: The  ____________access modifier allows access to everything the  ____________access modifier does and more.",code:null,answers:["public, private","private, package-private","package-private, protected","private, public"]},{title:"What is the output of the following application?",code:"<code>package ship;</code>\n<code>public class Phone {</code>\n<code>   private int size;</code>\n<code>   public Phone(int size) {this.size=size;}</code>\n<code>&nbsp;</code>\n<code>   public static void sendHome(Phone p, int newSize) {</code>\n<code>      p = new Phone(newSize);</code>\n<code>      p.size = 4;</code>\n<code>   }</code>\n<code>   public static final void main(String... params) {</code>\n<code>      final Phone phone = new Phone(3);</code>\n<code>      sendHome(phone,7);</code>\n<code>      System.out.print(phone.size);</code>\n<code>   }</code>\n<code>}</code>",answers:["3","4","7","The code does not compile."]},{title:"Given the following class, which line of code when inserted below would prevent the class from compiling?",code:"<code>public class Drink {</code>\n<code>   public static void water() {}</code>\n<code>   public void get() {</code>\n<code>      // INSERT CODE HERE</code>\n<code>   }</code>\n<code>}</code>",answers:["water();","this.Drink.water();","this.water();","Drink.water();"]},{title:"Given the following method declaration signature, which of the following is a valid call of this method?",code:"<code>public void call(int count, String me, String... data)</code>",answers:['call(9,"me",10,"Al")',"call(5)",'call(2,"home","sweet")','call("answering","service")']},{title:"Which statement about a static variable is true?",code:null,answers:["The value of a static variable must be set when the variable is declared or in a static initialization block.","It is not possible to read static final variables outside the class in which they are defined.","It is not possible to reference static methods using static imports.","A static variable is always available in all instances of the class."]},{title:"Which of the following is not a true statement?",code:null,answers:["The first line of every constructor is a call to the parent constructor via the super() command.","A class does not have to have a constructor explicitly defined.","A constructor may pass arguments to the parent constructor.","A final instance variable whose value is not set when they are declared or in an initialization block should be set by the constructor."]},{title:"How many final modifiers would need to be removed for this application to compile?",code:"<code>package park;</code>\n<code>public class Tree {</code>\n<code>   public final static long numberOfTrees;</code>\n<code>   public final double height;</code>\n<code>   static {}</code>\n<code>   { final int initHeight = 2;</code>\n<code>     height = initHeight;</code>\n<code>   }</code>\n<code>   static {</code>\n<code>      numberOfTrees = 100;</code>\n<code>      height = 4;</code>\n<code>   }</code>\n<code>}</code>",answers:["None","One","Two","The code will not compile regardless of the number of final modifiers removed."]},{title:"What is the output of the following application?",code:"<code>package jungle;</code>\n<code>public class RainForest extends Forest {</code>\n<code>   public RainForest(long treeCount) {</code>\n<code>      this.treeCount = treeCount+1;</code>\n<code>   }</code>\n<code>   public static void main(String[] birds) {</code>\n<code>      System.out.print(new RainForest(5).treeCount);</code>\n<code>   }</code>\n<code>}</code>\n<code>class Forest {</code>\n<code>   public long treeCount;</code>\n<code>   public Forest(long treeCount) {</code>\n<code>      this.treeCount = treeCount+2;</code>\n<code>   }</code>\n<code>}</code>",answers:["5","6","8","The code does not compile."]},{title:"What is the output of the following application?",code:"<code>public class ChooseWisely {</code>\n<code>   public ChooseWisely() { super(); }</code>\n<code>   public int choose(int choice) { return 5; }</code>\n<code>   public int choose(short choice) { return 2; }</code>\n<code>   public int choose(long choice) { return 11; }</code>\n<code>   public static void main(String[] path) {</code>\n<code>      System.out.print(new ChooseWisely().choose((byte)2+1));</code>\n<code>   }</code>\n<code>}</code>",answers:["5","2","11","The code does not compile."]},{title:"What is the output of the following application?",code:"<code>package sports;</code>\n<code>public class Football {</code>\n<code>   public static Long getScore(Long timeRemaining) {</code>\n<code>      return 2*timeRemaining; // m1</code>\n<code>   }</code>\n<code>   public static void main(String[] refs) {</code>\n<code>      final int startTime = 4;</code>\n<code>      System.out.print(getScore(startTime)); // m2</code>\n<code>   }</code>\n<code>}</code>",answers:["8","The code does not compile because of line m1.","The code does not compile because of line m2.","The code compiles but throws an exception at runtime."]},{title:"Which of the following is a valid method name in Java?",code:null,answers:["$sprint()","\\jog13()","walk#()","%run()"]},{title:"Assume there is a class Bouncer with a protected variable. Methods in which class can access this variable?",code:null,answers:["Only subclasses of Bouncer","Any subclass of Bouncer or any class in the same package as Bouncer","Only classes in the same package as Bouncer","Any superclass of Bouncer"]},{title:"Given the following two classes, each in a different package, which line inserted below allows the second class to compile?",code:'<code>package commerce;</code>\n<code>public class Bank {</code>\n<code>   public void withdrawal(int amountInCents) {}</code>\n<code>   public void deposit(int amountInCents) {}</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>package employee;</code>\n<code>// INSERT CODE HERE</code>\n<code>public class Teller {</code>\n<code>   public void processAccount(int depositSlip, int withdrawalSlip) {</code>\n<code><span epub:type="pagebreak" id="Page_96"></span>      withdrawal(withdrawalSlip);</code>\n<code>      deposit(depositSlip);</code>\n<code>   }</code>\n<code>}</code>',answers:["import static commerce.Bank.*;","static import commerce.Bank.*;","import static commerce.Bank;","None of the above"]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t],ol:e.ol}});i[14].imageUrl="./images/image-oca-ch6-15.png",t.default=i},163:function(e,t,o){"use strict";o.r(t);var n=["C. The code does not compile, so Option A is incorrect. This code does not compile for two reasons. First, the name variable is marked private in the Cinema class, which means it cannot be accessed directly in the Movie class. Next, the Movie class defines a constructor that is missing an explicit super() statement. Since Cinema does not include a no-argument constructor, the no-argument super() cannot be inserted automatically by the compiler without a compilation error. For these two reasons, the code does not compile, and Option C is the correct answer.","D. All abstract interface methods are implicitly public, making Option D the correct answer. Option A is incorrect because protected conflicts with the implicit public modifier. Since static methods must have a body and abstract methods cannot have a body, Option B is incorrect. Finally, Option C is incorrect. A method, whether it be in an interface or a class, cannot be declared both final and abstract, as doing so would prevent it from ever being implemented.","C. A class cannot contain two methods with the same method signature, even if one is static and the other is not. Therefore, the code does not compile because the two declarations of playMusic() conflict with one another, making Option C the correct answer.","A. Inheritance is often about improving code reusability, by allowing subclasses to inherit commonly used attributes and methods from parent classes, making Option A the correct answer. Option B is incorrect. Inheritance can lead to either simpler or more complex code, depending on how well it is structured. Option C is also incorrect. While all objects inherit methods from java.lang.Object, this does not apply to primitives. Finally, Option D is incorrect because methods that reference themselves are not a facet of inheritance.","A. Recall that this refers to an instance of the current class. Therefore, any superclass of Canine can be used as a return type of the method, including Canine itself, making Option C an incorrect answer. Option B is also incorrect because Canine implements the Pet interface. An instance of a class can be assigned to any interface reference that it inherits. Option D is incorrect because Object is the superclass of instances in Java. Finally, Option A is the correct answer. Canine cannot be returned as an instance of Class because it does not inherit Class.","B. The key here is understanding which of these features of Java allow one developer to build their application around another developer\u2019s code, even if that code is not ready yet. For this problem, an interface is the best choice. If the two teams agree on a common interface, one developer can write code that uses the interface, while another developer writes code that implements the interface. Assuming neither team changes the interface, the code can be easily integrated once both teams are done. For these reasons, Option B is the correct answer.","B. The drive() method in the Car class does not override the version in the Automobile class since the method is not visible to the Car class. Therefore, the final attribute in the Automobile class does not prevent the Car class from implementing a method with the same signature. The drive() method in the ElectricCar class is a valid override of the method in the Car class, with the access modifier expanding in the subclass. For these reasons, the code compiles, and Option D is incorrect. In the main() method, the object created is an ElectricCar, even if it is assigned to a Car reference. Due to polymorphism, the method from the ElectricCar will be invoked, making Option B the correct answer.","D. While Java does not allow a class to extend more than one class, it does allow a class to implement any number of interfaces. Multiple inheritance is, therefore, only allowed via interfaces, making Option D the correct answer.","C. There are three problems with this method override. First, the watch() method is marked final in the Television class. The final modifier would have to be removed from the method definition in the Television class in order for the method to compile in the LCD class. Second, the return types void and Object are not covariant. One of them would have to be changed for the override to be compatible. Finally, the access modifier in the child class must be the same or broader than in the parent class. Since package-private is narrower than protected, the code will not compile. For these reasons, Option C is the correct answer.","C. First off, the return types of an overridden method must be covariant. Next, it is true that the access modifier must be the same or broader in the child method. Using a narrower access modifier in the child class would not allow the code to compile. Overridden methods must not throw any new or broader checked exceptions than the method in the superclass. For these reasons, Options A, B, and D are true statements. Option C is the false statement. An overridden method is not required to throw a checked exception defined in the parent class.","C. The process() method is declared final in the Computer class. The Laptop class then attempts to override this method, resulting in a compilation error, making Option C the correct answer.","A. The code compiles without issue, so Option D is incorrect. The rule for overriding a method with exceptions is that the subclass cannot throw any new or broader checked exceptions. Since FileNotFoundException is a subclass of IOException, it is considered a narrower exception, and therefore the overridden method is allowed. Due to polymorphism, the overridden version of the method in HighSchool is used, regardless of the reference type, and 2 is printed, making Option A the correct answer. Note that the version of the method that takes the varargs is not used in this application.","B. Interface methods are implicitly public, making Option A and C incorrect. Interface methods can also not be declared final, whether they are static, default, or abstract methods, making Option D incorrect. Option B is the correct answer because an interface method can be declared static.","C. Having one class implement two interfaces that both define the same default method signature leads to a compiler error, unless the class overrides the default method. In this case, the Sprint class does override the walk() method correctly, therefore the code compiles without issue, and Option C is correct.","B. Interfaces can extend other interfaces, making Option A incorrect. On the other hand, an interface cannot implement another interface, making Option B the correct answer. A class can implement any number of interfaces, making Option C incorrect. Finally, a class can extend another class, making Option D incorrect.","D. The code does not compile because super.height is not visible in the Rocket class, making Option D the correct answer. Even though the Rocket class defines a height value, the super keyword looks for an inherited version. Since there are none, the code does not compile. Note that super.getWeight() returns 3 from the variable in the parent class, as polymorphism and overriding does not apply to instance variables.","D. An abstract class can contain both abstract and concrete methods, while an interface can only contain abstract methods. With Java 8, interfaces can now have static and default methods, but the question specifically excludes them, making Option D the correct answer. Note that concrete classes cannot contain any abstract methods.","C. The code does not compile, so Option D is incorrect. The IsoscelesRightTriangle class is abstract; therefore, it cannot be instantiated on line g3. Only concrete classes can be instantiated, so the code does not compile, and Option C is the correct answer. The rest of the lines of code compile without issue. A concrete class can extend an abstract class, and an abstract class can extend a concrete class. Also, note that the override of getDescription() has a widening access modifier, which is fine per the rules of overriding methods.","D. The play() method is overridden in Saxophone for both Horn and Woodwind, so the return type must be covariant with both. Unfortunately, the inherited methods must also be compatible with each other. Since Integer is not a subclass of Short, and vice versa, there is no subclass that can be used to fill in the blank that would allow the code to compile. In other words, the Saxophone class cannot compile regardless of its implementation of play(), making Option D the correct answer.","C. A class can implement an interface, not extend it. Alternatively, a class extends an abstract class. Therefore, Option C is the correct answer.","A. The code compiles and runs without issue, making Options C and D incorrect. Although super.material and this.material are poor choices in accessing static variables, they are permitted. Since super is used to access the variable in getMaterial(), the value papyrus is returned, making Option A the correct answer. Also, note that the constructor Book(String) is not used in the Encyclopedia class.","B. Options A and C are both true statements. Either the unknownBunny reference variable is the same as the object type or it can be explicitly cast to the Bunny object type, therefore giving it access to all its members. This is the key distinction between reference types and object types. Assigning a new reference does not change the underlying object. Option D is also a true statement since any superclass that Bunny extends or interface it implements could be used as the data type for unknownBunny. Option B is the false statement and the correct answer. An object can be assigned to a reference variable type that it inherits, such as Object unknownBunny = new Bunny().","D. An abstract method cannot include the final or private method. If a class contained either of these modifiers, then no concrete subclass would ever be able to override them with an implementation. For these reasons, Options A and B are incorrect. Option C is also incorrect because the default keyword applies to concrete interface methods, not abstract methods. Finally, Option D is correct. The protected, package-private, and public access modifiers can each be applied to abstract methods.","D. The declaration of Sphere compiles without issue, so Option C is incorrect. The Mars class declaration is invalid because Mars cannot extend Sphere, an interface, nor can Mars implement Planet, a class. In other words, they are reversed. Since the code does not compile, Option D is the correct answer. Note that if Sphere and Planet were swapped in the Mars class definition, the code would compile and the output would be Mars, making Option A the correct answer.","B. A reference to a class can be implicitly assigned to a superclass reference without an explicit class, making Option B the correct answer. Assigning a reference to a subclass, though, requires an explicit cast, making Option A incorrect. Option C is also incorrect because an interface does not inherit from a class. A reference to an interface requires an explicit cast to be assigned to a reference of any class, even one that implements the interface. An interface reference requires an explicit cast to be assigned to a class reference. Finally, Option D is incorrect. An explicit cast is not required to assign a reference to a class that implements an interface to a reference of the interface.","B. Interface variables are implicitly public, static, and final. Variables cannot be declared as abstract in interfaces, nor in classes.","C. The class is loaded first, with the static initialization block called and 1 is outputted first. When the BlueCar is created in the main() method, the superclass initialization happens first. The instance initialization blocks are executed before the constructor, so 32 is outputted next. Finally, the class is loaded with the instance initialization blocks again being called before the constructor, outputting 45. The result is that 13245 is printed, making Option C the correct answer.","C. Overloaded methods share the same name but a different list of parameters and an optionally different return type, while overridden methods share the exact same name, list of parameters, and return type. For both of these, the one commonality is that they share the same method name, making Option C the correct answer.","A. Although the casting is a bit much, the object in question is a SoccerBall. Since SoccerBall extends Ball and implements Equipment, it can be explicitly cast to any of those types, so no compilation error occurs. At runtime, the object is passed around and, due to polymorphism, can be read using any of those references since the underlying object is a SoccerBall. In other words, casting it to a different reference variable does not modify the object or cause it to lose its underlying SoccerBall information. Therefore, the code compiles without issue, and Option A is correct.","C. Both of these descriptions refer to variable and static method hiding, respectively, making Option C correct. Only instance methods can be overridden, making Options A and B incorrect. Option D is also incorrect because replacing is not a real term in this context.","B. The code does not compile, so Option D is incorrect. The issue here is that the override of getEqualSides() in Square is invalid. A static method cannot override a non-static method and vice versa. For this reason, Option B is the correct answer.","C. The application does not compile, but not for any reason having to do with the cast in the main() method. The Rotorcraft class includes an abstract method, but the class itself is not marked abstract. Only interfaces and abstract classes can include abstract methods. Since the code does not compile, Option C is the correct answer. ","B. A class can trivially be assigned to a superclass reference variable but requires an explicit cast to be assigned to a subclass reference variable. For these reasons, Option B is correct. ","C. A concrete class is the first non-abstract subclass that extends an abstract class and implements any inherited interfaces. It is required to implement all inherited abstract methods, making Option C the correct answer.","D. First of all, interfaces can only contain abstract, final, and default methods. The method fly() defined in CanFly is not marked static or default and defines an implementation, an empty {}, meaning it cannot be assumed to be abstract; therefore, the code does not compile. Next, the implementation of fly(int speed) in the Bird class also does not compile, but not because of the signature. The method body fails to return an int value. Since it is an overloaded method, if it returned a value it would compile without issue. Finally, the Eagle class does not compile because it extends the Bird class, which is marked final and therefore, cannot be extended. For these three reasons, Option D is the correct answer.","B. Abstract classes and interfaces can both contain static and abstract methods as well as static variables, but only an interface can contain default methods. Therefore, Option B is correct.","C. Java does not allow multiple inheritance, so having one class extend two interfaces that both define the same default method signature leads to a compiler error, unless the class overrides the method. In this case, though, the talk(String...) method defined in the Performance class is not an overridden version of method defined in the interfaces because the signatures do not match. Therefore, the Performance class does not compile since the class inherits two default methods with the same signature and no overridden version, making Option C the correct answer.","A. In Java, only non-static, non-final, and non-private methods are considered virtual and capable of being overridden in a subclass. For this reason, Option A is the correct answer.","B. An interface can only extend another interface, while a class can only extend another class. A class can also implement an interface, although that comparison is not part of the question text. Therefore, Option B is the correct answer.","A. The code compiles without issue, so Option D is incorrect. Java allows methods to be overridden, but not variables. Therefore, marking them final does not prevent them from being reimplemented in a subclass. Furthermore, polymorphism does not apply in the same way it would to methods as it does to variables. In particular, the reference type determines the version of the secret variable that is selected, making the output 2 and Option A the correct answer.","D. Options A and C are incorrect because an overridden method cannot reduce the visibility of the inherited method. Option B is incorrect because an overridden method cannot declare a broader checked exception than the inherited method. Finally, Option D is the correct answer. The removal of the checked exception, the application of a broader access modifier, and the addition of the final attribute are allowed for overridden methods.","C. The setAnimal() method requires an object that is Dog or a subclass of Dog. Since Husky extends Dog, Options A and B both allow the code to compile. Option D is also valid because a null value does not have a type and can be assigned to any reference variable. Option C is the only value that prevents the code from compiling because Wolf is not a subclass of Dog. Even though Wolf can be assigned to the instance Canine variable, the setter requires a compatible parameter.","A. An interface method can be abstract and not have a body, or it can be default or static and have a body. An interface method cannot be final though, making Option A the correct answer.","A. It looks like getSpace() in the Room class is an invalid override of the version in the House class since package-private is a more restrictive access modifier than protected, but the parameter list changes; therefore, this is an overloaded method, not an overridden one. Furthermore, the Ballroom class is abstract so no object is instantiated, but there is no requirement that an abstract class cannot contain a runnable main() method. For these reasons, the code compiles and runs without issue, making Option A correct.","D. Trick question! Option A seems like the correct answer, but the second part of the sentence is false, regardless of whether you insert overloaded or overridden. Overridden methods must have covariant return types, which may not be exactly the same as the type in the parent class. Therefore, Option D is the correct answer.","B. If a parent class does not include a no-argument constructor, a child class can still explicitly declare one; it just has to call an appropriate parent constructor with super(), making Option A incorrect. If a parent class does not include a no-argument constructor, the child class must explicitly declare a constructor, since the compiler will not be able to insert the default no-argument constructor, making Option B correct. Option C is incorrect because a parent class can have a no-argument constructor, while its subclasses do not. If Option C was true, then all classes would be required to have no-argument constructors since they all extend java.lang.Object, which has a no-argument constructor. Option D is also incorrect. The default no-argument constructor can be inserted into any class that directly extends a class that has a no-argument constructor. Therefore, no constructors in the subclass are required.","D. The object type relates to the attributes of the object that exist in memory, while the reference type dictates how the object is able to be used by the caller. For these reasons, Option D is correct.","A. The play() method is overridden in Violin for both MusicCreator and StringInstrument, so the return type must be covariant with both. Long is a subclass of Number, and therefore, it is covariant with the version in MusicCreator. Since it matches the type in StringInstrument, it can be inserted into the blank and the code would compile. While Integer is a subclass of Number, meaning the override for MusicCreator is valid, it is not a subclass of Long used in StringInstrument. Therefore, using Integer would cause the code to not compile. Finally, Number is compatible with the version of the method in MusicCreator but not with the version in StringInstrument, because Number is a superclass of Long, not a subclass. For these reasons, Long is the only class that allows the code to compile, making Option A the correct answer.","B. The primary motivation for adding default interface methods to Java was for backward compatibility. These methods allow developers to update older classes with a newer version of an interface without breaking functionality in the existing classes, making Option B the correct answer. Option is A is nonsensical and not the correct answer. Options C and D sound plausible, but both could be accomplished with static interface methods alone.","C. The rule for overriding a method with exceptions is that the subclass cannot throw any new or broader checked exceptions. Since IOException is a superclass of EOFException, from the question description, we see that this is a broader exception and therefore not compatible. For this reason, the code does not compile, and Option C is the correct answer."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"How many lines of the following program contain compilation errors?",code:'<code>package theater;</code>\n<code>class Cinema {</code>\n<code>   private String name;</code>\n<code>   public Cinema(String name) {this.name = name;}</code>\n<code>}</code>\n<code>public class Movie extends Cinema {</code>\n<code>   public Movie(String movie) {}</code>\n<code>   public static void main(String[] showing) {</code>\n<code>      System.out.print(new Movie("Another Trilogy").name);</code>\n<code>   }</code>\n<code>}</code>',answers:["None","One","Two","Three"]},{title:"Which modifier can be applied to an abstract interface method?",code:null,answers:["protected","static","final","public"]},{title:"What is the output of the following application?",code:'<code>package radio;</code>\n<code>public class Song {</code>\n<code>   public void playMusic() {</code>\n<code>      System.out.print("Play!");</code>\n<code>   }</code>\n<code>   private static int playMusic() {</code>\n<code>      System.out.print("Music!");</code>\n<code>   }</code>\n<code>   public static void main(String[] tracks) {</code>\n<code>      new Song().playMusic();</code>\n<code>   }</code>\n<code>}</code>',answers:["Play!","Music!","The code does not compile.","The code compiles but the answer cannot be determined until runtime."]},{title:"Which of the following statements about inheritance is true?",code:null,answers:["Inheritance allows objects to access commonly used attributes and methods.","Inheritance always leads to simpler code.","All primitives and objects inherit a set of methods.","Inheritance allows you to write methods that reference themselves."]},{title:"Given the class declaration below, which value cannot be inserted into the blank line that would allow the code to compile?",code:"<code>package mammal;</code>\n<code>interface Pet {}</code>\n<code>public class Canine implements Pet {</code>\n<code>   public ___________ getDoggy() {</code>\n<code>      return this;</code>\n<code>   }</code>\n<code>}</code>",answers:["Class","Pet","Canine","Object"]},{title:"Imagine you are working with another team to build an application. You are developing code that uses a class that the other team has not finished writing yet. Which element of Java would best facilitate this development, allowing easy integration once the other team\u2019s code is complete?",code:null,answers:["An abstract class","An interface","static methods","An access modifier"]},{title:"What is the output of the following application?",code:'<code>package vehicles;</code>\n<code>class Automobile {</code>\n<code>   private final String drive() { return "Driving vehicle"; }</code>\n<code>}</code>\n<code>class Car extends Automobile {</code>\n<code>   protected String drive() { return "Driving car"; }</code>\n<code>}</code>\n<code>public class ElectricCar extends Car {</code>\n<code>   public final String drive() { return "Driving electric car"; }</code>\n<code>   public static void main(String[] wheels) {</code>\n<code>      final Car car = new ElectricCar();</code>\n<code><span epub:type="pagebreak" id="Page_100"></span>      System.out.print(car.drive());</code>\n<code>   }</code>\n<code>}</code>',answers:["Driving vehicle","Driving electric car","Driving car","The code does not compile."]},{title:"Which of the following statements about inheritance is correct?",code:null,answers:["Java does not support multiple inheritance.","Java allows multiple inheritance using abstract classes.","Java allows multiple inheritance using non-abstract classes.","Java allows multiple inheritance using interfaces."]},{title:"How many changes need to be made to the classes below to properly override the watch() method?",code:"<code>package entertainment;</code>\n<code>class Television {</code>\n<code>   protected final void watch() {}</code>\n<code>}</code>\n<code>public class LCD extends Television {</code>\n<code>   Object watch() {}</code>\n<code>}</code>",answers:["One","Two","Three","None; the code compiles as is."]},{title:"Which of the following statements about overriding a method is incorrect?",code:null,answers:["The return types must be covariant.","The access modifier of the method in the child class must be the same or broader than the method in the superclass.","A checked exception thrown by the method in the parent class must be thrown by the method in the child class.","A checked exception thrown by a method in the child class must be the same or  narrower than the exception thrown by the method in the parent class."]},{title:"What is the output of the following application?",code:'<code>package machines;</code>\n<code>class Computer {</code>\n<code>   protected final int process() { return 5; }</code>\n<code><span epub:type="pagebreak" id="Page_101"></span>}</code>\n<code>public class Laptop extends Computer {</code>\n<code>   public final int process() { return 3; }</code>\n<code>   public static void main(String[] chips) {</code>\n<code>      System.out.print(new Laptop().process());</code>\n<code>   }</code>\n<code>}</code>',answers:["5","3","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Given that FileNotFoundException is a subclass of IOException, what is the output of the following application?",code:"<code>package edu;</code>\n<code>import java.io.*;</code>\n<code>class School {</code>\n<code>   public int getNumberOfStudentsPerClassroom(String... students)           throws IOException {</code>\n<code>      return 3;</code>\n<code>   }</code>\n<code>   public int getNumberOfStudentsPerClassroom() throws IOException {</code>\n<code>      return 9;</code>\n<code>   }</code>\n<code>}</code>\n<code>public class HighSchool extends School {</code>\n<code>   public int getNumberOfStudentsPerClassroom() throws FileNotFoundException {</code>\n<code>      return 2;</code>\n<code>   }</code>\n<code>   public static void main(String[] students) throws IOException {</code>\n<code>      School school = new HighSchool();</code>\n<code>      System.out.print(school.getNumberOfStudentsPerClassroom());</code>\n<code>   }</code>\n<code>}</code>",answers:["2","3","9","The code does not compile."]},{title:"Which modifier can be applied to an interface method?",code:null,answers:["protected","static","private","final"]},{title:"What is the output of the following application?",code:'<code>package track;</code>\n<code>interface Run {</code>\n<code>   default void walk() {</code>\n<code>      System.out.print("Walking and running!");</code>\n<code>   }</code>\n<code>}</code>\n<code>interface Jog {</code>\n<code>   default void walk() {</code>\n<code>      System.out.print("Walking and jogging!");</code>\n<code>   }</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>public class Sprint implements Run, Jog {</code>\n<code>   public void walk() {</code>\n<code>      System.out.print("Sprinting!");</code>\n<code>   }</code>\n<code>   public static void main() {</code>\n<code>      new Sprint().walk();</code>\n<code>   }</code>\n<code>}</code>',answers:["Walking and running!","Walking and jogging!","Sprinting!","The code does not compile."]},{title:"Which of the following statements about interfaces is not true?",code:null,answers:["An interface can extend another interface.","An interface can implement another interface.","A class can implement two interfaces.","A class can extend another class."]},{title:"What is the output of the following application?",code:'<code>package transport;</code>\n<code>&nbsp;</code>\n<code>class Ship {</code>\n<code>   protected int weight = 3;</code>\n<code>   private int height = 5;</code>\n<code>   public int getWeight() { return weight; }</code>\n<code>   public int getHeight() { return height; }</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>public class Rocket extends Ship {</code>\n<code>   public int weight = 2;</code>\n<code>   public int height = 4;</code>\n<code>   public void printDetails() {</code>\n<code>      System.out.print(super.getWeight()+","+super.height);</code>\n<code>   }</code>\n<code>   public static final void main(String[] fuel) {</code>\n<code>      new Rocket().printDetails();</code>\n<code>   }</code>\n<code>}</code>',answers:["2,5","3,4","3,5","The code does not compile."]},{title:"Fill in the blanks: Excluding default and static methods, a(n)  ____________can contain both abstract and concrete methods, while a(n)  ____________contains only abstract methods.",code:null,answers:["concrete class, abstract class","concrete class, interface","interface, abstract class","abstract class, interface"]},{title:"Which statement about the following class is correct?",code:'<code>package shapes;</code>\n<code>&nbsp;</code>\n<code>abstract class Triangle {</code>\n<code>   abstract String getDescription();</code>\n<code>}</code>\n<code><span epub:type="pagebreak" id="Page_104"></span>class RightTriangle extends Triangle {</code>\n<code>   protected String getDescription() { return "rt"; } // g1</code>\n<code>}</code>\n<code>public abstract class IsoscelesRightTriangle extends RightTriangle { // g2</code>\n<code>   public String getDescription() { return "irt"; }</code>\n<code>   public static void main(String[] edges) {</code>\n<code>      final Triangle shape = new IsoscelesRightTriangle(); // g3</code>\n<code>      System.out.print(shape.getDescription());</code>\n<code>   }</code>\n<code>}</code>',answers:["The code does not compile due to line g1.","The code does not compile due to line g2.","The code does not compile due to line g3.","The code compiles and runs without issue."]},{title:"Given that Short and Integer extend Number, what type can be used to fill in the blank in the class below to allow it to compile?",code:"<code>package band;</code>\n<code>&nbsp;</code>\n<code>interface Horn { public Integer play(); }</code>\n<code>abstract class Woodwind { public Short play() {return 3;} }</code>\n<code>public final class Saxophone extends Woodwind implements Horn {</code>\n<code>   public  ___________play() {</code>\n<code>      return null;</code>\n<code>   }</code>\n<code>}</code>",answers:["Integer","Short","Number","None of the above"]},{title:"Fill in the blanks: A class  ____________an interface, while a class  ____________an abstract class.",code:null,answers:["extends, implements","extends, extends","implements, extends","implements, implements"]},{title:"What is the output of the following application?",code:'<code>package paper;</code>\n<code>&nbsp;</code>\n<code>abstract class Book {</code>\n<code>   protected static String material = "papyrus";</code>\n<code>   public Book() {}</code>\n<code>   public Book(String material) {this.material = material;}</code>\n<code>}</code>\n<code>public class Encyclopedia extends Book {</code>\n<code>   public static String material = "cellulose";</code>\n<code>   public Encyclopedia() {super();}</code>\n<code>   public String getMaterial() {return super.material;}</code>\n<code>   public static void main(String[] pages) {</code>\n<code>      System.out.print(new Encyclopedia().getMaterial());</code>\n<code>   }</code>\n<code>}</code>',answers:["papyrus","cellulose","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"The following diagram shows two reference variables pointing to the same Bunny object in memory. The reference variable myBunny is of type Bunny, while unknownBunny is of an\xa0unknown data type. Which statement about the reference variables is not true? For this question, assume the instance methods and variables shown in the diagram are marked\xa0public.",code:null,answers:["If the unknownBunny reference does not have access to the same variables and methods that myBunny has access to, it can be explicitly cast to a reference type that does.","The data type of unknownBunny must be Bunny or a subclass of Bunny.","If the data type of unknownBunny is Bunny, it has access to all of the same methods and variables as myBunny.","The data type of unknownBunny could be an interface, class, or abstract class."]},{title:"Which of the following modifiers can be applied to an abstract method?",code:null,answers:["final","private","default","protected"]},{title:"What is the output of the following application?",code:'<code>package space;</code>\n<code>&nbsp;</code>\n<code>interface Sphere {</code>\n<code>   default String getName() { return "Unknown"; }</code>\n<code>}</code>\n<code>abstract class Planet {</code>\n<code>   abstract String getName();</code>\n<code>}</code>\n<code>public class Mars extends Sphere implements Planet {</code>\n<code>   public Mars() {</code>\n<code>      super();</code>\n<code>   }</code>\n<code>   public String getName() { return "Mars"; }</code>\n<code>   public static void main(final String[] probe) {</code>\n<code>      System.out.print(((Planet)new Mars()).getName());</code>\n<code>   }</code>\n<code>}</code>',answers:["Mars","Unknown","The code does not compile due to the declaration of Sphere.","The code does not compile for another reason."]},{title:"Which of the following statements is correct?",code:null,answers:["A reference to a class can be assigned to a subclass reference without an explicit cast.","A reference to a class can be assigned to a superclass reference without an explicit cast.","A reference to an interface can be assigned to a reference of a class that implements the interface without an explicit cast.","A reference to a class that implements an interface can be assigned to an interface  reference only with an explicit cast."]},{title:"Of the following four modifiers, choose the one that is not implicitly applied to all interface variables.",code:null,answers:["final","abstract","static","public"]},{title:"What is the output of the following application?",code:'<code>package race;</code>\n<code>abstract class Car {</code>\n<code>   static { System.out.print("1"); }</code>\n<code>   public Car(String name) {</code>\n<code>      super();</code>\n<code>      System.out.print("2");</code>\n<code>   }</code>\n<code>   { System.out.print("3"); }</code>\n<code>}</code>\n<code>public class BlueCar extends Car {</code>\n<code>   { System.out.print("4"); }</code>\n<code>   public BlueCar() {</code>\n<code>      super("blue");</code>\n<code>      System.out.print("5");</code>\n<code>   }</code>\n<code>   public static void main(String[] gears) {</code>\n<code>      new BlueCar();</code>\n<code>   }</code>\n<code>}</code>',answers:["23451","12354","13245","The code does not compile."]},{title:"Fill in the blank: Overloaded and overridden methods always have____________ .",code:null,answers:["the same parameter list","different return types","the same method name","covariant return types"]},{title:"What is the output of the following application?",code:'<code>package sports;</code>\n<code>abstract class Ball {</code>\n<code>   protected final int size;</code>\n<code>   public Ball(int size) {</code>\n<code>      this.size = size;</code>\n<code>   }</code>\n<code>}</code>\n<code><span epub:type="pagebreak" id="Page_108"></span>interface Equipment {}</code>\n<code>public class SoccerBall extends Ball implements Equipment {</code>\n<code>   public SoccerBall() {</code>\n<code>      super(5);</code>\n<code>   }</code>\n<code>   public Ball get() { return this; }</code>\n<code>   public static void main(String[] passes) {</code>\n<code>      Equipment equipment = (Equipment)(Ball)new SoccerBall().get();</code>\n<code>      System.out.print(((SoccerBall)equipment).size);</code>\n<code>   }</code>\n<code>}</code>',answers:["5","The code does not compile due an invalid cast.","The code does not compile for a different reason.","The code compiles but throws a ClassCastException at runtime."]},{title:"Fill in the blanks: A class that defines an instance variable with the same name as a variable in the parent class is referred to as  ____________a variable, while a class that defines a static method with the same signature as a static method in a parent class is referred to as  ____________a method.",code:null,answers:["hiding, overriding","overriding, hiding","hiding, hiding","replacing, overriding"]},{title:"Which statement about the following class is correct?",code:"<code>package shapes;</code>\n<code>&nbsp;</code>\n<code>abstract class Parallelogram {</code>\n<code>   private int getEqualSides() {return 0;}</code>\n<code>}</code>\n<code>abstract class Rectangle extends Parallelogram {</code>\n<code>   public static int getEqualSides() {return 2;} // x1</code>\n<code>}</code>\n<code>public final class Square extends Rectangle {</code>\n<code>   public int getEqualSides() {return 4;} // x2</code>\n<code>   public static void main(String[] corners) {</code>\n<code>      final Square myFigure = new Square(); // x3</code>\n<code>      System.out.print(myFigure.getEqualSides());</code>\n<code>   }</code>\n<code>}</code>",answers:["The code does not compile due to line x1.","The code does not compile due to line x2.","The code does not compile due to line x3.","The code compiles and runs without issue."]},{title:"What is the output of the following application?",code:"<code>package flying;</code>\n<code>&nbsp;</code>\n<code>class Rotorcraft {</code>\n<code>   protected final int height = 5;</code>\n<code>   abstract int fly();</code>\n<code>}</code>\n<code>public class Helicopter extends Rotorcraft {</code>\n<code>   private int height = 10;</code>\n<code>   protected int fly() {</code>\n<code>      return super.height;</code>\n<code>   }</code>\n<code>   public static void main(String[] unused) {</code>\n<code>      Helicopter h = (Helicopter)new Rotorcraft();</code>\n<code>      System.out.print(h.fly());</code>\n<code>   }</code>\n<code>}</code>",answers:["5","10","The code does not compile.","The code compiles but produces a ClassCastException at runtime."]},{title:"Fill in the blanks: A class may be assigned to a(n) _____________ reference variable automatically but requires an explicit cast when assigned to a(n) _____________ reference variable.",code:null,answers:["subclass, outer class","superclass, subclass","subclass, superclass","abstract class, concrete class"]},{title:"Fill in the blank: A(n)  ____________is the first non-abstract subclass that is required to implement all of the inherited abstract methods.",code:null,answers:["abstract class","abstraction","concrete class","interface"]},{title:"How many compiler errors does the following code contain?",code:"<code>package animal;</code>\n<code>interface CanFly {</code>\n<code>   public void fly() {}</code>\n<code>}</code>\n<code>final class Bird {</code>\n<code>   public int fly(int speed) {}</code>\n<code>}</code>\n<code>public class Eagle extends Bird implements CanFly {</code>\n<code>   public void fly() {}</code>\n<code>}</code>",answers:["None","One","Two","Three"]},{title:"Which of the following is not an attribute common to both abstract classes and interfaces?",code:null,answers:["They both can contain static variables.","They both can contain default methods.","They both can contain static methods.","They both can contain abstract methods."]},{title:"What is the output of the following application?",code:"<code>package musical;</code>\n<code>interface SpeakDialogue { default int talk() { return 7; } }</code>\n<code>interface SingMonologue { default int talk() { return 5; } }</code>\n<code>public class Performance implements SpeakDialogue, SingMonologue {</code>\n<code>   public int talk(String... x) {</code>\n<code>      return x.length;</code>\n<code>   }</code>\n<code>   public static void main(String[] notes) {</code>\n<code>      System.out.print(new Performance().talk(notes));</code>\n<code>   }</code>\n<code>}</code>",answers:["7","5","The code does not compile.","The code compiles without issue, but the output cannot be determined until runtime."]},{title:"Which of the following is a virtual method?",code:null,answers:["protected instance methods","static methods","private instance methods","final instance methods"]},{title:"Fill in the blanks: An interface  ____________another interface, while a class  ____________another class.",code:null,answers:["implements, extends","extends, extends","implements, implements","extends, implements"]},{title:"What is the output of the following application?",code:"<code>class Math {</code>\n<code>   public final double secret = 2;</code>\n<code>}</code>\n<code>class ComplexMath extends Math {</code>\n<code>   public final double secret = 4;</code>\n<code>}</code>\n<code>public class InfiniteMath extends ComplexMath {</code>\n<code>   public final double secret = 8;</code>\n<code>   public static void main(String[] numbers) {</code>\n<code>      Math math = new InfiniteMath();</code>\n<code>      System.out.print(math.secret);</code>\n<code>   }</code>\n<code>}</code>",answers:["2","4","8","The code does not compile."]},{title:"Given the following method and the fact that FileNotFoundException is a subclass of IOException, which of the following method signatures is a valid override by a subclass?",code:"<code>protected void dance() throws FileNotFoundException {}</code>",answers:["void dance() throws IOException","public void dance() throws IOException","private void dance() throws FileNotFoundException","public final void dance()"]},{title:"Given the class definitions below, which value, when inserted into the blank line, does not allow the class to compile?",code:"<code>public class Canine {}</code>\n<code>public class Dog extends Canine {}</code>\n<code>public class Wolf extends Canine {}</code>\n<code>public final class Husky extends Dog {}</code>\n<code>public class Zoologist {</code>\n<code>   Canine animal;</code>\n<code>   public final void setAnimal(Dog animal) { this.animal = animal; }</code>\n<code>   public static void main(String[] furryFriends) {</code>\n<code>      new Zoologist().setAnimal(_____________);</code>\n<code>   }</code>\n<code>}</code>",answers:["new Husky()","new Dog()","new Wolf()","null"]},{title:"Which of the following modifiers cannot be applied to an interface method?",code:null,answers:["final","default","static","abstract"]},{title:"Which statement about the following application is true?",code:'<code>package party;</code>\n<code>&nbsp;</code>\n<code>abstract class House {</code>\n<code>   protected abstract Object getSpace();</code>\n<code>}</code>\n<code>abstract class Room extends House {</code>\n<code>   abstract Object getSpace(Object list);</code>\n<code>}</code>\n<code>abstract public class Ballroom extends House {</code>\n<code>   protected abstract Object getSpace();</code>\n<code>   public static void main(String[] squareFootage) {</code>\n<code>      System.out.print("Let\'s start the party!");</code>\n<code>   }</code>\n<code>}</code>',answers:["It compiles and at runtime prints Let's start the party!","It does not compile for one reason.","It does not compile for two reasons.","It does not compile for three reasons."]},{title:"Fill in the blanks:  ____________methods must have a different list of parameters, while  ____________methods must have the exact same return type.",code:null,answers:["Overloaded, overridden","Inherited, overridden","Overridden, overloaded","None of the above"]},{title:"Which of the following statements about no-argument constructors is correct?",code:null,answers:["If a parent class does not include a no-argument constructor, a child class cannot declare one.","If a parent class does not include a no-argument constructor (nor a default one inserted by the compiler), a child class must contain at least one constructor definition.","If a parent class contains a no-argument constructor, a child class must contain a  no-argument constructor.","If a parent class contains a no-argument constructor, a child class must contain at least one constructor."]},{title:"Fill in the blanks: The  ____________determines which attributes exist in  memory, while the  ____________determines which attributes are accessible by\xa0the caller.",code:null,answers:["reference type, signature","object type, superclass","reference type, object type","object type, reference type"]},{title:"Given that Integer and Long are subclasses of Number, what type can be used to fill in the\xa0blank in the class below to allow it to compile?",code:"<code>package orchestra;</code>\n<code>interface MusicCreator { public Number play(); }</code>\n<code>abstract class StringInstrument { public Long play() {return 3L;} }</code>\n<code>public class Violin extends StringInstrument implements MusicCreator {</code>\n<code>   public _____________ play() {</code>\n<code>      return 12;</code>\n<code>   }</code>\n<code>}</code>",answers:["Long","Integer","Long or Integer","Long or Number"]},{title:"Which of the following is the best reason for creating a default interface method?",code:null,answers:["Allow interface methods to be inherited.","Add backward compatibility to existing interfaces.","Give an interface the ability to create concrete methods.","Allow an interface to define a method at the class level."]},{title:"Given that EOFException is a subclass of IOException, what is the output of the following application?",code:"<code>package ai;</code>\n<code>import java.io.*;</code>\n<code>class Machine {</code>\n<code>   public boolean turnOn() throws EOFException {return true;}</code>\n<code>}</code>\n<code>public class Robot extends Machine {</code>\n<code>   public boolean turnOn() throws IOException {return false;}</code>\n<code>   public static void main(String[] doesNotCompute) throws Exception {</code>\n<code>      Machine m = new Robot();</code>\n<code>      System.out.print(m.turnOn());</code>\n<code>   }</code>\n<code>}</code>",answers:["true","false","The code does not compile.","The code compiles but produces an exception at runtime."]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t],ol:e.ol}});i[21].imageUrl="./images/image-oca-ch7-22.png",t.default=i},164:function(e,t,o){"use strict";o.r(t);var n=["D. A try block must include either a catch or finally block, or both. The think() method declares a try block but neither additional block. For this reason, the code does not compile, and Option D is the correct answer. The rest of the lines compile without issue, including k1.","B. The correct order of blocks is try, catch, and finally, making Option B the correct answer.","D. Option D is the correct model. The class RuntimeException extends Exception, and both Exception and Error extend Throwable. Finally, like all Java classes, they all inherit from Object. Notice that Error does not extend Exception, even though we often refer to these generally as exceptions.","A. While Exception and RuntimeException are commonly caught in Java applications, it is recommended Error not be caught. An Error often indicates a failure of the JVM which cannot be recovered from. For this reason, Option A is correct, and Options C and D are incorrect. Option B is not a class defined in the Java API; therefore, it is also incorrect.","D. The application does not compile because score is defined only within the try block. The other three places it is referenced, in the catch block, in the finally block, and outside the try-catch-finally block at the end, are not in scope for this variable and each does not compile. Therefore, the correct answer is Option D.","B. ClassCastException, ArrayIndexOutOfBoundsException, and IllegalArgumentException are unchecked exceptions and can be thrown at any time. IOException is a checked exception that must be handled or declared when used, making Option B the correct answer.","A. The throws keyword is used in method declarations, while the throw keyword is used to throw an exception to the surrounding process, making Option A the correct answer. The catch keyword is used to handle exceptions, not to create them or in the declaration of a method.","B. IOException is a subclass of Exception, so it must appear first in any related catch blocks. If Exception was to appear before IOException, then the IOException block would be considered unreachable code because any thrown IOException is already handled by the Exception catch block. For this reason, Option B is correct.","C. The application first enters the try block and outputs A. It then throws a RuntimeException, but the exception is not caught by the catch block since RuntimeException is not a subclass of ArrayIndexOutOfBoundsException (it is a superclass). Next, the finally block is called and C is output. Finally, the RuntimeException is thrown by the main() method and a stack trace is printed. For these reasons, Option C is correct.","C. The application does not compile, so Option D is incorrect. The openDrawbridge() method compiles without issue, so Options A and B are incorrect. The issue here is how the openDrawbridge() method is called from within the main() method on line p3. The openDrawbridge() method declares the checked exception, Exception, but the main() method from which it is called does not handle or declare the exception. In order for this code to compile, the main() method would have to have a try-catch statement around line p3 that properly handles the checked exception, or the main() would have to be updated to declare a compatible checked exception. For these reasons, line p3 does not compile, and Option C is the correct answer.","B. NullPointerException and ArithmeticException both extend RuntimeException, which are unchecked exceptions and not required to be handled or declared in the method in which they are thrown. On the other hand, Exception is a checked exception and must be handled or declared by the method in which it is thrown. Therefore, Option B is the correct answer.","A. The code compiles and runs without issues, so Options C and D are incorrect. The try block throws a ClassCastException. Since ClassCastException is not a subclass of ArrayIndexOutOfBoundsException, the first catch block is skipped. For the second catch block, ClassCastException is a subclass of Throwable, so that block is executed. Afterward, the finally block is executed and then control returns to the main() method with no exception being thrown. The result is that 1345 is printed, making Option A the correct answer.","C. A finally block can throw an exception, in which case not every line of the finally block would be executed. For this reason, Options A and D are incorrect. Option B is also incorrect The finally block is called regardless of whether or not the related catch block is executed. Option C is the correct answer. Unlike an if-then statement, which can take a single statement, a finally statement requires brackets {}.","C. The code does not compile because the catch blocks are used in the wrong order. Since IOException is a superclass of FileNotFoundException, the FileNotFoundException is considered unreachable code. For this reason, the code does not compile, and Option C is correct.","C. A try statement requires a catch or a finally block. Without one of them, the code will not compile; therefore, Option D is incorrect. A try statement can also be used with both a catch and finally block, making Option C the correct answer. Note that finalize is not a keyword, but a method inherited from java.lang.Object.","B. Option A is a true statement about exceptions and when they are often applied. Option B is the false statement and the correct answer. An application that throws an exception can choose to handle the exception and avoid termination. Option C is also a true statement. For example, a NullPointerException can be avoided on a null object by testing whether or not the object is null before attempting to use it. Option D is also a correct statement. Attempting to recover from unexpected problems is an important aspect of proper exception handling.","D. The code does not compile because the catch block uses parentheses () instead of brackets {}, making Option D the correct answer. Note that Boat does not extend Transport, so while the override on line j1 appears to be invalid since Exception is a broader checked exception than CapsizedException, that code compiles without issue. If the catch block was fixed, the code would output 4, making Option A the correct answer.","B. Overridden methods cannot throw new or broader checked exceptions than the one they inherit. Since Exception is a broader checked exception than PrintException, Option B is not allowed and is the correct choice. Alternatively, declaring narrower or the same checked exceptions or removing them entirely is allowed, making Options A and C incorrect. Since Option B is correct, Option D is incorrect.","D. All three of those classes belong to the java.lang package, so Option C seems like the correct answer. The Java compiler, though, includes java.lang by default, so no import statement is actually required to use those three classes, making Option D the correct answer.","C. The code does not compile because the catch block is missing a variable type and name, such as catch (Exception e) . Therefore, Option C is the correct answer. Both implementations of getSymbol() compile without issue, including the overridden method. A subclass can swallow a checked exception for a method declared in a parent class; it just cannot declare any new or broader checked exceptions.","B. Checked exceptions must be handled or declared or the program will not compile, while unchecked exceptions can be optionally handled. On the other hand, java.lang.Error should never be handled by the application because it often indicates an unrecoverable state in the JVM, such as running out of memory. For these reasons, Option B is the correct answer.","B. The application does not compile, so Option D is incorrect. The checked KnightAttackingException thrown in the try block is handled by the associated catch block. The ClassCastException is an unchecked exception, so it is not required to be handled or declared and line q1 compiles without issue. The finally block throws a checked CastleUnderSiegeException, which is required to be handled or declared by the method, but is not. There is no try-catch around line q2, and the method does not declare a compatible checked exception, only an unchecked exception. For this reason, line q2 does not compile, and Option B is the correct answer. Lastly, line q3 compiles without issue because the unchecked RuntimeException is not required to be handled or declared by the call in the main() method.","A. If an exception matches multiple catch blocks, the first one that it encounters will be the only one executed, making Option A correct, and Options B and C incorrect. Option D is also incorrect. It is possible to write two consecutive catch blocks that can catch the same exception, with the first type being a subclass of the second. In this scenario, an exception thrown of the first type would match both catch blocks, but only the first catch block would be executed, since it is the more specific match.","C. The code does not compile due to the call to compute() in the main() method. Even though the compute() method only throws an unchecked exception, its method declaration includes the Exception class, which is a checked exception. For this reason, the checked exception must be handled or declared in the main() method in which it is called. While there is a try-catch block in the main() method, it is only for the unchecked NullPointerException. Since Exception is not a subclass of NullPointerException, the checked Exception is not properly handled or declared and the code does not compile, making Option C the correct answer.","D. A NullPointerException can be thrown if the value of list is null. Likewise, an ArrayIndexOutOfBoundsException can be thrown if the value of list is an array with fewer than 10 elements. Finally, a ClassCastException can be thrown if list is assigned an object that is not of type Boolean[]. For example, the assignment list = (Boolean[]) new Object() will compile without issue but throws a ClassCastException at runtime. Therefore, the first three options are possible, making Option D the correct answer.","B. A StackOverflowError occurs when a program recurses too deeply into an infinite loop. It is considered an error because the JVM often runs out of memory and cannot recover. A NullPointerException occurs when an instance method or variable on a null reference is used. For these reasons, Option B is correct. A NoClassDefFoundError occurs when code available at compile time is not available at runtime. A ClassCastException occurs when an object is cast to an incompatible reference type. Finally, an IllegalArgumentException occurs when invalid parameters are sent to a method.","C. Checked exceptions are commonly used to force a caller to deal with an expected type of problem, such as the inability to write a file to the file system. Without dealing with all checked exceptions thrown by the method, the calling code does not compile, so Option A is a true statement. Option B is also a true statement. Declaring various different exceptions informs the caller of the potential types of problems the method can encounter. Option C is the correct answer. There may be no recourse in handling an exception other than to terminate the application. Finally, Option D is also a true statement because it gives the caller a chance to recover from an exception, such as writing file data to a backup location.","D. This code does not compile because the catch and finally blocks are in the wrong order, making Option D the correct answer. If the order was flipped, the output would be Finished!Joyce Hopper, making Option B correct.","A. A try statement is not required to have a finally block, but if it does, there can be at most one. Furthermore, a try statement can have any number of catch blocks or none at all. For these reasons, Option A is the correct answer. ","D. The code compiles without issue, so Option C is incorrect. The key here is noticing that count, an instance variable, is initialized with a value of 0. The getDuckies() method ends up computing 5/0, which leads to an unchecked ArithmeticException at runtime, making Option D the correct answer.","B. If both the catch and finally blocks throw an exception, the one from the finally block is propagated to the caller, with the one from the catch block being dropped, making Option B the correct answer. Note that Option C is incorrect due to the fact that only one exception can be thrown to the caller.","A. The application does not compile because the roar() method in the BigCat class uses throw instead of throws, making Option A the correct answer. Note that if the correct keyword was used, the code would compile without issues, and Option D would be correct. Also the override of roar() in the Lion class is valid, since the overridden method has a broader access modifier and does not declare any new or broader checked exceptions.","A. Although this code uses the RuntimeException and Exception classes, the question is about casting. Exception is not a subclass of RuntimeException, so the assignment on the second line throws a ClassCastException at runtime, making Option A correct.","C. All exceptions in Java inherit from Throwable, making Option C the correct answer. Note that Error and Exception extend Throwable, and RuntimeException extends Exception.","B. If both values are valid non-null String objects, then no exception will be thrown, with the statement in the finally block being executed first, before returning control to the main() method; therefore, the second statement is a possible output. If either value is null, then the toString() method will cause a NullPointerException to be thrown. In both cases, the finally block will execute first, printing Posted:, even if there is an exception. For this reason, the first statement is not a possible output, and Option B is correct.","A. ClassCastException is a subclass of RuntimeException, so it must appear first in any related catch blocks. If RuntimeException was to appear before ClassCastException, then the ClassCastException block would be considered unreachable code, since any thrown ClassCastException is already handled by the RuntimeException catch block. For this reason, Option A is correct.","C. Option A is incorrect. You should probably seek help if the computer is on fire! Option B is incorrect because code that does not compile cannot run and therefore cannot throw any exceptions. Option C is the best answer, since an IllegalArgumentException can be used to alert a caller of missing or invalid data. Option D is incorrect; finishing sooner is rarely considered a problem.","C. The code does not compile due to an invalid override of the operate() method. An overridden method must not throw any new or broader checked exceptions than the method it inherits. Even though RuntimeException is a subclass of Exception, Exception is considered a new checked exception, since RuntimeException is an unchecked exception. Therefore, the code does not compile, and Option C is correct.","D. A NullPointerException is an unchecked exception. While it can be handled by the surrounding method, either through a try-catch block or included in the method declaration, these are optional. For this reason, Option D is correct.","D. In this application, the throw RuntimeException(String) statement in the zipper() method does not include the new keyword. The new keyword is required to create the object being thrown, since RuntimeException(String) is a constructor. For this reason, the code does not compile, and Option D is correct. If the keyword new was inserted properly, then the try block would throw a CastClassException, which would be replaced with a RuntimeException to the calling method by the catch block. The catch block in the main() method would then be activated, and no output would be printed, making Option C correct.","C. For this question, notice that all the exceptions thrown or caught are unchecked exceptions. First, the ClassCastException is thrown in the try block and caught by the second catch block since it inherits from RuntimeException, not IllegalArgumentException. Next, a NullPointerException is thrown, but before it can be returned the finally block is executed and a RuntimeException replaces it. The application exits and the caller sees the RuntimeException in the stack trace, making Option C the correct answer. If the finally block did not throw any exceptions, then Option B would be the correct answer.","D. Trick question! Options A, B, and C are each invalid overrides of the method because the return type must be covariant with void. For this reason, Option D is the correct answer. If the return types were changed to be void, then Option A would be a valid override. Options B and C would still be incorrect, since overridden methods cannot throw broader checked exceptions than the inherited method.","D. The code does not compile because the catch block is missing a variable name, such as catch (Error e). Therefore, Option D is the correct answer. If a variable name was added, the application would produce a stack trace at runtime and Option C would be the correct answer. Because IllegalArgumentException does not inherit from Error, the catch block would be skipped and the exception sent to the main() method at runtime. Note that the declaration of RuntimeException by both methods is unnecessary since it is unchecked, although allowed by the compiler.","D. The openDrawbridge() is capable of throwing a variety of exceptions, including checked Exception and DragonException as well as an unchecked RuntimeException. All of these are handled by the fact that the method declares the checked Exception class in the method signature, which all the exceptions within the class inherit. For this reason, the openDrawbridge() method compiles without issue. The call to openDrawbridge() in the main() method also compiles without issue because the main() method declares Exception in its signature. For these reasons, the code compiles but a stack trace is printed at runtime, making Option D the correct answer. In case you are wondering, the caller would see RuntimeException: Or maybe this one in the stack trace at runtime, since the exception in the finally block replaces the one from the try block. Note that the exception in the catch block is never reached because the RuntimeException type declared in the catch block does not handle Exception.","C. Both IllegalArgumentException and ClassCastException inherit RuntimeException, but neither is a subclass of the other. For this reason, they can be listed in either order, making Option C the correct statement.","D. The class RuntimeException is not an interface and it cannot be implemented. For this reason, the Problem class does not compile, and Option D is the correct answer. Note that this is the only compilation problem in the application. If implements was changed to extends, the code would compile and Problem?Fixed! would be printed, making Option A the correct answer.","D. The question is designed to see how closely you pay attention to throw and throws! The try block uses the incorrect keyword, throws, to create an exception. For this reason, the code does not compile, and Option D is correct. If throws was changed to throw, then the code would compile without issue, and Option B would be correct.","D. A Java application tends to only throw an Error when the application has entered a final, unrecoverable state. Options A and C are incorrect. These types of errors are common and expected in most software applications, and should not cause the application to terminate. Option B uses the word temporarily, meaning the network connection will come back. In this case, a regular exception could be used to try to recover from this state. Option D is the correct answer because running out of memory is usually unrecoverable in Java.","C. While a catch block is permitted to include an embedded try-catch block, the issue here is that the variable name e is already used by the first catch block. In the second catch block, it is equivalent to declaring a variable e twice. For this reason, line z1 does not compile, and Option C is the correct answer. If a different variable name was used for either catch block, then the code would compile without issue, and Option A would be the correct answer.","B. The finally block of the snore() method throws a new checked exception on line x1, but there is no try-catch block around it to handle it, nor does the snore() method declare any checked exceptions. For these reasons, line x1 does not compile, and Option B is the correct answer. The rest of the lines of code compile without issue, even line x3 where a static method is being accessed using an instance reference. Note that the code inside the try block, if it ran, would produce an ArrayIndexOutOfBoundsException, which would be caught by the RuntimeException catch block, printing Awake!. What happens next would depend on how the finally block was corrected."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"What is the result of compiling and executing the following application?",code:"<code>package mind;</code>\n<code>public class Remember {</code>\n<code>   public static void think() throws Exception {  // k1</code>\n<code>      try {</code>\n<code>         throw new Exception();</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String... ideas) throws Exception {</code>\n<code>      think();</code>\n<code>   }</code>\n<code>}</code>",answers:["The code compiles and runs without printing anything.","The code compiles but a stack trace is printed at runtime.","The code does not compile because of line k1.","The code does not compile for another reason."]},{title:"Choose the answer that lists the keywords in the order that they would be used together.",code:null,answers:["catch, try, finally","try, catch, finally","finally, catch, try","try, finally, catch"]},{title:"Which of the following diagrams of java.lang classes shows the inheritance model properly?",code:null,answers:["1","2","3","4"]},{title:"Which of the following Throwable types is it recommended not to catch in a Java application?",code:null,answers:["Error","CheckedException","Exception","RuntimeException"]},{title:"What is the output of the following application?",code:"<code>package game;</code>\n<code>public class Baseball {</code>\n<code>   public static void main(String... teams) {</code>\n<code>      try {</code>\n<code>         int score = 1;</code>\n<code>         System.out.print(score++);</code>\n<code>      } catch (Throwable t) {</code>\n<code>         System.out.print(score++);</code>\n<code>      } finally {</code>\n<code>         System.out.print(score++);</code>\n<code>      }</code>\n<code>      System.out.print(score++);</code>\n<code>   }</code>\n<code>}</code>",answers:["123","124","12","None of the above"]},{title:"Which of the following is a checked exception?",code:null,answers:["ClassCastException","IOException","ArrayIndexOutOfBoundsException","IllegalArgumentException"]},{title:"Fill in the blanks: The  ____________keyword is used in method declarations, while the  ____________keyword is used to throw an exception to the  surrounding process.",code:null,answers:["throws, throw","catch, throw","throw, throws","throws, catch"]},{title:"If a try statement has catch blocks for both Exception and IOException, then which of the following statements is correct?",code:null,answers:["The catch block for Exception must appear before the catch block for IOException.","The catch block for IOException must appear before the catch block for Exception.","The catch blocks for these two exception types can be declared in any order.","A try statement cannot be declared with these two catch block types because they are incompatible."]},{title:"What is the output of the following application?",code:"<code>package game;</code>\n<code>public class Football {</code>\n<code><span epub:type=\"pagebreak\" id=\"Page_119\"></span>   public static void main(String officials[]) {</code>\n<code>      try {</code>\n<code>         System.out.print('A');</code>\n<code>         throw new RuntimeException(\"Out of bounds!\");</code>\n<code>      } catch (ArrayIndexOutOfBoundsException aioobe) {</code>\n<code>         System.out.print('B');</code>\n<code>         throw t;</code>\n<code>      } finally {</code>\n<code>         System.out.print('C');</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>",answers:["ABC","ABC, followed by a stack trace for a RuntimeException","AC, followed by a stack trace for a RuntimeException","None of the above"]},{title:"What is the result of compiling and running the following application?",code:'<code>package castles;</code>\n<code>public class Fortress {</code>\n<code>   public void openDrawbridge() throws Exception {  // p1</code>\n<code>      try {</code>\n<code>         throw new Exception("Circle");</code>\n<code>      } catch (Exception e) {</code>\n<code>         System.out.print("Opening!");</code>\n<code>      } finally {</code>\n<code>         System.out.print("Walls");  // p2</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] moat) {</code>\n<code>      new Fortress().openDrawbridge();  // p3</code>\n<code>   }</code>\n<code>}</code>',answers:["The code does not compile because of line p1.","The code does not compile because of line p2.","The code does not compile because of line p3.","The code compiles, but a stack trace is printed at runtime."]},{title:"Which of the following exception types must be handled or declared by the method in which they are thrown?",code:null,answers:["NullPointerException","Exception","RuntimeException","ArithmeticException"]},{title:"What is the output of the following application?",code:"<code>package game;</code>\n<code>public class BasketBall {</code>\n<code>   public static void main(String[] dribble) {</code>\n<code>      try {</code>\n<code>         System.out.print(1);</code>\n<code>         throw new ClassCastException();</code>\n<code>      } catch (ArrayIndexOutOfBoundsException ex) {</code>\n<code>         System.out.print(2);</code>\n<code>      } catch (Throwable ex) {</code>\n<code>         System.out.print(3);</code>\n<code>      } finally {</code>\n<code>         System.out.print(4);</code>\n<code>      }</code>\n<code>      System.out.print(5);</code>\n<code>   }</code>\n<code>}</code>",answers:["1345","1235","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which of the following statements about a finally block is true?",code:null,answers:["Every line of the finally block is guaranteed to be executed.","The finally block is executed only if the related catch block is also executed.","The finally statement requires brackets {}.","The finally block cannot throw an exception."]},{title:"Given that FileNotFoundException is a subclass of IOException, what is the output of the following application?",code:'<code>package office;</code>\n<code>import java.io.*;</code>\n<code>public class Printer {</code>\n<code>   public void print() {</code>\n<code>      try {</code>\n<code>         throw new FileNotFoundException();</code>\n<code>      } catch (IOException exception) {</code>\n<code>         System.out.print("Z");</code>\n<code>      } catch (FileNotFoundException enfe) {</code>\n<code>         System.out.print("X");</code>\n<code>      } finally {</code>\n<code>         System.out.print("Y");</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String... ink) {</code>\n<code>      new Printer().print();</code>\n<code>   }</code>\n<code>}</code>',answers:["XY","ZY","The code does not compile.","The code compiles but a stack trace is printed at runtime."]},{title:"Which keywords are required with a try statement?",code:null,answers:["I only","II only","I or III, or both","None of these statements are required with a try statement."],ol:["catch","finalize","finally"]},{title:"Which statement about the role of exceptions in Java is incorrect?",code:null,answers:["Exceptions are often used when things \u201cgo wrong\u201d or deviate from the expected path.","An application that throws an exception will terminate.","Some exceptions can be avoided programmatically.","An application that can properly handle its exception may recover from unexpected problems."]},{title:"What is the output of the following application?",code:"<code>package harbor;</code>\n<code>class CapsizedException extends Exception {}</code>\n<code>class Transport {</code>\n<code>   public int travel() throws CapsizedException { return 2; };</code>\n<code>}</code>\n<code>public class Boat {</code>\n<code>   public int travel() throws Exception { return 4; };  // j1</code>\n<code>   public static void main(String... distance) throws Exception{</code>\n<code>      try {</code>\n<code>         System.out.print(new Boat().travel());</code>\n<code>      } catch (Exception e) (</code>\n<code>         System.out.print(8);</code>\n<code>      )</code>\n<code>   }</code>\n<code>}</code>",answers:["4","8","The code does not compile due to line j1.","The code does not compile for another reason."]},{title:"Which of following method signatures would not be allowed in a class implementing the Printer interface?",code:"<code>class PrintException extends Exception {}</code>\n<code>class PaperPrintException extends PrintException {}</code>\n<code>&nbsp;</code>\n<code>public interface Printer {</code>\n<code>   abstract int printData() throws PrintException;</code>\n<code>}</code>",answers:["public int printData() throws PaperPrintException","public int printData() throws Exception","public int printData()","None of the above"]},{title:"Which import statement is required to be declared in order to use the Exception, RuntimeException, and Throwable classes in an application?",code:null,answers:["import java.exception.*;","import java.util.exception.*;","import java.lang.*;","None of the above"]},{title:"Which statement about the following classes is correct?",code:'<code>class GasException extends Exception {}</code>\n<code>class Element {</code>\n<code>   public int getSymbol() throws GasException { return -1; }  // g1</code>\n<code>}</code>\n<code>public class Oxygen extends Element {</code>\n<code>   public int getSymbol() { return 8; }  // g2</code>\n<code>   public void printData() {</code>\n<code>      try {</code>\n<code>         System.out.print(getSymbol());</code>\n<code>      } catch {  // g3</code>\n<code>         System.out.print("Unable to read data");</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["The code does not compile because of line g1.","The code does not compile because of line g2.","The code does not compile because of line g3.","None of the above"]},{title:"Fill in the blanks: A program must handle or declare  ____________but should never handle ____________.",code:null,answers:["java.lang.Error, unchecked exceptions","checked exceptions, java.lang.Error","java.lang.Throwable, java.lang.Error","unchecked exceptions, java.lang.Exception"]},{title:"What is the result of compiling and running the following application?",code:'<code>package castles;</code>\n<code>class CastleUnderSiegeException extends Exception {}</code>\n<code>class KnightAttackingException extends CastleUnderSiegeException {}</code>\n<code>public class Citadel {</code>\n<code>   public void openDrawbridge() throws RuntimeException {  // q1</code>\n<code><span epub:type="pagebreak" id="Page_123"></span>      try {</code>\n<code>         throw new KnightAttackingException();</code>\n<code>      } catch (Exception e) {</code>\n<code>         throw new ClassCastException();</code>\n<code>      } finally {</code>\n<code>         throw new CastleUnderSiegeException();  // q2</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] moat) {</code>\n<code>      new Citadel().openDrawbridge();  // q3</code>\n<code>   }</code>\n<code>}</code>',answers:["The code does not compile because of line q1.","The code does not compile because of line q2.","The code does not compile because of line q3.","The code compiles, but a stack trace is printed at runtime."]},{title:"If an exception matches two or more catch blocks, which catch block is executed?",code:null,answers:["The first one that matches is executed.","The last one that matches is executed.","All matched blocks are executed.","It is not possible to write code like this."]},{title:"What is the output of the following application?",code:'<code>package system;</code>\n<code>public class Computer {</code>\n<code>   public void compute() throws Exception {</code>\n<code>      throw new RuntimeException("Error processing request");</code>\n<code>   }</code>\n<code>   public static void main(String[] bits) {</code>\n<code>      try {</code>\n<code>         new Computer().compute();</code>\n<code>         System.out.print("Ping");</code>\n<code>      } catch (NullPointerException e) {</code>\n<code>         System.out.print("Pong");</code>\n<code>         throw e;</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["Ping","Pong","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"In the following application, the value of list has been omitted. Assuming the code compiles without issue, which one of the following is not a possible output of executing this class?",code:"<code>package checkboard;</code>\n<code>&nbsp;</code>\n<code>public class Attendance {</code>\n<code>   private Boolean[] list = // value omitted</code>\n<code>   public int printTodaysCount() {</code>\n<code>      int count=0;</code>\n<code>      for(int i=0; i&lt;10; i++) {</code>\n<code>         if(list[i]) ++count;</code>\n<code>      }</code>\n<code>      return count;</code>\n<code>   }</code>\n<code>   public static void main(String[] roster) {</code>\n<code>      new Attendance().printTodaysCount();</code>\n<code>   }</code>\n<code>}</code>",answers:["A stack trace for NullPointerException is printed.","A stack trace for ArrayIndexOutOfBoundsException is printed.","A stack trace for ClassCastException is printed.","None of the above"]},{title:"Fill in the blanks: A  ____________occurs when a program recurses too deeply into an infinite loop, while a(n)  ____________occurs when a reference to a nonexistent object is acted upon.",code:null,answers:["NoClassDefFoundError, StackOverflowError","StackOverflowError, NullPointerException","ClassCastException, IllegalArgumentException","StackOverflowError, IllegalArgumentException"]},{title:"Which of the following is not a reason to add checked exceptions to a method signature?",code:null,answers:["To force a caller to handle or declare its exceptions","To notify the caller of potential types of problems","To ensure that exceptions never cause the application to terminate","To give the caller a chance to recover from a problem"]},{title:"What is the output of the following application?",code:'<code>package peculiar;</code>\n<code>public class Stranger {</code>\n<code>   public static String getFullName(String firstName, String lastName) {</code>\n<code>      try {</code>\n<code>         return firstName.toString() + " " + lastName.toString();</code>\n<code>      } finally {</code>\n<code>         System.out.print("Finished!");</code>\n<code>      } catch (NullPointerException npe) {</code>\n<code>         System.out.print("Problem?");</code>\n<code>      }</code>\n<code>      return null;</code>\n<code>   }</code>\n<code>   public static void main(String[] things) {</code>\n<code>      System.out.print(getFullName("Joyce","Hopper"));</code>\n<code>   }</code>\n<code>}</code>',answers:["Joyce Hopper","Finished!Joyce Hopper","Problem?Finished!null","None of the above"]},{title:"Fill in the blanks: A try statement has  ____________finally block(s) and  ____________catch blocks.",code:null,answers:["zero or one, zero or more","one, one or more","zero or one, zero or one","one or more, zero or one"]},{title:"What is the output of the following application?",code:'<code>package pond;</code>\n<code>abstract class Duck {</code>\n<code>   protected int count;</code>\n<code>   public abstract int getDuckies();</code>\n<code>}</code>\n<code>public class Ducklings extends Duck {</code>\n<code>   private int age;</code>\n<code>   public Ducklings(int age) { this.age = age; }</code>\n<code>   public int getDuckies() { return this.age/count; }</code>\n<code>   public static void main(String[] pondInfo) {</code>\n<code><span epub:type="pagebreak" id="Page_126"></span>      Duck itQuacks = new Ducklings(5);</code>\n<code>      System.out.print(itQuacks.getDuckies());</code>\n<code>   }</code>\n<code>}</code>',answers:["0","5","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Given a try statement, if both the catch block and the finally block each throw an exception, what does the caller see?",code:null,answers:["The exception from the catch block","The exception from the finally block","Both the exception from the catch block and the exception from the finally block","None of the above"]},{title:"What is the output of the following application?",code:'<code>package zoo;</code>\n<code>class BigCat {</code>\n<code>   void roar(int level) throw RuntimeException {  // m1</code>\n<code>      if(level&lt;3) throw new IllegalArgumentException("Incomplete");</code>\n<code>      System.out.print("Roar!");</code>\n<code>   }</code>\n<code>}</code>\n<code>public class Lion extends BigCat {</code>\n<code>   public void roar() {  // m2</code>\n<code>      System.out.print("Roar!!!");</code>\n<code>   }</code>\n<code>&nbsp;</code>\n<code>   public static void main(String[] cubs) {</code>\n<code>      final BigCat kitty = new Lion();  // m3</code>\n<code>      kitty.roar(2);</code>\n<code>   }</code>\n<code>}</code>',answers:["The code does not compile because of line m1.","The code does not compile because of line m2.","The code does not compile because of line m3.","The code compiles but a stack trace is printed at runtime."]},{title:"Given the following code snippet, which specific exception will be thrown?",code:"<code>final Object exception = new Exception();</code>\n<code>final Exception data = (RuntimeException)exception;</code>\n<code>System.out.print(data);</code>",answers:["ClassCastException","RuntimeException","NullPointerException","None of the above"]},{title:"Which of the following classes will handle all types in a catch block?",code:null,answers:["Exception","Error","Throwable","RuntimeException"]},{title:"In the following application, the values of street and city have been omitted. Which one of the following is a possible output of executing this class?",code:'<code>package registration;</code>\n<code>public class Address {</code>\n<code>   public String getAddress(String street, String city) {</code>\n<code>      try {</code>\n<code>         return street.toString() + " : " + city.toString();</code>\n<code>      } finally {</code>\n<code>         System.out.print("Posted:");</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] form) {</code>\n<code>      String street = // value omitted</code>\n<code>      String city = // value omitted</code>\n<code>      System.out.print(new Address().getAddress(street,city));</code>\n<code>   }</code>\n<code>}</code>',answers:["I only","II only","I and II","None of the above"],ol:["350 5th Ave - New York","Posted:350 5th Ave - New York"]},{title:"If a try statement has catch blocks for both ClassCastException and RuntimeException, then which of the following statements is correct?",code:null,answers:["The catch block for ClassCastException must appear before the catch block for RuntimeException.","The catch block for RuntimeException must appear before the catch block for ClassCastException.","The catch blocks for these two exception types can be declared in any order.","A try statement cannot be declared with these two catch block types because they are incompatible."]},{title:"Which of the following is the best scenario to use an exception?",code:null,answers:["The computer caught fire.","The code does not compile.","A caller passes invalid data to a method.","A method finishes sooner than expected."]},{title:"What is the output of the following application?",code:'<code>package body;</code>\n<code>class Organ {</code>\n<code>   public void operate() throws RuntimeException {</code>\n<code>      throw new RuntimeException("Not supported");</code>\n<code>   }</code>\n<code>}</code>\n<code>public class Heart extends Organ {</code>\n<code>   public void operate() throws Exception {</code>\n<code>      System.out.print("beat");</code>\n<code>   }</code>\n<code>   public static void main(String... cholesterol) throws Exception {</code>\n<code>      try {</code>\n<code>         new Heart().operate();</code>\n<code>      } finally {</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["beat","Not supported","The code does not compile.","The code compiles but a stack trace is printed at runtime."]},{title:"Which statement about the following exception statement is correct?",code:"<code>throw new NullPointerException();</code>",answers:["The code where this is called must include a try-catch block that handles this exception.","The method where this is called must declare a compatible exception.","This exception cannot be handled.","This exception can be handled with a try-catch block or ignored altogether by the surrounding method."]},{title:"What is the output of the following application?",code:'<code>package clothing;</code>\n<code>public class Coat {</code>\n<code>   public Long zipper() throws Exception {</code>\n<code>      try {</code>\n<code>         String checkZipper = (String)new Object();</code>\n<code>      } catch (Exception e) {</code>\n<code>         throw RuntimeException("Broken!");</code>\n<code>      }</code>\n<code>      return null;</code>\n<code>   }</code>\n<code>   public static void main(String... warmth) {</code>\n<code>      try {</code>\n<code>         new Coat().zipper();</code>\n<code>         System.out.print("Finished!");</code>\n<code>      } catch (Throwable t) {}</code>\n<code>   }</code>\n<code>}</code>',answers:["Finished!","Finished!, followed by a stack trace","The application does not produce any output at runtime.","The code does not compile."]},{title:"Given the following application, which type of exception will be printed in the stack trace at runtime?",code:'<code>package carnival;</code>\n<code>public class WhackAnException {</code>\n<code>   public static void main(String... hammer) {</code>\n<code>      try {</code>\n<code>         throw new ClassCastException();</code>\n<code><span epub:type="pagebreak" id="Page_130"></span>      } catch (IllegalArgumentException e) {</code>\n<code>         throw new IllegalArgumentException();</code>\n<code>      } catch (RuntimeException e) {</code>\n<code>         throw new NullPointerException();</code>\n<code>      } finally {</code>\n<code>         throw new RuntimeException();</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["IllegalArgumentException","NullPointerException","RuntimeException","The code does not compile."]},{title:"Which of these method signatures is allowed in a class implementing the Outfielder interface?",code:"<code>class OutOfBoundsException extends BadCatchException {}</code>\n<code>class BadCatchException extends Exception {}</code>\n<code>&nbsp;</code>\n<code>public interface Outfielder {</code>\n<code>   public void catchBall() throws OutOfBoundsException;</code>\n<code>}</code>",answers:["public int catchBall() throws OutOfBoundsException","public int catchBall() throws BadCatchException","public int catchBall() throws Exception","None of the above"]},{title:"What is the output of the following application?",code:'<code>package city;</code>\n<code>public class Street {</code>\n<code>   public static void dancing() throws RuntimeException {</code>\n<code>      try {</code>\n<code>         throw new IllegalArgumentException();</code>\n<code>      } catch (Error) {</code>\n<code>         System.out.print("Unable!");</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String... count) throws RuntimeException {</code>\n<code>      dancing();</code>\n<code>   }</code>\n<code>}</code>',answers:["Unable!","The application does not produce any output.","The application compiles but produces a stack trace at runtime.","The code does not compile."]},{title:"What is the result of compiling and running the following application?",code:'<code>package castles;</code>\n<code>class DragonException extends Exception {}</code>\n<code>public class Lair {</code>\n<code>   public void openDrawbridge() throws Exception {  // r1</code>\n<code>      try {</code>\n<code>         throw new Exception("This Exception");</code>\n<code>      } catch (RuntimeException e) {</code>\n<code>         throw new DragonException();  // r2</code>\n<code>      } finally {</code>\n<code>         throw new RuntimeException("Or maybe this one");</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] moat) throws Exception {</code>\n<code>      new Lair().openDrawbridge();  // r3</code>\n<code>   }</code>\n<code>}</code>',answers:["The code does not compile because of line r1.","The code does not compile because of line r2.","The code does not compile because of line r3.","The code compiles, but a stack trace is printed at runtime."]},{title:"If a try statement has catch blocks for both IllegalArgumentException and ClassCastException, then which of the following statements is correct?",code:null,answers:["The catch block for IllegalArgumentException must appear before the catch block for ClassCastException.","The catch block for ClassCastException must appear before the catch block for IllegalArgumentException.","The catch blocks for these two exception types can be declared in any order.","A try statement cannot be declared with these two catch block types because they are incompatible."]},{title:"What is the output of the following application?",code:'<code>package broken;</code>\n<code>class Problem implements RuntimeException {}</code>\n<code>public class BiggerProblem extends Problem {</code>\n<code>   public static void main(String uhOh[]) {</code>\n<code>      try {</code>\n<code>         throw new BiggerProblem();</code>\n<code>      } catch (BiggerProblem re) {</code>\n<code>         System.out.print("Problem?");</code>\n<code>      } catch (Problem e) {</code>\n<code>         System.out.print("Handled");</code>\n<code>      } finally {</code>\n<code>         System.out.print("Fixed!");</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["Problem?Fixed!","Handled.Fixed!","Problem?Handled.Fixed!","The code does not compile."]},{title:"What is the output of the following application?",code:'<code>package lighting;</code>\n<code>interface Source {</code>\n<code>   void flipSwitch() throws Exception;</code>\n<code>}</code>\n<code>public class LightBulb implements Source {</code>\n<code>   public void flipSwitch() {</code>\n<code>      try {</code>\n<code>         throws new RuntimeException("Circuit Break!");</code>\n<code>      } finally {</code>\n<code>         System.out.print("Flipped!");</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String... electricity) throws Throwable {</code>\n<code>      final Source bulb = new LightBulb();</code>\n<code>      bulb.flipSwitch();</code>\n<code>   }</code>\n<code>}</code>',answers:["A stack trace for a RuntimeException","Flipped!, followed by a stack trace for a RuntimeException","The code does not compile because flipSwitch() is an invalid method override.","The code does not compile for another reason."]},{title:"Given an application that hosts a website, which of the following would most likely result in a java.lang.Error being thrown?",code:null,answers:["Two users try to register an account at the same time.","The application temporarily loses connection to the network.","A user enters their password incorrectly.","The application runs out of memory."]},{title:"Given that FileNotFoundException is a subclass of IOException, what is the output of the following application?",code:'<code>package storage;</code>\n<code>import java.io.*;</code>\n<code>public class Backup {</code>\n<code>   public void performBackup() {</code>\n<code>      try {</code>\n<code>         throw new IOException("Disk not found");</code>\n<code>      } catch (Exception e) {</code>\n<code>         try {</code>\n<code>            throw new FileNotFoundException("File not found");</code>\n<code>         } catch (FileNotFoundException e) {  // z1</code>\n<code>            System.out.print("Failed");</code>\n<code>         }</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String... files) {</code>\n<code>      new Backup().performBackup();  // z2</code>\n<code>   }</code>\n<code>}</code>',answers:["Failed","The application compiles but a stack trace is printed at runtime.","The code does not compile because of line z1.","The code does not compile because of line z2."]},{title:"What is the output of the following application?",code:'<code>package bed;</code>\n<code>public class Sleep {</code>\n<code>   public static void snore() {</code>\n<code>      try {</code>\n<code>         String sheep[] = new String[3];</code>\n<code>         System.out.print(sheep[3]);</code>\n<code>      } catch (RuntimeException e) {</code>\n<code>         System.out.print("Awake!");</code>\n<code>      } finally {</code>\n<code>         throw new Exception();  // x1</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String... sheep) {  // x2</code>\n<code>      new Sleep().snore();  // x3</code>\n<code>   }</code>\n<code>}</code>',answers:["Awake!, followed by a stack trace","The code does not compile because of line x1.","The code does not compile because of line x2.","The code does not compile because of line x3."]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t],ol:e.ol}});i[2].imageUrl="./images/image-oca-ch8-3.png",t.default=i},165:function(e,t,o){"use strict";o.r(t);var n=["C. Option A is incorrect because StringBuilder does not support multiple threads. In fact, threads aren\u2019t even covered on the OCA, which should be your clue that this answer is wrong! You don\u2019t need to know this for the exam, but StringBuffer supports multiple threads. Option B is incorrect because == compares references, not values. Option D is incorrect because both String and StringBuilder support languages and encodings. Option C is correct and the primary reason to use StringBuilder. String often creates a new object each time you call certain methods on the object like concat(). StringBuilder optimizes operations like append() because it is mutable.","D. A String can be created using a literal rather than calling a constructor directly, making Option A incorrect. A string pool exists for String reuse, making Option B incorrect. A String is final and immutable, making Option C incorrect and Option D correct.","D. This question is testing whether you understand how method chaining works. Option A creates an empty StringBuilder and then adds the five characters in clown to it. Option B simply creates the clown when calling the constructor. Finally, Option C creates the same value, just in two parts. Therefore, Option D is correct.","B. Since StringBuilder is mutable, each call to append adds to the value. When calling print, toString() is automatically called and 333 806 1601 is output. Therefore, Option B is correct.","B. List is an interface and not a class. It cannot be instantiated. While Object is a concrete class, it does not implement the List interface so it cannot be assigned to frisbees. Note that if you were to add an explicit cast, it would compile and throw an exception at runtime. Of the three options, only ArrayList can fill in the blank, so Option B is correct.","C. An ArrayList does not automatically sort the elements. It simply remembers them in order. Since Java uses zero-based indexes, Option C is correct.","C. Calling the constructor and then insert() is an example of method chaining. However, the sb.length() call is a problem. The sb reference doesn\u2019t exist until after the chained calls complete. Just because it happens to be on a separate line doesn\u2019t change when the reference is created. Since the code does not compile, Option C is correct.","A. While the ArrayList is declared with an initial capacity of one element, it is free to expand as more elements are added. Each of the three calls to the add() method adds an element to the end of the ArrayList. The remove() method call deletes the element at index 2, which is Art. Therefore, Option A is correct.","C. On line 12, the value of the StringBuilder is 12. On line 13, it becomes 123. Since StringBuilder is mutable, storing the result in the same reference is redundant. Then on line 14, the value is reversed, giving us 321 and making Option C correct.","D. Option A is incorrect as it describes autoboxing. Options B and C are not possible in Java. Option D is correct as it describes lambdas. Lambdas use deferred execution and can be run elsewhere in the codebase.","D. A StringBuilder is mutable, so the length is two after line 6 completes. The StringBuilder methods return a reference to the same object so you can chain method calls. Therefore, line and anotherLine refer to the same object. This means that line 7 prints true. Then on line 9, both references point to the same object of length 2, and Option D is correct.","D. The add() and get() methods are available on ArrayList. However, ArrayList uses size rather than length to get the number of elements. Therefore, Option D is correct. If length was changed to size, Option B would compile if put in the blank. Option A still wouldn\u2019t compile in the blank because a cast would be needed to store the value in str.","D. Option A is tricky, but incorrect. While a lambda can have zero parameters, a Predicate cannot. A Predicate is defined as a type mapping to a boolean. Option B is clearly incorrect as -> separates the parts of a lambda. Options C and D are similar. Option C is incorrect because return is only allowed when the brackets are present. Option D is correct.","A. Lines 20\u201322 create an ArrayList with two elements. Line 23 replaces the second one with a new value. Now chars is [a, c]. Then line 24 removes the first element, making it just [c]. Option A is correct because there is only one element, but it is not the value b.","D. Trick question. There is no reverse method on the String class. There is one on the StringBuilder class. Therefore, the code does not compile, and Option D is correct.","A. When creating a lambda with only one parameter, there are a few variants. The pred1 approach shows the shortest way, where the type is omitted and the parentheses are omitted. The pred2 approach is similar except it includes the parentheses. Both are legal. The pred4 approach is the long way with both the parentheses and type specified. The only one that doesn\u2019t compile is pred3. The parentheses are required if including the type.","A. This is a correct example of code that uses a lambda. The interface has a single abstract method. The lambda correctly takes one double parameter and returns a boolean. This matches the interface. The lambda syntax is correct. Since 45 is greater than 5, Option A is correct.","A. Since String is immutable, each call to concat() returns a new object with the new value. However, that return value is ignored and the teams variable never changes in value. Therefore it stays as 694, and Option A is correct.","A. The ArrayList class is in the java.util package, making I correct. The LocalDate class is in the java.time package, making II incorrect. The String class is in the java.lang package, which means you can use it without typing an import, making III incorrect. Therefore, Option A is correct.","C. Option A is straightforward and outputs radical robots. Option B does the same in a convoluted manner. First Option B removes all the characters after the first one. It doesn\u2019t matter that there aren\u2019t actually 100 characters to delete. Then it appends obots to the end, making the builder contain robots. Finally, it inserts the remainder of the string immediately after the first index. Try drawing the flow if this is hard to envision. Option D also creates the same value by inserting robots immediately after the end of the StringBuilder. Option C is close, but it has an off-by-one error. It inserts robots after the letter l rather than after the space. This results in the value radicalrobots followed by a space. Option C is different than the others and the correct answer.","A. Since we are creating the list from an array, it is a fixed size. We are allowed to change elements. At the end of this code, museums is [Art, Science]. Therefore, it contains Art, and Option A is correct.",'D. Options A and B are not true if the String is "deabc". Option C is not true if the String is "abcde". Option D is true in all cases.',"D. Line 25 does not compile. On an ArrayList, the method to get the number of elements is size. The length() method is used for a String or StringBuilder.","B. The toString() method call doesn\u2019t help in narrowing things down as all Java objects have that method available. The other two methods are more helpful. String is the only type of these three to have a startsWith() method, making Option B correct. String also has the replace() method declared here. If you memorized the whole API, you might know that StringBuilder also has a replace() method, but it requires three parameters instead of two. Please don\u2019t memorize the API in that level of detail. We included what you need to know in our study guide. If you do have this outside knowledge, be careful not to read into the questions!","B. The <> is known as the diamond operator. Here, it works as a shortcut to avoid repeating the generic type twice for the same declaration. On the right side of the expression, this is a handy shortcut. Java still needs the type on the left side so there is something to infer. In the figure, position P is the left side and position Q is the right side. Therefore, Option B is correct.","D. The type in the lambda must match the generic declared on the Predicate. In this case, that is String. Therefore, Options A and B are incorrect. While Option C is of the correct type, it uses the variable s, which is already in use from the main() method parameter. Therefore, none of these are correct, and Option D is the answer.","A. A String is immutable so a different object is returned on line 6. The object anotherLine points to is of length 2 after line 6 completes. However, the original line reference still points to an object of length 1. Therefore, Option A is correct.","C. While it is common for a Predicate to have a generic type, it is not required. However, it is treated like a Predicate of type Object if the generic type is missing. Since startsWith() does not exist on Object, the first line does not compile, and Option C is correct.","B. LocalDate only includes the date portion and not the time portion. There is no class named LocalTimeStamp. The other two, LocalDateTime and LocalTime, both include the time elements, making Option B correct.","D. Line 4 creates a String of length 5. Since String is immutable, line 5 creates a new String with the value 1 and assigns it to builder. Remember that indexes in Java begin with 0, so the substring() method is taking the values from the fifth element through the end. Since the first element is the last element, there\u2019s only one character in there. Then line 6 tries to retrieve the second indexed element. Since there is only one element, this gives a StringIndexOutOfBoundsException, and Option D is correct.","D. When you\u2019re using brackets, both the return keyword and semicolon are needed for the lambda to compile, making Option D correct.","B. Java 8 date and time classes are immutable. The plusDays method returns a LocalDate object presenting Christmas Eve (December 24th). However, this return value is ignored. The xmas variable still represents the original value, so Option B is correct.","A. Line 3 creates an empty StringBuilder. Line 4 adds three characters to it. Line 5 removes the first character, resulting in ed. Line 6 deletes the characters starting at position 1 and ending right before position 2, which removes the character at index 1, which is d. The only character left is e, so Option A is correct.","B. While it is common for a Predicate to have a generic type, it is not required. When the generic is omitted, it is treated like a Predicate of type Object. Since the equals() method exists on Object, this is fine. Option B is correct because the Predicate tests as false.","C. In Java, most things use zero-based indexes, including arrays and a String. Months are an exception to this convention starting Java 8. This makes the answer either Option C or D. However, LocalTime does not contain date fields, so it has to be Option C.","C. Predicate is an interface with one method. The method signature is boolean test(T t). Option C is the answer because the method accepts one parameter rather than two.","B. Be careful here. The Period class uses a static helper method to return the period. It does not chain method calls, so period1 only represents three days. Since three days is less than 10 days, period2 is larger, and Option B is correct.","B. The code starts by correctly creating a date representing January 1, 2017, and a period representing one day. It then explicitly defines the format as month followed by day followed by year. Finally, the code subtracts a day, giving us the formatted version of December 31, 2016.",'C. The trim() method returns a String with all leading and trailing white space removed. In this question, that\u2019s the seven-character String: ":) - (:". Options A and B are incorrect because they do not remove the first blank space in happy. Option D is incorrect because it does not remove the last character in happy. Therefore, Option C is correct.',"C. The Period class creates immutable objects and is usually used to add/subtract from a LocalDate or LocalDateTime object. It allows creating date, week, month, or year periods. Since it cannot be used for time, Option C is the answer.","D. Line 4 creates a StringBuilder of length 5. Pay attention to the substring() method StringBuilder. It returns a String with the value 321. It does not change the StringBuilder itself. Then line 6 is retrieving the second indexed element from that unchanged value, which is 4. Therefore, Option D is correct.","B. This one is tricky. There are two remove() methods available on ArrayList. One removes an element by index and takes an int parameter. The other removes an element by value. Due to the generics, it takes an Integer parameter in this example. Since the int primitive is a better match, the element with index 2 is removed, which is the value of 1. Therefore, Option B is correct.","C. ArrayList has a size() method rather than a length() method, making Option A incorrect. The charAt() and length() methods are declared on both String and StringBuilder. However, the insert() method is only declared on a StringBuilder and not a String. Therefore, Option C is correct.","C. The minusNanos and plusNanos are the smallest units available, making Option C correct. Option D is incorrect because LocalTime is not that granular. Note that while you can add milliseconds by adding many nanoseconds, there isn\u2019t a method for it. A millisecond is also larger than a nanosecond. Finally, don\u2019t be tricked by the fact that LocalTime is immutable. You can still add time; it just gets returned as a different object.","D. When creating a formatter object, remember that MM represents month while mm represents minute. Since there are not minutes defined on a LocalDate object, the code throws an UnsupportedTemporalTypeException. You don\u2019t need to know the name of the exception, but you do need to know that an exception is thrown.","D. There are two signatures for the replace() method. One takes two char parameters. The other signature takes a CharSequence. Both String and StringBuilder implement this interface. This makes all three alternatives correct, and Option D is correct.","C. Pay attention to the data types. The print() method is looping through a list of String objects. However, the Predicate expects an Integer. Since these don\u2019t match, the if statement does not compile.","D. Line 12 creates an empty ArrayList. While it isn\u2019t recommended to use generics on only the left side of the assignment operator, this is allowed. It just gives a warning. Lines 13 and 14 add two elements. Line 15 resets to an empty ArrayList. Line 16 adds an element, so now we have an ArrayList of size 1. Line 17 attempts to remove the element at index 1. Since Java uses zero-based indexes, there isn\u2019t an element there and the code throws an IndexOutOfBoundsException.","C. The declaration of witch is incorrect. It tries to store a char into a String variable reference. This does not compile, making Option C correct. If this was fixed, the answer would be Option B.","C. The Java 8 date and time classes are immutable. This means they do not contain setter methods and the code does not compile."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"What is the best reason for using StringBuilder instead of String?",code:null,answers:["StringBuilder adds support for multiple threads.","StringBuilder can use == to compare values.","StringBuilder saves memory by reducing the number of objects created.","StringBuilder supports different languages and encodings."]},{title:"What is not true about a String?",code:null,answers:["It can be created without coding a call to a constructor.","It can be reused via the string pool.","It is final.","It is mutable."]},{title:"Which of the following creates a StringBuilder with a different value than the other options?",code:null,answers:['new StringBuilder().append("clown")','new StringBuilder("clown")','new StringBuilder("cl").insert(2, "own")',"All of them create the same value."]},{title:"What is the output of the following?",code:'<code>StringBuilder teams = new StringBuilder("333");</code>\n<code>teams.append(" 806");</code>\n<code>teams.append(" 1601");</code>\n<code>System.out.print(teams);</code>',answers:["333","333 806 1601","The code compiles but outputs something else.","The code does not compile."]},{title:"How many of the types ArrayList, List, and Object can fill in the blank to produce code that compiles?",code:"<code>List frisbees = new  ____________();</code>",answers:["None","One","Two","Three"]},{title:"What is the output of the following?",code:'<code>List&lt;String&gt; tools = new ArrayList&lt;&gt;();</code>\n<code>tools.add("hammer");</code>\n<code>tools.add("nail");</code>\n<code>tools.add("hex key");</code>\n<code>System.out.println(tools.get(1));</code>',answers:["hammer","hex key","nail","None of the above"]},{title:"What is the result of the following code?",code:'<code>StringBuilder sb = new StringBuilder("radical")</code>\n<code>   .insert(sb.length(), "robots");</code>\n<code>System.out.println(sb);</code>',answers:["radicarobots","radicalrobots","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What is the output of the following?",code:'<code>List&lt;String&gt; museums = new ArrayList&lt;&gt;(1);</code>\n<code>museums.add("Natural History");</code>\n<code>museums.add("Science");</code>\n<code>museums.add("Art");</code>\n<code>museums.remove(2);</code>\n<code>System.out.println(museums);</code>',answers:["[Natural History, Science]","[Natural History, Art, Science]","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What is the output of the following?",code:'<code>12:  StringBuilder b = new StringBuilder("12");</code>\n<code>13:  b = b.append("3");</code>\n<code>14:  b.reverse();</code>\n<code>15:  System.out.println(b.toString());</code>',answers:["12","123","321","The code does not compile."]},{title:"What is the main benefit of a lambda expression?",code:null,answers:["It allows you to convert a primitive to a wrapper class.","It allows you to change the bytecode while the application is running.","It allows you to inherit from multiple classes.","It allows you to write code that has the execution deferred."]},{title:"What is the output of the following?",code:'<code>5:  StringBuilder line = new StringBuilder("-");</code>\n<code>6:  StringBuilder anotherLine = line.append("-");</code>\n<code>7:  System.out.print(line == anotherLine);</code>\n<code>8:  System.out.print(" ");</code>\n<code>9:  System.out.print(line.length());</code>',answers:["false 1","false 2","true 1","true 2"]},{title:"The author of this method forgot to include the data type. Which of the following reference types can fill in the blank to complete this method?",code:'<code>public static void secret( ____________mystery) {</code>\n<code>  mystery.add("metal");</code>\n<code>  String str = mystery.get(0);</code>\n<code>  int num = mystery.length();</code>\n<code>}</code>',answers:["ArrayList","ArrayList<String>","StringBuilder","None of the above"]},{title:"Which portion of code can be removed so that this line of code continues to compile?",code:"<code>Predicate&lt;StringBuilder&gt; p = (StringBuilder b) \u2010&gt; {return true;};</code>",answers:["Remove StringBuilder b","Remove ->","Remove { and ;}","Remove { return and ;}"]},{title:"What is the output of the following?",code:"<code>20:  List&lt;Character&gt; chars = new ArrayList&lt;&gt;();</code>\n<code>21:  chars.add('a');</code>\n<code>22:  chars.add('b');</code>\n<code>23:  chars.set(1, 'c');</code>\n<code>24:  chars.remove(0);</code>\n<code>25:  System.out.print(chars.size() + \" \" + chars.contains('b'));</code>",answers:["1 false","1 true","2 false","2 true"]},{title:"What is the output of the following?",code:'<code>12:  String b = "12";</code>\n<code>13:  b += "3";</code>\n<code>14:  b.reverse();</code>\n<code>15:  System.out.println(b.toString());</code>',answers:["12","123","321","The code does not compile."]},{title:"How many of these lines fail to compile?",code:"<code>Predicate&lt;String&gt; pred1 = s \u2010&gt; false;</code>\n<code>Predicate&lt;String&gt; pred2 = (s) \u2010&gt; false;</code>\n<code>Predicate&lt;String&gt; pred3 = String s \u2010&gt; false;</code>\n<code>Predicate&lt;String&gt; pred4 = (String s) \u2010&gt; false;</code>",answers:["One","Two","Three","Four"]},{title:"What does the following do?",code:'<code>public class Shoot {</code>\n<code>   interface Target {</code>\n<code>      boolean needToAim(double angle);</code>\n<code>   }</code>\n<code>   static void prepare(double angle, Target t) {</code>\n<code>      boolean ready = t.needToAim(angle);  // k1</code>\n<code><span epub:type="pagebreak" id="Page_140"></span>      System.out.println(ready);</code>\n<code>   }</code>\n<code>   public static void main(String[] args) {</code>\n<code>      prepare(45, d -&gt; d &gt; 5 || d &lt; -5);   // k2</code>\n<code>   }</code>\n<code>}</code>',answers:["It prints true.","It prints false.","It doesn\u2019t compile due to line k1.","It doesn\u2019t compile due to line k2."]},{title:"What is the output of the following?",code:'<code>String teams = new String("694");</code>\n<code>teams.concat(" 1155");</code>\n<code>teams.concat(" 2265");</code>\n<code>teams.concat(" 2869");</code>\n<code>System.out.println(teams);</code>',answers:["694","694 1155 2265 2869","The code compiles but outputs something else.","The code does not compile."]},{title:"Which of these classes are in the java.util package?",code:null,answers:["I only","II only","I and II","I, II, and III"],ol:["ArrayList","LocalDate","String"]},{title:"Which of the answer choices results in a different value being output than the other three choices?",code:'<code>StringBuilder sb = new StringBuilder("radical ");</code>\n<code>sb = ________________________;</code>\n<code>System.out.print(sb);</code>',answers:['new StringBuilder("radical ")\n\n.append("robots")\n','new StringBuilder("radical ")\n\n.delete(1, 100)\n.append("obots")\n.insert(1,  "adical r")\n','new StringBuilder("radical ")\n\n.insert(7, "robots")\n','new StringBuilder("radical ")\n\n.insert(sb.length(), "robots")\n']},{title:"What is the output of the following?",code:'<code>String[] array = {"Natural History", "Science"};</code>\n<code>List&lt;String&gt; museums = Arrays.asList(array);</code>\n<code>museums.set(0, "Art");</code>\n<code>System.out.println(museums.contains("Art"));</code>',answers:["true","false","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which is a true statement?",code:null,answers:['If s.contains("abc") is true, then s.equals("abc") is also true.','If s.contains("abc") is true, then s.startsWith("abc") is also true.','If s.startsWith("abc") is true, then s.equals("abc") is also true.','If s.startsWith("abc") is true, then s.contains("abc") is also true.']},{title:"What is the output of the following?",code:"<code>20:  List&lt;Character&gt; chars = new ArrayList&lt;&gt;();</code>\n<code>21:  chars.add('a');</code>\n<code>22:  chars.add('b');</code>\n<code>23:  chars.set(1, 'c');</code>\n<code>24:  chars.remove(0);</code>\n<code>25:  System.out.print(chars.length());</code>",answers:["0","1","2","None of the above"]},{title:"The author of this method forgot to include the data type. Which of the following reference types can fill in the blank to complete this method?",code:'<code>public static void secret(_____________ mystery) {</code>\n<code>   mystery = mystery.replace("1", "8");</code>\n<code>   mystery.startsWith("paper");</code>\n<code>   String s = mystery.toString();</code>\n<code>}</code>',answers:["ArrayList","String","StringBuilder","None of the above"]},{title:"Which statement is true about the following figure while ensuring the code continues to compile?",code:null,answers:["<> can be inserted at position P without making any other changes.","<> can be inserted at position Q without making any other changes.","<> can be inserted at both positions P and Q.","None of the above"]},{title:"Which of the following can fill in the blank to make the code compile?",code:"<code>import java.util.function.*;</code>\n<code>public class Card {</code>\n<code>   public static void main(String[] s) {</code>\n<code>      Predicate&lt;String&gt; pred =____________  \u2010&gt; true;</code>\n<code>   }</code>\n<code>}</code>",answers:["(Integer i)","(Object o)","(String s)","None of the above"]},{title:"What is the output of the following?",code:'<code>5:  String line = new String("-");</code>\n<code>6:  String anotherLine = line.concat("-");</code>\n<code>7:  System.out.print(line == anotherLine);</code>\n<code>8:  System.out.print(" ");</code>\n<code>9:  System.out.print(line.length());</code>',answers:["false 1","false 2","true 1","true 2"]},{title:"What does the following output?",code:'<code>Predicate dash = c -&gt; c.startsWith("\u2010");</code>\n<code>System.out.println(dash.test("\x96"));</code>',answers:["true","false","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Of the classes LocalDate, LocalDateTime, LocalTime, and LocalTimeStamp, how many include hours, minutes, and seconds?",code:null,answers:["One","Two","Three","Four"]},{title:"What is the output of the following class?",code:'<code>1:  package rocket;</code>\n<code>2:  public class Countdown {</code>\n<code>3:     public static void main(String[] args) {</code>\n<code>4:        String builder = "54321";</code>\n<code>5:        builder = builder.substring(4);</code>\n<code>6:        System.out.println(builder.charAt(2));</code>\n<code>7:     }</code>\n<code>8:  }</code>',answers:["2","3","4","None of the above"]},{title:"Which equivalent code can replace i -> i != 0 in the following line?",code:"<code>Predicate&lt;Integer&gt; ip = i \u2010&gt; i != 0;</code>",answers:["i -> { i != 0 }","i -> { i != 0; }","i -> { return i != 0 }","i -> { return i != 0; }"]},{title:"What is the output of the following?",code:"<code>LocalDate xmas = LocalDate.of(2016,  12,  25);</code>\n<code>xmas.plusDays(-1);</code>\n<code>System.out.println(xmas.getDayOfMonth());</code>",answers:["24","25","26","None of the above"]},{title:"What is the output of the following?",code:'<code>1:   public class Legos {</code>\n<code>2:      public static void main(String[] args) {</code>\n<code>3:         StringBuilder sb = new StringBuilder();</code>\n<code>4:         sb.append("red");</code>\n<code>5:         sb.deleteCharAt(0);</code>\n<code>6:         sb.delete(1, 2);</code>\n<code>7:         System.out.println(sb);</code>\n<code>8:      }</code>\n<code>9:   }</code>',answers:["e","d","ed","None of the above"]},{title:"What does the following output?",code:'<code>Predicate clear = c -&gt; c.equals("clear");</code>\n<code>System.out.println(clear.test("pink"));</code>',answers:["true","false","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which starts counting from one rather than zero?",code:null,answers:["Array indexes","The index used by charAt in a String","The months in a LocalDateTime","The months in a LocalTime"]},{title:"Which statement is not true of Predicate?",code:null,answers:["A boolean is returned from the method it declares.","It is an interface.","The method it declares accepts two parameters.","The method it declares is named test."]},{title:"Which of these periods represents a larger amount of time?",code:"<code>Period period1 = Period.ofWeeks(1).ofDays(3);</code>\n<code>Period period2 = Period.ofDays(10);</code>",answers:["period1","period2","They represent the same length of time.","None of the above. This code does not compile."]},{title:"What is the result of the following?",code:'<code>import java.time.*;</code>\n<code>import java.time.format.*;</code>\n<code>&nbsp;</code>\n<code>public class HowLong {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      LocalDate newYears = LocalDate.of(2017, 1, 1);</code>\n<code>      Period period = Period.ofDays(1);</code>\n<code>      DateTimeFormatter format = DateTimeFormatter.ofPattern("MM-dd-yyyy");</code>\n<code>      System.out.print(format.format(newYears.minus(period)));</code>\n<code>   }</code>\n<code>}</code>',answers:["01-01-2017","12-31-2016","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which of the following can fill in the blank so the following code prints true?",code:'<code>String happy = " :) - (: ";</code>\n<code>String really = happy.trim();</code>\n<code>String question = ______________________;</code>\n<code>System.out.println(really.equals(question));</code>',answers:["happy.substring(0, happy.length() - 1)","happy.substring(0, happy.length())","happy.substring(1, happy.length() - 1)","happy.substring(1, happy.length())"]},{title:"Which is not a true statement about the Period class?",code:null,answers:["A Period is immutable.","A Period is typically used for adding or subtracting time from dates.","You can create a Period representing 2 minutes.","You can create a Period representing 5 years."]},{title:"What is the output of the following class?",code:'<code>1:  package rocket;</code>\n<code>2:  public class Countdown {</code>\n<code>3:     public static void main(String[] args) {</code>\n<code>4:        StringBuilder builder = new StringBuilder("54321");</code>\n<code>5:        builder.substring(2);</code>\n<code>6:        System.out.println(builder.charAt(1));</code>\n<code>7:     }</code>\n<code>8:  }</code>',answers:["1","2","3","4"]},{title:"What does the following output?",code:"<code>List&lt;Integer&gt; pennies = new ArrayList&lt;&gt;();</code>\n<code>pennies.add(3);</code>\n<code>pennies.add(2);</code>\n<code>pennies.add(1);</code>\n<code>pennies.remove(2);</code>\n<code>System.out.println(pennies);</code>",answers:["[3, 1]","[3, 2]","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"The author of this method forgot to include the data type. Which of the following reference types can best fill in the blank to complete this method?",code:'<code>public static void secret(_____________ mystery) {</code>\n<code>   char ch = mystery.charAt(3);</code>\n<code>   mystery = mystery.insert(1, "more");</code>\n<code>   int num = mystery.length();</code>\n<code>}</code>',answers:["ArrayList","String","StringBuilder","None of the above"]},{title:"What is the smallest unit you can add to a LocalTime object?",code:null,answers:["Second","Millisecond","Nanosecond","Picosecond"]},{title:"What is the result of the following?",code:'<code>import java.time.*;</code>\n<code>import java.time.format.*;</code>\n<code>&nbsp;</code>\n<code>public class HowLong {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      LocalDate newYears = LocalDate.of(2017, 1, 1);</code>\n<code>      Period period = Period.ofDays(1);</code>\n<code>      DateTimeFormatter format = DateTimeFormatter.ofPattern("mm-dd-yyyy");</code>\n<code>      System.out.print(format.format(newYears.minus(period)));</code>\n<code>   }</code>\n<code>}</code>',answers:["01-01-2017","12-31-2016","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which of the following types can you pass as a parameter to the replace() method on the String class?",code:null,answers:["I","I and II","II and III","I, II, and III"],ol:["char","String","StringBuilder"]},{title:"How many lines does this code output?",code:'<code>import java.util.*;</code>\n<code>import java.util.function.*;</code>\n<code>&nbsp;</code>\n<code>public class PrintNegative {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>\n<code>      list.add("-5");</code>\n<code>      list.add("0");</code>\n<code>      list.add("5");</code>\n<code>      print(list, e -&gt; e &lt; 0);</code>\n<code>   }</code>\n<code>   public static void print(List&lt;String&gt; list, Predicate&lt;Integer&gt; p) {</code>\n<code>      for (String num : list)</code>\n<code>         if (p.test(num))</code>\n<code>            System.out.println(num);</code>\n<code>   }</code>\n<code>}</code>',answers:["One","Two","None. The code does not compile.","None. The code throws an exception at runtime."]},{title:"What is the output of the following?",code:'<code>12:  List&lt;String&gt; magazines = new ArrayList();</code>\n<code>13:  magazines.add("Readers Digest");</code>\n<code>14:  magazines.add("People");</code>\n<code>15:  magazines.clear();</code>\n<code>16:  magazines.add("The Economist");</code>\n<code>17:  magazines.remove(1);</code>\n<code>18:  System.out.println(magazines.size());</code>',answers:["0","1","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What is the output of the following?",code:"<code>public class Costume {</code>\n<code>   public static void main(String[] black) {</code>\n<code>     String witch = 'b';</code>\n<code>     String tail = \"lack\";</code>\n<code>     witch = witch.concat(tail);</code>\n<code>     System.out.println(witch);</code>\n<code>   }</code>\n<code>}</code>",answers:["b","black","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What is the result of the following?",code:"<code>LocalDate xmas = LocalDate.of(2016,  12,  25);</code>\n<code>xmas.setYear(2017);</code>\n<code>System.out.println(xmas.getYear());</code>",answers:["2016","2017","The code does not compile.","The code compiles but throws an exception at runtime."]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t],ol:e.ol}});i[24].imageUrl="./images/image-oca-ch9-25.png",t.default=i},166:function(e,t,o){"use strict";o.r(t);var n=["D. The toString() method is declared in the Object class. Therefore it is available to be called in any Java class and is overridden in some. Java automatically calls the toString() method when you print an object, making Option D correct. Option C is incorrect because toString() is a method, not a variable.","B. This code is not a singleton because it has a public constructor. Remember that a public no-argument constructor is provided automatically if no constructor is coded. This code is well encapsulated because the instance variable is private. It is not immutable since there is a setter method. Therefore, Option B is correct.","C. The singleton pattern ensures there will be no more than one instance of the object. Depending on how it is implemented, it is possible for there to be zero instances. But it is not possible to have more than one, making Option C correct. Option D means the variable is shared across instances or even without an instance being created but does not limit the number of the instances of the class itself.","C. Both objects are instances of the class Laptop. This means the startup() method in the Laptop class gets called both times thanks to polymorphism.","D. We know that the variable o that equals() is called on isn\u2019t null, since we can\u2019t call instance methods on a null reference. However, a null reference could be passed as a method parameter. If a null is passed in, the method should return false since an object and a null are not equal. Options A and B are incorrect because the first line of those methods should return false rather than true. Option C is incorrect because the cast is missing. The Object class does not have a text variable available. Option D shows a properly implemented equals() method and is correct.","A. Option A is correct because mutability means the state can change and immutability means it cannot. In Option C, static means the state isn\u2019t tied to an instance. In Option B, rigidity is not a common programming term.","B. The Hammer class is a subclass of the Tool class. Since the use() method in Hammer is intended to override the one in Tool, there are certain rules. One is that the access modifier must not be more specific. Therefore, trying to make it private is a problem. Option B is correct and r2 is the only line with a compiler error in this code.","D. The singleton pattern requires that only one instance of the class exist. Neither of these classes meets that requirement since they have the default no-argument constructor available. There should have been a private constructor in each class. Therefore, Option D is correct. Remember that the exam doesn\u2019t always include import statements to simplify the code you need to read.","B. While using null with instanceof compiles, it always returns false. The other two instanceof calls show that instanceof can be used with both classes and interfaces. They both return true, making Option B correct.","D. The static keyword is used to create a class-level variable, making Option D correct. Note that a singleton is where you limit a class so only one instance can be created. This means there are not multiple instances to share a variable across.","A. Option A is a requirement of a singleton class rather than an immutable one. The other three options are requirements of an immutable class.","C. If the variables are public, the class is not encapsulated because callers have direct access to them. This rules out Options A and B. Having private methods doesn\u2019t allow the callers to use the data, making Option D an undesirable answer. Option C is correct and the classic definition of encapsulation where the data is not exposed directly.","A. While both objects are instances of Laptop, we are not calling methods in this example. Virtual method invocation only works for methods, not instance variables. For instance variables, Java actually looks at the type of the reference and calls the appropriate variable. This makes each reference call a different class\u2019s instance variable in this example, and Option A is correct.","B. An immutable class must not allow the state to change. In the Flower class, the caller has a reference to the List being passed in and can change the size or elements in it. Similarly, any class with a reference to the object can get the List by calling get() and make these changes. The Flower class is not immutable. The Plant class shows how to fix these problems and is immutable. Option B is correct.","C. An instance method can access both instance variables and static variables. Both methods compile and Option C is correct.","B. A static method can access static variables, but not instance variables. The getNumRakes() method does not compile, so Option B is correct.","A. You are allowed to use null with instanceof; it just prints false. The bus variable is both a Vehicle and a Bus, so lines 18 and 19 print true. Then it gets interesting. We know that bus is not an ArrayList or Collection. However, the compiler only knows that bus is not an ArrayList because ArrayList is a concrete class. Line 20 does not compile. The compiler can\u2019t definitively state that bus is not a Collection. Some future program could create a subclass of Bus that does implement Collection, so this line compiles. Therefore, only line 20 fails to compile, and Option A is correct.","B. Building and House are both properly declared inner classes. Any House object can be stored in a Building reference, making the declarations for p and r compile. The declaration for s is also correct. It so happens that bh is a House object, so the cast works. The declaration of q is a problem though. While the cast itself is fine, a Building cannot be stored in a House reference, which means the assignment fails to compile. Option B is correct and is the only line with a compiler error in this code. Note that if the declaration of q was removed, the declaration of p would produce a ClassCastException at runtime.","D. If two instances of a class have the same hash code, they might or might not be equal. The reverse is not true. If two objects are equal, they must have the same hash code in order to comply with the contracts of these methods. However, in this case, the answer is none of the above because the method can\u2019t simply return true or false. Based on the rules of equals(), if null is passed in, the result must be false. If an object identity is passed in, the result must be true due to reflexivity. As a result, Option D is correct.","D. This class is a good example of encapsulation. It has a private instance variable and is accessed by a public method. No changes are needed to encapsulate it, and Option D is correct.","B. The singleton pattern requires that only one instance of the class exist. The ExamAnswers class is close. However, getExamAnswers() is not static, so you can\u2019t retrieve the instance. Option B is the answer because TestAnswers is a correct implementation. It has a static variable representing the one instance and a static method to retrieve it.","C. The static initializer is only run once. The static method is run twice since it is called twice. Therefore, three lines are printed, and Option C is correct.","C. Option A is allowed because the turnOn() method is public and can be called from anywhere. Options B and D are allowed since the method is in the same class, which is always allowed! Option C is not allowed because wash() is a package-private method in another package. Option C is the correct answer.","B. The display() method has protected access. This means it can be accessed by instance methods in the same package and any subclasses. There are no subclasses in this example, so we only need to count the classes in the same package. Option B is correct because Flashlight and Phone are in the package.","B. Line 15 calls the method on line 9 since it is a Watch object. That returns watch, making Option A incorrect. Line 16 calls the method on line 3 since it is a SmartWatch object and the method is properly overridden. That returns smart watch, so Option B is the answer, and Option C is incorrect.","A. Clearly a Bus is a Vehicle since the Bus class implements Vehicle. The Van class is also a Vehicle since it extends Bus. This question also confirms you know that arrays can be tested with instanceof, which they can. Therefore, Option A is correct.","C. There is no instanceOf keyword, making Options B and D incorrect. There is an instanceof keyword. If an object is the wrong type, the equals() method should return false, making Option C the answer.","D. The Hammer class is a subclass of the Tool class. Luckily, the use() method has a different signature so it is not an override. This means it is fine that the access modifier is stricter, and Option D is correct. Line r3 is a valid method unrelated to the superclass.","B. Lazy instantiation is part of a possible implementation for the singleton pattern. It defers creating the object until the first caller requests it. While this does save memory, it only does so if the object is never requested. This does not save memory when actually creating the object. Option B is correct.","D. Notice how the code begins at line 30. This means you have to infer the surrounding code. Here it is reasonable to assume the classes are inner classes. Building and House are defined correctly. Any House or Building reference can potentially be a House. The compiler does not know which ones work and which don\u2019t. This means all three casts compile.","C. Encapsulation doesn\u2019t allow callers access to the instance variables, which makes it easier to change the code. The instance variables can be any type, which means they can be mutable or immutable. There are not constraints on the implementation of methods. The purpose of encapsulation is to lessen how tightly tied or coupled the classes are. Option C is the opposite of this, making it the answer.","A. An immutable class must not allow the state to change. The Flower class does this correctly. While the class isn\u2019t final, the getters are, so subclasses can\u2019t change the value returned. The Plant class lacks this protection, which makes it mutable. Option A is correct.","D. A static initializer is not allowed inside of a method. It should go on the class level rather than the method level. Therefore, the code does not compile, and Option D is correct.","A. An object is required to have the same value for repeated calls to hashCode() if the value has not changed. This makes III and IV incorrect. If two objects are equal, they are required to have the same hash code. Since equality must be reflexive, it cannot return false if the same object is passed, and I is incorrect. Since equals() must return false when null is passed in, it cannot be true and II is incorrect. Therefore, Option A is the answer. ","D. By definition, you cannot change the value of an instance variable in an immutable class. There are no setter methods, making Option A incorrect. While Option B would allow you to set the value, the class would no longer be immutable. Option D is correct. If you are an advanced developer, you might know that you can use reflection to change the value. Don\u2019t read into questions like this on the exam. Reflection isn\u2019t on the exam, so you can pretend it doesn\u2019t exist.","B. Option A is incorrect because the \u201cis-a\u201d principle is about inheritance. For example, a String is an Object. Option C is incorrect because singletons require a static variable to ensure there is only one instance. While it is common to have instance variables as well, this is not required to implement the pattern. Option B is correct. For an object to be composed of other objects, instance variables are required.","B. The static initializer only runs once since statics are shared by all instances. The instance initializer runs twice because we call the constructor twice. Therefore, Option B is correct.","A. While there is a default keyword in Java, it is only allowed in interfaces or in switch statements. It is not a visibility modifier. The author of this code probably intended for the method to be package-private, which doesn\u2019t use a visibility modifier. The line with default doesn\u2019t compile, so Option A is correct. If default was removed, the code would all compile.","A. The reference b points to a Building object, which cannot be stored in a House reference. This means the assignment to p compiles but fails at runtime. The other two casts would run without issue if the code got that far.","C. The hashCode() method in the Object class does not have a parameter. Therefore, the Sticker class provides an overloaded method rather than an overridden one. Since it is not an overridden method, the contract for the Object class\u2019 hashCode() method does not apply, and any int value can be returned. Therefore, Option C is correct."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"Which answer choice can replace line 6 so the code continues to produce the same output?",code:'<code>3:   List&lt;String&gt; rug = new ArrayList&lt;&gt;();</code>\n<code>4:   rug.add("circle");</code>\n<code>5:   rug.add("square");</code>\n<code>6:   System.out.println(rug);</code>',answers:["System.out.println(rug.asString);","System.out.println(rug.asString());","System.out.println(rug.toString);","System.out.println(rug.toString());"]},{title:"Which best describes this code?",code:"<code>class Stats {</code>\n<code>   private int data;</code>\n<code>   public int getData() {</code>\n<code>      return data;</code>\n<code>   }</code>\n<code>   public void setData(int data) {</code>\n<code>     this.data = data;</code>\n<code>   }</code>\n<code>}</code>",answers:["It is a singleton.","It is well encapsulated.","It is immutable.","It is both well encapsulated and immutable."]},{title:"What design pattern or principle ensures that there will be no more than one instance of a class?",code:null,answers:["Encapsulation","Immutability","Singleton","Static"]},{title:"What is the output of this code?",code:'<code>class Laptop extends Computer {</code>\n<code><span epub:type="pagebreak" id="Page_189"></span>    public void startup() {</code>\n<code>        System.out.print("laptop-");</code>\n<code>    }</code>\n<code>}</code>\n<code>public class Computer {</code>\n<code>   public void startup() {</code>\n<code>      System.out.print("computer-");</code>\n<code>   }</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Computer computer = new Laptop();</code>\n<code>      Laptop laptop = new Laptop();</code>\n<code>      computer.startup();</code>\n<code>      laptop.startup();</code>\n<code>   }</code>\n<code>}</code>',answers:["computer-laptop-","laptop-computer-","laptop-laptop-","None of the above"]},{title:"Which method can be correctly inserted into this class to meet the contract of the  equals() method? You may assume that text is not null.",code:"<code>class Button {</code>\n<code>   private String text;</code>\n<code>&nbsp;</code>\n<code>   public int hashCode() {</code>\n<code>      return text.hashCode();</code>\n<code>   }</code>\n<code>}</code>",answers:["\n\n\xa0 \n\npublic boolean equals(Object o) { \n\n   if ( o == null ) return true; \n\n   if (! (o instanceof Button)) return false; \n\n   return text.equals(o.text); \n\n}\n","\n\n\xa0 \n\npublic boolean equals(Object o) { \n\n   if ( o == null ) return true; \n\n   Button b = (Button) o; \n\n   return text.equals(b.text); \n\n}\n","\n\n\xa0 \n\npublic boolean equals(Object o) { \n\n   if (! (o instanceof Button)) return false; \n\n   return text.equals(o.text); \n\n}\n","\n\n\xa0 \n\npublic boolean equals(Object o) { \n\n   if (! (o instanceof Button)) return false; \n\n   Button b = (Button) o; \n\n   return text.equals(b.text); \n\n}\n"]},{title:"Fill in the blanks:  ____________means the state of an object cannot be changed while  ____________means that it can.",code:null,answers:["Immutability, mutability","Rigidity, flexibility","Static, instance","None of the above"]},{title:"Which is the first line to fail to compile?",code:"<code>class Tool {</code>\n<code>   void use() { }     // r1</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>class Hammer extends Tool {</code>\n<code>   private void use() { }  // r2</code>\n<code>   public void bang() { }  // r3</code>\n<code>}</code>\n<code>&nbsp;</code>",answers:["r1","r2","r3","None of the above"]},{title:"Which of these classes properly implement(s) the singleton pattern?",code:'<code>class ExamAnswers {</code>\n<code>  private static ExamAnswers instance = new ExamAnswers();</code>\n<code>  private List&lt;String&gt; answers = new ArrayList&lt;&gt;();</code>\n<code><span epub:type="pagebreak" id="Page_191"></span>  public static List&lt;String&gt; getAnswers() {</code>\n<code>    return instance.answers;</code>\n<code>  }</code>\n<code>}</code>\n<code>class TestAnswers {</code>\n<code>   private static TestAnswers instance = new TestAnswers();</code>\n<code>   private List&lt;String&gt; answers = new ArrayList&lt;&gt;();</code>\n<code>   public static TestAnswers getTestAnswers() {</code>\n<code>      return instance;</code>\n<code>   }</code>\n<code>   public List&lt;String&gt; getAnswers() {</code>\n<code>      return answers;</code>\n<code>   }</code>\n<code>}</code>',answers:["ExamAnswers","TestAnswers","Both classes","Neither class"]},{title:"What does the following print?",code:'<code>public class Transport {</code>\n<code>   static interface Vehicle {}</code>\n<code>   static class Bus implements Vehicle {}</code>\n<code>&nbsp;</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Bus bus = new Bus();</code>\n<code>      boolean n = null instanceof Bus;</code>\n<code>      boolean v = bus instanceof Vehicle;</code>\n<code>      boolean b = bus instanceof Bus;</code>\n<code>      System.out.println(n + " " + v + " " + b);</code>\n<code>  }</code>\n<code>}</code>',answers:["true true true","false true true","false false false","None of the above"]},{title:"What technique allows multiple variables from the same class to be shared across all instances of a class?",code:null,answers:["Encapsulation","Immutability","Singleton","Static"]},{title:"Which is not a requirement for a class to be immutable?",code:null,answers:["A private constructor is provided.","Any instance variables are private.","Methods cannot be overridden.","There are no setter methods."]},{title:"Which statement is true about encapsulation while providing the broadest access allowed?",code:null,answers:["Variables are public and methods are private.","Variables are public and methods are public.","Variables are private and methods are public.","Variables are private and methods are private."]},{title:"What does the following print?",code:'<code>class Laptop extends Computer {</code>\n<code>   String type = "laptop";</code>\n<code>}</code>\n<code>public class Computer {</code>\n<code>   String type = "computer";</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Computer computer = new Laptop();</code>\n<code>      Laptop laptop = new Laptop();</code>\n<code>      System.out.print(computer.type + "," + laptop.type);</code>\n<code>   }</code>\n<code>}</code>',answers:["computer,laptop","laptop,computer","laptop,laptop","None of the above"]},{title:"Which of these classes is/are immutable?",code:'<code>public final class Flower {</code>\n<code>   private final String name;</code>\n<code>   private final List&lt;Integer&gt; counts;</code>\n<code>   public Flower(String name, List&lt;Integer&gt; counts) {</code>\n<code><span epub:type="pagebreak" id="Page_193"></span>      this.name = name;</code>\n<code>      this.counts = counts;</code>\n<code>   }</code>\n<code>   public String getName() {</code>\n<code>      return name;</code>\n<code>   }</code>\n<code>   public List&lt;Integer&gt; getCounts() {</code>\n<code>      return counts;</code>\n<code>   }</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>public final class Plant {</code>\n<code>   private final String name;</code>\n<code>   private final List&lt;Integer&gt; counts;</code>\n<code>   public Plant(String name, List&lt;Integer&gt; counts) {</code>\n<code>      this.name = name;</code>\n<code>      this.counts = new ArrayList&lt;&gt;(counts);</code>\n<code>   }</code>\n<code>   public String getName() {</code>\n<code>      return name;</code>\n<code>   }</code>\n<code>   public List&lt;Integer&gt; getCounts() {</code>\n<code>      return new ArrayList&lt;&gt;(counts);</code>\n<code>   }</code>\n<code>}</code>\n<code>&nbsp;</code>',answers:["Flower","Plant","Both classes","Neither class"]},{title:"Which methods compile?",code:"<code>private static int numShovels;</code>\n<code>private int numRakes;</code>\n<code>&nbsp;</code>\n<code>public int getNumShovels() {</code>\n<code>   return numShovels;</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>public int getNumRakes() {</code>\n<code>   return numRakes;</code>\n<code>}</code>",answers:["Just getNumRakes()","Just getNumShovels()","Both methods","Neither method"]},{title:"Which methods compile?",code:"<code>private static int numShovels;</code>\n<code>private int numRakes;</code>\n<code>&nbsp;</code>\n<code>public static int getNumShovels() {</code>\n<code>   return numShovels;</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>public static int getNumRakes() {</code>\n<code>   return numRakes;</code>\n<code>}</code>",answers:["Just getNumRakes()","Just getNumShovels()","Both methods","Neither method"]},{title:"How many lines of the main method fail to compile?",code:"<code>11:  static interface Vehicle {}</code>\n<code>12:  static class Bus implements Vehicle {}</code>\n<code>13:</code>\n<code>14:  public static void main(String[] args) {</code>\n<code>15:     Bus bus = new Bus();</code>\n<code>16:</code>\n<code>17:     System.out.println(null instanceof Bus);</code>\n<code>18:     System.out.println(bus instanceof Vehicle);</code>\n<code>19:     System.out.println(bus instanceof Bus);</code>\n<code>20:     System.out.println(bus instanceof ArrayList);</code>\n<code>21:     System.out.println(bus instanceof Collection);</code>\n<code>22: }</code>",answers:["One","Two","Three","Four"]},{title:"Which variable declaration is the first line not to compile?",code:"<code>class Building {}</code>\n<code>class House extends Building{}</code>\n<code>&nbsp;</code>\n<code>public void convert() {</code>\n<code>   Building b =  new Building();</code>\n<code>   House h = new House();</code>\n<code>   Building bh = new House();</code>\n<code>   Building p = (House) b;</code>\n<code>   House q = (Building) h;</code>\n<code>   Building r = (Building) bh;</code>\n<code>   House s = (House) bh;</code>\n<code>}</code>",answers:["p","q","r","s"]},{title:"Which statement is true about the code that can fill in the blank?",code:"<code>class Sticker {</code>\n<code>   public int hashCode() {</code>\n<code>      return 1;</code>\n<code>   }</code>\n<code>   public boolean equals(Object o) {</code>\n<code>      return____________ ;</code>\n<code>   }</code>\n<code>}</code>",answers:["It must return false.","It must return true.","It can return either true or false.","None of the above."]},{title:"What change is needed to make Secret well encapsulated?",code:"<code>import java.util.*;</code>\n<code>&nbsp;</code>\n<code>public class Secret {</code>\n<code>&nbsp;</code>\n<code>   private int number = new Random().nextInt(10);</code>\n<code>   public boolean guess(int candidate) {</code>\n<code>      return number == candidate;</code>\n<code>   }</code>\n<code>}</code>",answers:["Change number to use a public access modifier.","Declare a private constructor.","Remove the guess method.","None. It is already well encapsulated."]},{title:"Which of these classes best implement(s) the singleton pattern?",code:"<code>class ExamAnswers {</code>\n<code>   private static ExamAnswers instance = new ExamAnswers();</code>\n<code>   private List&lt;String&gt; answers = new ArrayList&lt;&gt;();</code>\n<code>   private ExamAnswers() {}</code>\n<code>   public ExamAnswers getExamAnswers() {</code>\n<code>      return instance;</code>\n<code>   }</code>\n<code>   public List&lt;String&gt; getAnswers() {</code>\n<code>      return answers;</code>\n<code>   }</code>\n<code>}</code>\n<code>class TestAnswers {</code>\n<code>   private static TestAnswers instance = new TestAnswers();</code>\n<code>   private List&lt;String&gt; answers = new ArrayList&lt;&gt;();</code>\n<code>   private TestAnswers() {}</code>\n<code>   public static TestAnswers getTestAnswers() {</code>\n<code>      return instance;</code>\n<code>   }</code>\n<code>   public List&lt;String&gt; getAnswers() {</code>\n<code>      return answers;</code>\n<code>   }</code>\n<code>}</code>",answers:["ExamAnswers","TestAnswers","Both classes","Neither class"]},{title:"How many lines does the following code output?",code:'<code>public class Cars {</code>\n<code>  static {</code>\n<code><span epub:type="pagebreak" id="Page_197"></span>     System.out.println("static");</code>\n<code>  }</code>\n<code>  private static void drive() {</code>\n<code>     System.out.println("fast");</code>\n<code>  }</code>\n<code>  public static void main(String[] args) {</code>\n<code>     drive();</code>\n<code>     drive();</code>\n<code>  }</code>\n<code>}</code>',answers:["One","Two","Three","None of the above. The code does not compile."]},{title:"Which is not a true statement given this diagram?",code:null,answers:["Instance methods in the Blanket class can call the Flashlight class\u2019s turnOn().","Instance methods in the Flashlight class can call the Flashlight class\u2019s replaceBulb().","Instance methods in the Phone class can call the Blanket class\u2019s wash().","Instance methods in the Tent class can call the Tent class\u2019s pitch()."]},{title:"Given the diagram in the previous question, how many of the classes can call the display() method?",code:null,answers:["One","Two","Three","Four"]},{title:"What does the following print?",code:'<code>1:   class SmartWatch extends Watch {</code>\n<code>2:      private String getType() { return "smart watch"; }</code>\n<code>3:      public String getName(String suffix) {</code>\n<code><span epub:type="pagebreak" id="Page_198"></span>4:         return getType() + suffix;</code>\n<code>5:      }</code>\n<code>6:   }</code>\n<code>7:   public class Watch {</code>\n<code>8:      private String getType() { return "watch"; }</code>\n<code>9:      public String getName(String suffix) {</code>\n<code>10:        return getType() + suffix;</code>\n<code>11:     }</code>\n<code>12:     public static void main(String[] args) {</code>\n<code>13:        Watch watch = new Watch();</code>\n<code>14:        SmartWatch smartWatch = new SmartWatch();</code>\n<code>15:        System.out.print(watch.getName(","));</code>\n<code>16:        System.out.print(smartWatch.getName(""));</code>\n<code>17:     }</code>\n<code>18:  }</code>',answers:["smart watch,watch","watch,smart watch","watch,watch","None of the above"]},{title:"What does the following print?",code:'<code>public class Transport {</code>\n<code>   static interface Vehicle {}</code>\n<code>   static class Bus implements Vehicle {}</code>\n<code>   static class Van extends Bus {}</code>\n<code>&nbsp;</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Bus bus = new Van();</code>\n<code>      Van van = new Van();</code>\n<code>      Van[] vans = new Van[0];</code>\n<code>&nbsp;</code>\n<code>      boolean b = bus instanceof Vehicle;</code>\n<code>      boolean v = van instanceof Vehicle;</code>\n<code>      boolean a = vans instanceof Vehicle[];</code>\n<code>&nbsp;</code>\n<code>      System.out.println(b + " " + v + " " + a);</code>\n<code>   }</code>\n<code>}</code>',answers:["true true true","false true true","true false false","None of the above. The code does not compile"]},{title:"Which of the following correctly fills in the blank so this code compiles and prints true?",code:'<code>public class Button {</code>\n<code>   private String text;</code>\n<code>   public int hashCode() {</code>\n<code>      return text.hashCode();</code>\n<code>   }</code>\n<code>   public boolean equals(Object o) {</code>\n<code>      if (____________)  return false;</code>\n<code>      Button b = (Button) o;</code>\n<code>      return text.equals(b.text);</code>\n<code>   }</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Button b1 = new Button();</code>\n<code>      Button b2 = new Button();</code>\n<code>      b1.text = "mickey";</code>\n<code>      b2.text = "mickey";</code>\n<code>      System.out.println(b1.equals(b2));</code>\n<code>   }</code>\n<code>}</code>',answers:["(o instanceof Button)","(o instanceOf Button)","!(o instanceof Button)","!(o instanceOf Button)"]},{title:"Which is the first line to fail to compile?",code:"<code>class Tool {</code>\n<code>   void use() { }     // r1</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>class Hammer extends Tool {</code>\n<code>   private void use(String s) { }  // r2</code>\n<code>   public void bang() { }  // r3</code>\n<code>}</code>\n<code>&nbsp;</code>",answers:["r1","r2","r3","None of the above"]},{title:"What is lazy instantiation?",code:null,answers:["A technique that can be used in an immutable class to wait until the first use to create the object","A technique that can be used in a singleton to wait until the first use to create the object","A technique that can be used in an immutable class to save memory when creating the object","A technique that can be used in a singleton to save memory when creating the object"]},{title:"Which variable declaration is the first line not to compile?",code:"<code>30:  class Building {}</code>\n<code>31:  class House extends Building{}</code>\n<code>32:</code>\n<code>33:  public void convert() {</code>\n<code>34:     Building b =  new Building();</code>\n<code>35:     House h = new House();</code>\n<code>36:     Building bh = new House();</code>\n<code>37:     House p = (House) b;</code>\n<code>38:     House q = (House) h;</code>\n<code>39:     House r = (House) bh;</code>\n<code>40:  }</code>",answers:["p","q","r","None of the above"]},{title:"Which statement about encapsulation is not true?",code:null,answers:["Encapsulation allows putting extra logic in the getter and setter methods.","Encapsulation can use immutable instance variables in the implementation.","Encapsulation causes two classes to be more tightly tied together.","Encapsulation makes it easier to change the instance variables in the future."]},{title:"Which of these classes is/are immutable?",code:'<code>public class Flower {</code>\n<code>   private final String name;</code>\n<code><span epub:type="pagebreak" id="Page_201"></span>   private final List&lt;Integer&gt; counts;</code>\n<code>   public Flower(String name, List&lt;Integer&gt; counts) {</code>\n<code>      this.name = name;</code>\n<code>      this.counts = new ArrayList&lt;&gt;(counts);</code>\n<code>   }</code>\n<code>   public final String getName() {</code>\n<code>      return name;</code>\n<code>   }</code>\n<code>   public final List&lt;Integer&gt; getCounts() {</code>\n<code>      return new ArrayList&lt;&gt;(counts);</code>\n<code>   }</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>public class Plant {</code>\n<code>   private final String name;</code>\n<code>   private final List&lt;Integer&gt; counts;</code>\n<code>   public Plant(String name, List&lt;Integer&gt; counts) {</code>\n<code>      this.name = name;</code>\n<code>      this.counts = new ArrayList&lt;&gt;(counts);</code>\n<code>   }</code>\n<code>   public String getName() {</code>\n<code>      return name;</code>\n<code>   }</code>\n<code>   public List&lt;Integer&gt; getCounts() {</code>\n<code>      return new ArrayList&lt;&gt;(counts);</code>\n<code>   }</code>\n<code>}</code>\n<code>&nbsp;</code>',answers:["Flower","Plant","Both classes","Neither class"]},{title:"How many lines does the following code output?",code:'<code>public class Cars {</code>\n<code>   private static void drive() {</code>\n<code>       static {</code>\n<code>          System.out.println("static");</code>\n<code>       }</code>\n<code>       System.out.println("fast");</code>\n<code><span epub:type="pagebreak" id="Page_202"></span>   }</code>\n<code>   public static void main(String[] args) {</code>\n<code>      drive();</code>\n<code>      drive();</code>\n<code>   }</code>\n<code>}</code>',answers:["One","Two","Three","None of the above. The code does not compile."]},{title:"How many of the following pairs of values can fill in the blanks to comply with the contract of the hashCode() and equals() methods?",code:"<code>class Sticker {</code>\n<code>   public int hashCode() {</code>\n<code>      return _____________;</code>\n<code>   }</code>\n<code>   public boolean equals(Object o) {</code>\n<code>      return _____________;</code>\n<code>   }</code>\n<code>}</code>",answers:["None","One","Two","Three"],ol:["1, false","1, true","new Random().nextInt(), false","new Random().nextInt(), true"]},{title:"How do you change the value of an instance variable in an immutable class?",code:null,answers:["Call the setter method.","Remove the final modifier and set the instance variable directly.","Use a method other than Option A or B.","You can\u2019t."]},{title:"Which technique or pattern requires instance variables to implement?",code:null,answers:["Is-a","Object composition","Singleton","None of the above"]},{title:"How many lines of output does the following generate?",code:'<code>public class HowMany {</code>\n<code>   static {</code>\n<code>      System.out.println("any");</code>\n<code>   }</code>\n<code>   {</code>\n<code>      System.out.println("more");</code>\n<code>   }</code>\n<code>   public static void main(String[] args) {</code>\n<code>      new HowMany();</code>\n<code>      new HowMany();</code>\n<code>   }</code>\n<code>}</code>\n<code>&nbsp;</code>',answers:["Two","Three","Four","None of the above. The code does not compile."]},{title:"Which is the first line to fail to compile?",code:"<code>class Tool {</code>\n<code>   default void use() { }     // r1</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>class Hammer extends Tool {</code>\n<code>   public void use() { }  // r2</code>\n<code>   public void bang() { }  // r3</code>\n<code>}</code>\n<code>&nbsp;</code>",answers:["r1","r2","r3","None of the above"]},{title:"Which variable declaration is the first line to throw a ClassCastException at runtime?",code:"<code>class Building {}</code>\n<code>class House extends Building{}</code>\n<code>&nbsp;</code>\n<code>public void convert() {</code>\n<code>   Building b =  new Building();</code>\n<code>   House h = new House();</code>\n<code>   Building bh = new House();</code>\n<code>   House p = (House) b;</code>\n<code>   House q = (House) h;</code>\n<code>   House r = (House) bh;</code>\n<code>}</code>",answers:["p","q","r","None of the above"]},{title:"Which of the following values can fill in the blank for the class to be correctly implemented?",code:"<code>class Sticker {</code>\n<code>   public int hashCode(Object o) {</code>\n<code>      return_____________ ;</code>\n<code>   }</code>\n<code>   public boolean equals(Object o) {</code>\n<code>      return true;</code>\n<code>   }</code>\n<code>}</code>",answers:["I","I and II","I, II, and III","I and III"],ol:["-1","5","new Random().nextInt()"]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t],ol:e.ol}});i[22].imageUrl="./images/image-ocp-ch11-23.png",t.default=i},167:function(e,t,o){"use strict";o.r(t);var n=["B. The lambda expression s -> true is valid, making Options A, C, and D incorrect. Parentheses () are not required on the left-hand side if there is only one variable. Brackets {} are not required if the right-hand side is a single expression. Parameter data types are only required if the data type for at least one parameter is specified, otherwise none are required. The remaining choice, the arrow operator ->, is required for all lambda expressions, making Option B the correct answer.","D. The application contains a compilation error. The case statements incorrectly use the enum name as well as the value, such as DaysOff.ValentinesDay. Since the type of the enum is determined by the value of the variable in the switch statement, the enum name is not allowed and throws a compilation error when used. For this reason, Option D is correct. If the enum name DaysOff was removed, the application would output 12, since the lack of any break statements causes multiple blocks to be reached, and Option C would have been the correct answer.","C. A functional interface must include exactly one abstract method, either by inheritance or declared directly. It may also have any number, including zero, of default or static methods. For this reason, both parts of Option D are incorrect. The first part of Option A is incorrect because more than one abstract method disqualifies it as a functional interface. The first part of Option B is incorrect because the method must be abstract; that is to say, any method will not suffice. Finally, Option C is the correct answer. The first part of the sentence defines what it means to be a functional interface. The second part refers to the optional @FunctionalInterface annotation. It is considered a good practice to add this annotation to any functional interfaces you define because the compiler will report a problem if you define an invalid interface that does not have exactly one abstract method.","C. While an anonymous inner class can extend another class or implement an interface, it cannot be declared final or abstract since it has no class definition. For this reason, Option C is correct. The other classes may be declared final or abstract since they have a class definition.","B. Option A is incorrect because the lambda expression is missing a semicolon (;) at the end of the return statement. Option C is incorrect because the local variable test is used without being initialized. Option D is also incorrect. The parentheses are required on the left-hand side of the lambda expression when there is more than one value or a data type is specified. Option B is the correct answer and the only valid lambda expression.","B. An enum cannot be marked abstract, nor can any of its values, but its methods can be marked abstract, making Option B the correct answer. Note that if an enum contains an abstract method, then every enum value must include an override of this abstract method.","B. The code compiles without issue, so Option D is incorrect. The first print() statement refers to value in the Deeper class, so 5 is printed. The second and third print() statements actually refer to the same value in the Deep class, so 2 is printed twice. The prefix Matrix. is unnecessary in the first of the two print() statements and does not change the result. For these reasons, Option B is the correct answer.","D. A local inner class can access final or effectively final local variables, making Option D the correct answer. The second statement is invalid because access modifiers like private cannot be applied to local variables.","C. The type of the variable in the switch statement is the enum Currency, but the case statements use int values. While the enum class hierarchy does support an ordinal() method, which returns an int value, the enum values cannot be compared directly with int values. For this reason, the code does not compile, since the case statement values are not compatible with the variable type in the switch statement, making Option C the correct answer.","C. A local variable is effectively final when it\u2019s primitive value or object reference does not change after it is initialized, making Option C the correct answer. Option D is incorrect. Any change to the variable after it is initialized disqualifies it for being considered effectively final.","D. Both the Drive and Hover interfaces define a default method getSpeed() with the same signature. In fact, both getSpeed() methods return the same value of 5. The class Car implements both interfaces, which means it inherits both default methods. Since the compiler does not know which one to choose, the code does not compile, and the answer is Option D. Note that if the Car class had overridden the getSpeed() method, then the code would have compiled without issue and printed 10 at runtime. In particular, the local class Racecar defined in the main() method compiles without issue, making Option C incorrect.","B. An interface can be extended by another interface and a class can be extended by another class, making the second part of Options A, C, and D incorrect. Option B is correct because an enum cannot be extended. Note that Option C is also incorrect for this reason.","B. If the program is called with a single input WEST, then WEST would be printed at runtime. If the program is called with no input, then the compass array would be of size zero, and an ArrayIndexOutOfBoundsException would be thrown at runtime. Finally, if the program is called with a string that does not match one of the values in Direction, then an IllegalArgumentException would be thrown at runtime. The only result not possible is south, since the enum value is in uppercase, making Option B the correct answer.","B. Enumerated types support creating a set of reusable values whose values are fixed and consistent across the entire application. For these reason, Options A, C, and D are incorrect. Option B is the false statement because enum values are defined at compile time and cannot be changed or added at runtime.","D. The program contains three compilation problems. First off, the enum Color extends the enum Light, but enums cannot extend other enums so the definition is invalid. Second, the enum value list must end with a semicolon (;) if the enum definition contains anything other than the enum values. Since it includes a constructor, a semicolon (;) is required after GREEN. Finally, enum constructors must be private, meaning the protected constructor for Color does not compile. For these three reasons, Option D is the correct answer.","D. Both abstract classes and interfaces can include static methods, so Options A and C are incorrect. A static nested class can include static methods, but it is the only type of inner class in which this is allowed. Local inner classes, anonymous inner classes, and member inner classes do not support static methods. For these reasons, Option D is correct, and Option B is incorrect.","B. A functional interface must contain exactly one abstract method. The Bend interface contains two abstract methods, pump() and bend(), since it extends Pump and inherits pump(). For this reason, the Bend method is not a valid functional interface and therefore cannot be used as a lambda expression, making Option B the correct answer. The rest of the code compiles without issue. Note that the usage of an instance variable to call a static method, r.apply() in the main() method, is permitted but discouraged.","C. Applying the @Override annotation is optional and not required to override a method or implement an interface method, making Options A and B incorrect. While partially helpful as a form of documentation, it is not the best reason to apply the annotation, making Option D incorrect. The best reason is that the compiler will actually fail to compile if the method that the @Override annotation is being applied to is not actually overriding an inherited method. This behavior helps correct typos or changes in superclasses or interfaces that could break the class or lead to unexpected behavior. For this reason, Option C is the best choice.","C. The Bottle class includes a static nested class Ship that must be instantiated in a static manner. Line w2 uses an instance of Bottle to instantiate the Ship. While this would be allowed if Ship was a member inner class, since it is a static nested class, line w2 does not compile, and Option C is the correct answer. Note that if Ship was changed to be a member inner class, the code would still not compile since a member inner class cannot include static members and enums are inherently static. Therefore, the correct change would be to fix the declaration on line w2.","A. Option A is the invalid lambda expression because the type is specified for the variable j, but not the variable k. The rest of the options are valid lambda expressions. To be a valid lambda expression, the type must be specified for all of the variables, as in Option C, or none of them, as in Options B and D.","D. This application declares an anonymous inner class that implements the Edible interface. Interface methods are public, whereas the override in the anonymous inner class uses package-private access. Since this reduces the visibility of the method, the declaration of eat() on line 8 does not compile. Next, the declaration of the apple object must end with a semicolon (;) on line 11, and it does not. For these two reasons, the code does not compile, and Option D is the correct answer. Note that if these two issues were corrected, with the public modifier and missing semi-colon (;), then the correct answer would be Option A because the code does not actually call the eat() method; it just declares it.","A. The code compiles without issue and prints 15, making Option A correct and Option D incorrect. The main() method defines a local class Oak that correctly extends Tree, a static nested class, making Option B incorrect. Finally, the method getWater() is permitted to read the variable water, defined in the main() method, since it is effectively final, having a value of 15 when it is defined. For this reason, Option C is also incorrect.","C. Interfaces allow Java to support multiple inheritance because a class may implement any number of interfaces. On the other hand, an anonymous inner class may implement at most one interface, since it does not have a class definition to implement any others. For these reasons, Option C is the correct answer.","A. The code does not compile because the declaration of isDanger() in the class SeriousDanger is an invalid method override. An overridden method may not throw a broader checked exception than it inherits. Since Exception is a superclass of Problem, thrown by the inherited method in the Danger class, the override of this checked exception is invalid. For this reason, line m1 does not compile, and Option A is the correct answer. The rest of the lines of code compile without issue.","B. Options A, C, and D are true statements about interfaces and abstract classes. Option B is the correct answer because neither abstract classes nor interfaces can be marked final. For Option D, methods and variables can both be marked private in abstract classes in some cases. The \u201csome cases\u201d refers to the fact that the private modifier cannot be applied to abstract methods, since a method cannot be marked both final and abstract. Since abstract classes can contain concrete methods, which can take the private access modifier, the statement is true.","A. The code compiles without issue, so Option C is incorrect. Enum ordinal values are indexed starting with zero, so 0 is printed first. The second line compiles and runs without issue, with flurry being converted to FLURRY, using the toUpperCase() method. Since there is a matching enum named FLURRY, that value is printed next. For these reasons, Option A is the correct answer.","D. Java was updated to include default interface methods in order to support backward compatibility of interfaces. By adding a default method to an existing interface, we can create a new version of the interface, which can be used without breaking the functionality of existing classes that implement an older version of the interface. For this reason, Option D is the correct answer. Options A and C are not applicable to default interface methods, whereas Option B could be achieved by using static interface methods.","C. The Penguin class includes a member inner class Chick. Member inner classes cannot include static methods or variables. Since the variable volume is marked static, the member inner class Chick does not compile, making Option C the correct answer. Note that the variable volume referenced in the chick() method is one defined in the Penguin outer class. If the static modifier was removed from the volume variable in the Chick class, then the rest of the code would compile and run without issue, printing Honk(1)! at runtime.","D. Member inner classes require an instance of the surrounding class to be instantiated. Option A is incorrect since we are told that the instantiation request is from a static method. Note that this call would be valid from a non-static method in Dinosaur. Option B is incorrect because it lacks the new keyword. Option C is incorrect. Pterodactyl is a member inner class, not a static nested class. Option D is correct and uses the instance dino to create a new Pterodactyl object.","C. First off, both CanBurrow and HasHardShell are functional interfaces since they contain exactly one abstract method, although only the latter uses the optional @FunctionalInterface annotation. The declarations of these two interfaces, along with the abstract class Tortoise, compile without issue, making Options A and B incorrect. The code does not compile, though, so Option D is incorrect. The class DesertTortoise inherits two abstract methods, one from the interface CanBurrow and the other from the abstract parent class Tortoise. Since the class only implements one of them and the class is concrete, the class declaration of DesertTortoise fails to compile on line k3, making Option C the correct answer.","B. First off, the two interface definitions contain identical methods, with the public modifiers assumed in all interfaces methods. For the first statement, the write() method is marked default in both interfaces, which means a class can only implement both interfaces if the class overrides the default method with its own implementation of the method. Since the Twins method does override write(), the method compiles without issue, making the first statement incorrect. Next, the publish() method is marked static in both interfaces and the Twins class. While having a static method in all three is allowed, marking a static method with the @Override annotation is not because only member methods may be overridden. For this reason, the second statement is correct. Finally, the think() method is assumed to be abstract in both interfaces since it doesn\u2019t have a static or default modifier and does not define a body. The think() method is then correctly overridden with a concrete implementation in the Twins class, making the third statement incorrect. Since only the second statement was true, Option B is the correct answer.","D. An enum and static inner class can define static methods, making Option D the correct answer. Options A, B, and C are incorrect because the other types of inner classes cannot define static methods. Note that interfaces and abstract classes can define static methods.","C. First off, Option A does not compile since the variables p and q are reversed, making the return type of the method and usage of operators invalid. The first argument p is a String and q is an int, but the lambda expression reverses them, and the code does not compile. Option B also does not compile. The variable d is declared twice, first in the lambda argument list and then in the body of the lambda expression. The second declaration in the body of the lambda expression causes the compiler to generate a duplicate local variable message. Note that other than it being used twice, the expression is valid; the ternary operator is functionally equivalent to the learn() method in the BiologyMaterial class. Option C is the correct answer since it compiles and handles the input in the same way as the learn() method in the BiologyMaterial class. ","C. The code does not compile since it contains two compilation errors, making Option A incorrect. First, the enum list is not terminated with a semicolon (;). A semicolon (;) is required anytime an enum includes anything beyond just the list of values, such as a constructor or method. Second, the access modifier of TRUE\u2019s implementation of getNickName() is package-private, but the abstract method signature has a protected modifier. Since package-private is a more restrictive access than protected, the override is invalid and the code does not compile. For these two reasons, Option C is the correct answer. Note that the @Override annotation is optional in the method signature, therefore FALSE\u2019s version of getNickName() compiles without issue. Also, note that the Proposition constructor does not include a private access modifier, but the constructor compiles without issue. Enum constructors are assumed to be private if no access modifier is specified, unlike regular classes where package-private is assumed if no access modifier is specified.","A. The code compiles and runs without issue, printing 8 at runtime, making Option A correct and Option D incorrect. The AddNumbers interface is a valid functional interface. While it includes both static and default methods, it only includes one abstract method, the precise requirement for it to be considered a functional interface, making Option B incorrect. Finally, Option C is incorrect because the lambda expression is valid and used correctly.","A. While this code included a large number of final modifiers, none of them prevent the code from compiling when a valid expression is placed in the blank, making Option D incorrect. Option B is incorrect since it returns the size variable defined in the Insert member inner class, not the Bottle class, printing 25 at runtime. Option C is incorrect because the expression is invalid and does not compile when inserted into the blank. Finally, Option A is the correct answer because it compiles, properly references the variable size in the Bottle class, and prints 14 at runtime.","C. The main() method attempts to define an anonymous inner class instance but fails to provide the class or interface name, or use the new keyword. The right-hand side of the assignment to the seaTurtle variable should start with new CanSwim(). For this reason, Option C is the correct answer. If the code was corrected with the proper declaration, it would output 7, and Option B would be the correct answer.","D. The code does not compile, so Options A and B are incorrect. The declarations of the local inner classes Robot and Transformer compile without issue. The anonymous inner class that extends Transformer compiles without issue, since the public variable name is inherited, making Option C incorrect. The only compilation problem in this class is the last line of the main() method. The variable name is defined inside the local inner class and not accessible outside class declaration without a reference to the local inner class. Due to scope, this last line of the main() method does not compile, making Option D the correct answer. Note that the first part of the print() statement in the main() method, if the code compiled, would print GiantRobot.","B. The Dancer class compiles without issue, making Option A incorrect. The SwingDancer class, though, does not compile because getPartner() is an invalid method override. In particular, Leader and Follower are not covariant since Follower is not a subclass of Leader. Therefore, line u2 does not compile, making Option B correct and Option D incorrect. Note that the abstract method getPartner(int) is not implemented in SwingDancer, but this is valid because SwingDancer is an abstract class and is not required to implement all of the inherited abstract methods.","C. The code does not compile, so Options A and B are incorrect. The problem here is that the DEFAULT_VALUE is an instance variable, not a static variable; therefore, the static nested class GetSet cannot access it without a reference to the class. For this reason, the declaration of the static nested class GetSet does not compile, and Option C is the correct answer. The rest of the code compiles without issue. Note that if the DEFAULT_VALUE variable was modified to be static, then the code would compile without issue, and Option B would be the correct answer."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"Which of the following is required for all valid lambda expressions?",code:null,answers:["()","->","{}","Parameter data type(s)"]},{title:"What is the output of the following application?",code:'<code>package holiday;</code>\n<code>enum DaysOff {</code>\n<code>   Thanksgiving, PresidentsDay, ValentinesDay</code>\n<code>}</code>\n<code>public class Vacation {</code>\n<code>   public static void main(String... unused) {</code>\n<code>      final DaysOff input = DaysOff.Thanksgiving;</code>\n<code>      switch(input) {</code>\n<code>         default:</code>\n<code>         case DaysOff.ValentinesDay:</code>\n<code>            System.out.print("1");</code>\n<code>         case DaysOff.PresidentsDay:</code>\n<code>            System.out.print("2");</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["1","2","12","None of the above"]},{title:"Fill in the blanks: A functional interface must contain or inherit  ____________and may optionally include____________ .",code:null,answers:["at least one abstract method, the @Override annotation","exactly one method, static methods","exactly one abstract method, the @FunctionalInterface annotation","at least one static method, at most one default method"]},{title:"Which of the following class types cannot be marked final or abstract?",code:null,answers:["Static nested class","Local inner class","Anonymous inner class","Member inner class"]},{title:"Which of the following is a valid lambda expression?",code:null,answers:["r -> {return 1==2}","(q) -> true","(x,y) -> {int test; return test>0;}","a,b -> true"]},{title:"Which of the following properties of an enum can be marked abstract?",code:null,answers:["The enum class definition","An enum method","An enum value","None of the above"]},{title:"What is the output of the following application?",code:'<code>package world;</code>\n<code>public class Matrix {</code>\n<code>   private int level = 1;</code>\n<code>   class Deep {</code>\n<code>      private int level = 2;</code>\n<code>      class Deeper {</code>\n<code>         private int level = 5;</code>\n<code>         public void printReality() {</code>\n<code>            System.out.print(level);</code>\n<code>            System.out.print(" "+Matrix.Deep.this.level);</code>\n<code>            System.out.print(" "+Deep.this.level);</code>\n<code>         }</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] bots) {</code>\n<code>      Matrix.Deep.Deeper simulation = new Matrix().new Deep().new Deeper();</code>\n<code>      simulation.printReality();</code>\n<code>   }</code>\n<code>}</code>',answers:["1 1 2","5 2 2","5 2 1","The code does not compile."]},{title:"A local inner class can access which type of local variables?",code:null,answers:["I only","I and II","III only","I and III"],ol:["final","private","effectively final"]},{title:"What is the output of the following application?",code:"<code>package finance;</code>\n<code>&nbsp;</code>\n<code>enum Currency {</code>\n<code>   DOLLAR, YEN, EURO</code>\n<code>}</code>\n<code>abstract class Provider {</code>\n<code>   protected Currency c = Currency.EURO;</code>\n<code>}</code>\n<code>public class Bank extends Provider {</code>\n<code>   protected Currency c = Currency.DOLLAR;</code>\n<code>   public static void main(String[] pennies) {</code>\n<code>      int value = 0;</code>\n<code>      switch(new Bank().c) {</code>\n<code>         case 0:</code>\n<code>            value--; break;</code>\n<code>         case 1:</code>\n<code>            value++; break;</code>\n<code>      }</code>\n<code>      System.out.print(value);</code>\n<code>   }</code>\n<code>}</code>",answers:["0","1","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What statement best describes the notion of effectively final in Java?",code:null,answers:["A local variable that is marked final","A static variable that is marked final","A local variable that is not marked final but whose primitive value or object reference does not change after it is initialized","A local variable that is not marked final but whose primitive value or object reference does not change after a certain point in the method"]},{title:"What is the output of the following application?",code:"<code>package race;</code>\n<code>&nbsp;</code>\n<code>interface Drive {</code>\n<code>   int SPEED = 5;</code>\n<code>   default int getSpeed() { return SPEED; }</code>\n<code>}</code>\n<code>interface Hover {</code>\n<code>   int MAX_SPEED = 5;</code>\n<code>   default int getSpeed() { return MAX_SPEED; }</code>\n<code>}</code>\n<code>public class Car implements Drive, Hover {</code>\n<code>   public static void main(String[] gears) {</code>\n<code>      class RaceCar extends Car {</code>\n<code>         @Override public int getSpeed() { return 10; }</code>\n<code>      };</code>\n<code>      System.out.print(new RaceCar().getSpeed());</code>\n<code>   }</code>\n<code>}</code>",answers:["5","10","The code does not compile due to the definition of Racecar.","The code does not compile for some other reason."]},{title:"Fill in the blanks:  It is possible to extend an  ____________but not an ____________.",code:null,answers:["interface, abstract class","abstract class, enum","enum, interface","abstract class, interface"]},{title:"Which of the following results is not a possible output of this program?",code:"<code>package sea;</code>\n<code>enum Direction { NORTH, SOUTH, EAST, WEST; };</code>\n<code>public class Ship {</code>\n<code>   public static void main(String[] compass) {</code>\n<code>      System.out.print(Direction.valueOf(compass[0]));</code>\n<code>   }</code>\n<code>}</code>",answers:["WEST is printed.","south is printed.","An ArrayIndexOutOfBoundsException is thrown at runtime.","An IllegalArgumentException is thrown at runtime."]},{title:"Which of the following is not an advantage of using enumerated types in Java?",code:null,answers:["Ensure consistency of data across an application.","Offer ability to create new enumerated values at runtime.","Provide access to fixed constants whose value does not change during the course of the application.","Support cases where a value can only take one of a limited number of options."]},{title:"Given the following enum declaration, how many lines contain compilation errors?",code:"<code>package rainbow;</code>\n<code>enum Light {}</code>\n<code>public enum Color extends Light {</code>\n<code>   RED, BLUE, ORANGE, GREEN</code>\n<code>   protected Color() {}</code>\n<code>}</code>",answers:["None, the code compiles as is.","One","Two","Three"]},{title:"Which of the following cannot include a static method in its definition?",code:null,answers:["Abstract class","Static nested class","Interface","Local inner class"]},{title:"What is the output of the following application?",code:'<code>package ai;</code>\n<code>&nbsp;</code>\n<code>interface Pump {</code>\n<code>   void pump(double psi);</code>\n<code>}</code>\n<code>interface Bend extends Pump {</code>\n<code>   void bend(double tensileStrength);</code>\n<code>}</code>\n<code>public class Robot {</code>\n<code>   public static final void apply(Bend instruction, double input) { // r1</code>\n<code>      instruction.bend(input);</code>\n<code>   }</code>\n<code>   public static void main(String... future) {</code>\n<code>      final Robot r = new Robot();</code>\n<code>      r.apply(x -&gt; System.out.print(x+" bent!"), 5);</code>\n<code>   }</code>\n<code>}</code>',answers:["5.0 bent!","The code does not compile because Bend is not a functional interface.","The code does not compile because of line r1.","None of the above."]},{title:"What is the best reason for applying the @Override annotation to a method?",code:null,answers:["It is required to implement an interface method.","It is required to override a method.","The method will fail to compile if it is not actually overriding another method.","There are no good reasons other than as a form of documentation."]},{title:"What is the output of the following application?",code:'<code>package space;</code>\n<code>&nbsp;</code>\n<code>public class Bottle {</code>\n<code>   public static class Ship {</code>\n<code>      private enum Sail {  // w1</code>\n<code>         TALL {protected int getHeight() {return 100;}},</code>\n<code>         SHORT {protected int getHeight() {return 2;}};</code>\n<code>         protected abstract int getHeight();</code>\n<code>      }</code>\n<code>      public Sail getSail() {</code>\n<code><span epub:type="pagebreak" id="Page_212"></span>         return Sail.TALL;</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] stars) {</code>\n<code>      Bottle bottle = new Bottle();</code>\n<code>      Ship q = bottle.new Ship();  // w2</code>\n<code>      System.out.print(q.getSail());</code>\n<code>   }</code>\n<code>}</code>',answers:["TALL","The code does not compile because of line w1.","The code does not compile because of line w2.","The code compiles but the application does not produce any output at runtime."]},{title:"Which of the following is not a valid lambda expression?",code:null,answers:["(Integer j, k) -> 5","(p,q) -> p+q","(Integer x, Integer y) -> x*y",'(left,right) -> {return "null";}']},{title:"What is the output of the following application?",code:'<code>1:  package fruit;</code>\n<code>2:</code>\n<code>3:  interface Edible { void eat(); }</code>\n<code>4:  public class ApplePicking {</code>\n<code>5:     public static void main(String[] food) {</code>\n<code>6:        Edible apple = new Edible() {</code>\n<code>7:           @Override</code>\n<code>8:           void eat() {</code>\n<code>9:              System.out.print("Yummy!");</code>\n<code>10:          }</code>\n<code>11:       }</code>\n<code>12:    }</code>\n<code>13: }</code>',answers:["The application completes without printing anything.","Yummy!","One line of this application fails to compile.","Two lines of this application fail to compile."]},{title:"What is the output of the following application?",code:"<code>package forest;</code>\n<code>&nbsp;</code>\n<code>public class Woods {</code>\n<code>   static class Tree {}</code>\n<code>   public static void main(String[] leaves) {</code>\n<code>      int water = 10+5;</code>\n<code>      final class Oak extends Tree {  // p1</code>\n<code>         public int getWater() {</code>\n<code>            return water;  // p2</code>\n<code>         }</code>\n<code>      }</code>\n<code>      System.out.print(new Oak().getWater());</code>\n<code>   }</code>\n<code>}</code>",answers:["15","The code does not compile because of line p1.","The code does not compile because of line p2.","None of the above"]},{title:"Fill in the blanks:  ____________allow Java to support multiple inheritance, and anonymous inner classes can  ____________of them.",code:null,answers:["Abstract classes, extend at most one","Abstract classes, extend any number","Interfaces, implement at most one","Interfaces, implement any number"]},{title:"What is the output of the following application?",code:"<code>package vessel;</code>\n<code>&nbsp;</code>\n<code>class Problem extends Exception {}</code>\n<code>abstract class Danger {</code>\n<code>   protected abstract void isDanger() throws Problem;</code>\n<code>}</code>\n<code>public class SeriousDanger extends Danger {</code>\n<code>   protected void isDanger() throws Exception {  // m1</code>\n<code>      throw new RuntimeException();</code>\n<code>   }</code>\n<code>   public static void main(String[] will) throws Throwable {  // m2</code>\n<code>      new SeriousDanger().isDanger();  // m3</code>\n<code>   }</code>\n<code>}</code>",answers:["The code does not compile because of line m1","The code does not compile because of line m2.","The code does not compile because of line m3.","The code compiles but throws an exception at runtime."]},{title:"Which of the following is not a true statement about interfaces and abstract classes?",code:null,answers:["Interfaces can only extend other interfaces, while abstract classes can extend both abstract and concrete classes.","Unlike abstract classes, interfaces can be marked final.","Abstract classes offer support for single inheritance, while interfaces offer support for multiple inheritance.","All methods and variables in interfaces are public, while abstract classes can use\xa0various access modifiers for their methods and variables, including private in\xa0some cases."]},{title:"What is the output of the following application?",code:'<code>package weather;</code>\n<code>&nbsp;</code>\n<code>public class Forecast {</code>\n<code>   public enum Snow { BLIZZARD, SQUALL, FLURRY }</code>\n<code>   public static void main(String[] modelData) {</code>\n<code>      System.out.print(Snow.BLIZZARD.ordinal());</code>\n<code>      System.out.print(" "+Snow.valueOf("flurry".toUpperCase()).name());</code>\n<code>   }</code>\n<code>}</code>',answers:["0 FLURRY","1 FLURRY","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Fill in the blank:  The primary reason default interface methods were added to Java is to support____________ .",code:null,answers:["polymorphism","concrete methods in interfaces","multiple inheritance","backward compatibility"]},{title:"What is the output of the following application?",code:'<code>package zoo;</code>\n<code>&nbsp;</code>\n<code>public class Penguin {</code>\n<code><span epub:type="pagebreak" id="Page_215"></span>   private int volume = 1;</code>\n<code>   private class Chick {</code>\n<code>      private static int volume = 3;</code>\n<code>      void chick() {</code>\n<code>         System.out.print("Honk("+Penguin.this.volume+")!");</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String... eggs) {</code>\n<code>      Penguin pen = new Penguin();</code>\n<code>      final Penguin.Chick littleOne = pen.new Chick();</code>\n<code>      littleOne.chick();</code>\n<code>   }</code>\n<code>}</code>',answers:["Honk(1)!","Honk(3)!","The code does not compile.","The code compiles but the output cannot be determined until runtime."]},{title:"Let\u2019s say Dinosaur is a class that contains a public member inner class called Pterodactyl. Given that dino is an instance of Dinosaur, how would you instantiate a new Pterodactyl from within a static method, such as main()?",code:null,answers:["new Pterodactyl();","dino.Pterodactyl();","Dinosaur.new Pterodactyl();","dino.new Pterodactyl();"]},{title:"What is the result of compiling the following program?",code:"<code>package desert;</code>\n<code>&nbsp;</code>\n<code>interface CanBurrow {</code>\n<code>   public abstract void burrow();</code>\n<code>}</code>\n<code>@FunctionalInterface interface HasHardShell extends CanBurrow {}  // k1</code>\n<code>abstract class Tortoise implements HasHardShell {  // k2</code>\n<code>   public abstract int toughness();</code>\n<code>}</code>\n<code>public class DesertTortoise extends Tortoise {  // k3</code>\n<code>   public int toughness() { return 11; }</code>\n<code>}</code>",answers:["The code does not compile because of line k1.","The code does not compile because of line k2.","The code does not compile because of line k3.","The code compiles without issue."]},{title:"Which statement(s) about the following Twins class are true?",code:'<code>package clone;</code>\n<code>&nbsp;</code>\n<code>interface Alex {</code>\n<code>   default void write() {}</code>\n<code>   static void publish() {}</code>\n<code>   void think();</code>\n<code>}</code>\n<code>interface Michael {</code>\n<code>   public default void write() {}</code>\n<code>   public static void publish() {}</code>\n<code>   public void think();</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>public class Twins implements Alex, Michael {</code>\n<code>   @Override public void write() {}</code>\n<code>   @Override public static void publish() {}</code>\n<code>   @Override public void think() {</code>\n<code>      System.out.print("Thinking...");</code>\n<code>   }</code>\n<code>}</code>',answers:["I only","II only","I and II","II and III"],ol:["The class fails to compile because of the write() method.","The class fails to compile because of the publish() method.","The class fails to compile because of the think() method."]},{title:"Fill in the blanks:  A(n)  ____________and a(n)  ____________can define  static methods.",code:null,answers:["abstract class, local inner class","anonymous inner class, interface","member inner class, enum","enum, static inner class"]},{title:"Which lambda expression can replace the instance of new BiologyMaterial() in the  Scientist class and produce the same results under various inputted values?",code:"<code>package university;</code>\n<code>&nbsp;</code>\n<code>@FunctionalInterface interface Study {</code>\n<code>   abstract int learn(String subject, int duration);</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>class BiologyMaterial implements Study {</code>\n<code>   @Override public int learn(String subject, int duration) {</code>\n<code>      if(subject == null)</code>\n<code>         return duration;</code>\n<code>      else</code>\n<code>         return duration+1;</code>\n<code>   }</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>public class Scientist {</code>\n<code>   public static void main(String[] courses) {</code>\n<code>      final Study s = new BiologyMaterial() {};</code>\n<code>      System.out.print(s.learn(courses[0], Integer.parseInt(courses[1])));</code>\n<code>   }</code>\n<code>}</code>",answers:["(p,q) -> q==null ? p : p+1","(c,d) -> {int d=1; return c!=null ? d+1 : d;}","(x,y) -> {return x==null ? y : y+1;}","None of the above"]},{title:"Given the following enum declaration, how many lines contain compilation errors?",code:'<code>package myth;</code>\n<code>&nbsp;</code>\n<code>public enum Proposition {</code>\n<code>   TRUE(-10) { @Override String getNickName() { return "RIGHT"; }},</code>\n<code>   FALSE(-10) { public String getNickName() { return "WRONG"; }},</code>\n<code>   UNKNOWN(0) { @Override public String getNickName() { return "LOST"; }}</code>\n<code>   private final int value;</code>\n<code>   Proposition(int value) {</code>\n<code>      this.value = value;</code>\n<code>   }</code>\n<code>   public int getValue() {</code>\n<code><span epub:type="pagebreak" id="Page_218"></span>      return this.value;</code>\n<code>   }</code>\n<code>   protected abstract String getNickName();</code>\n<code>}</code>',answers:["None. The code compiles as is.","One","Two","Three"]},{title:"What is the output of the following application?",code:"<code>package math;</code>\n<code>&nbsp;</code>\n<code>interface AddNumbers {</code>\n<code>   int add(int x, int y);</code>\n<code>   static int subtract(int x, int y) { return x-y; }</code>\n<code>   default int multiply(int x, int y) { return x*y; }</code>\n<code>}</code>\n<code>public class Calculator {</code>\n<code>   protected void calculate(AddNumbers add, int a, int b) {</code>\n<code>      System.out.print(add.add(a, b));</code>\n<code>   }</code>\n<code>   public static void main(String[] moreNumbers) {</code>\n<code>      final Calculator ti = new Calculator();</code>\n<code>      ti.calculate((k,p) -&gt; p+k+1, 2, 5);  // j1</code>\n<code>   }</code>\n<code>}</code>",answers:["8","The code does not compile because AddNumbers is not a functional interface.","The code does not compile because of line j1.","None of the above"]},{title:"Given the class declaration below, what expression can be used to fill in the blank to return the size variable defined in the Bottle class, printing 14 at runtime?",code:'<code>package baby;</code>\n<code>&nbsp;</code>\n<code>final public class Bottle {</code>\n<code>   final private int size = 14;</code>\n<code>   final protected class Insert {</code>\n<code><span epub:type="pagebreak" id="Page_219"></span>      private final int size = 25;</code>\n<code>      public final int getSize() {</code>\n<code>         return_____________ ;</code>\n<code>      }</code>\n<code>   }</code>\n<code>   final Insert insert = new Insert();</code>\n<code>   final public static void main(String[] feed) {</code>\n<code>      System.out.print(new Bottle().insert.getSize());</code>\n<code>   }</code>\n<code>}</code>',answers:["Bottle.this.size","this.size","this.Bottle.size","The code does not compile, regardless of what is placed in the blank."]},{title:"What is the output of the following application?",code:"<code>package ocean;</code>\n<code>abstract interface CanSwim {</code>\n<code>   public void swim();</code>\n<code>}</code>\n<code>public class Turtle {</code>\n<code>   public static void main(String[] seaweed) {</code>\n<code>      int distance = 7;</code>\n<code>      CanSwim seaTurtle = {</code>\n<code>         @Override</code>\n<code>         public void swim() {</code>\n<code>            System.out.print(distance);</code>\n<code>         }</code>\n<code>      };</code>\n<code>      seaTurtle.swim();</code>\n<code>   }</code>\n<code>}</code>",answers:["The application completes without printing anything.","7","One line of this application fails to compile.","Two lines of this application fail to compile."]},{title:"What is the output of the following application?",code:'<code>package present;</code>\n<code>&nbsp;</code>\n<code>interface Toy { String play(); }</code>\n<code>public class Gift {</code>\n<code>   public static void main(String[] matrix) {</code>\n<code>      abstract class Robot {}</code>\n<code>      class Transformer extends Robot implements Toy {</code>\n<code>         public String name = "GiantRobot";</code>\n<code>         public String play() {return "DinosaurRobot";}</code>\n<code>      }</code>\n<code>      Transformer prime = new Transformer () {</code>\n<code>         public String play() {return name;}  // y1</code>\n<code>      };</code>\n<code>      System.out.print(prime.play()+" "+name);</code>\n<code>   }</code>\n<code>}</code>',answers:["GiantRobot GiantRobot","GiantRobot DinosaurRobot","The code does not compile because of line y1.","None of the above"]},{title:"What is the result of compiling the following program?",code:"<code>package ballroom;</code>\n<code>&nbsp;</code>\n<code>class Leader {}</code>\n<code>class Follower {}</code>\n<code>abstract public class Dancer {</code>\n<code>   public Leader getPartner() { return new Leader(); }</code>\n<code>   abstract public Leader getPartner(int count);  // u1</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>abstract class SwingDancer extends Dancer {</code>\n<code>   public Follower getPartner() {  // u2</code>\n<code>      return new Follower();  // u3</code>\n<code>   }</code>\n<code>}</code>",answers:["The code does not compile because of line u1.","The code does not compile because of line u2.","The code does not compile because of line u3.","The code compiles without issue."]},{title:"What is the output of the following application?",code:'<code>package prepare;</code>\n<code>public class Ready {</code>\n<code>   protected static int first = 2;</code>\n<code>   private final short DEFAULT_VALUE = 10;</code>\n<code>   private static class GetSet {</code>\n<code>      int first = 5;</code>\n<code>      static int second = DEFAULT_VALUE;</code>\n<code>   }</code>\n<code>   private GetSet go = new GetSet();</code>\n<code>   public static void main(String[] begin) {</code>\n<code>      Ready r = new Ready();</code>\n<code>      System.out.print(r.go.first);</code>\n<code>      System.out.print(", "+r.go.second);</code>\n<code>   }</code>\n<code>}</code>',answers:["2, 5","5, 10","The code does not compile because of the GetSet class body.","The code does not compile for another reason."]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t],ol:e.ol}});t.default=i},168:function(e,t,o){"use strict";o.r(t);var n=["C. When declaring a class that uses generics, you must specify a name for the formal type parameter. Java uses the standard rules for naming a variable or class. A question mark is not allowed in a variable name, making I incorrect. While it is common practice to use a single uppercase letter for the type parameter, this is not required. It certainly isn\u2019t a good idea to use existing class names like the News class being declared here or the Object class built into java. However, this is allowed, and Option C is correct.","B. Option A is incorrect because the filter() method is available on Stream, but not List. Option C is incorrect because the replace() method is available on List, but not Stream. Option D is tricky because there is a sort() method on List and a sorted() method on Stream. These are different method names though, so Option D is incorrect. Option B is the answer because both interfaces have a forEach() method.","A. Notice how there is unnecessary information in this description. The fact that patrons select books by name is irrelevant. The checkout line is a perfect example of a double-ended queue. We need easy access to one end of the queue for patrons to add themselves to the queue. We also need easy access to the other end of the queue for patrons to get off the queue when it is their turn. The book lookup by ISBN is a lookup by key. We need a map for this. A HashMap is probably better here, but it isn\u2019t a choice. So the answer is Option A, which does include both a double-ended queue and a map.","B. Java talks about the collections framework, but the Map interface does not actually implement the Collection interface. TreeMap has different methods than ArrayDeque and TreeSet. It cannot fill in the blank, so Option B is correct.","B. Options C and D are incorrect because the method signature is incorrect. Unlike the equals() method, the method in Comparator takes the type being compared as the parameters when using generics. Option A is a valid Comparator. However, it sorts in ascending order by length. Option B is correct. If s1 is three characters and s2 is one character, it returns -2. The negative value says that s1 should sort first, which is correct, because we want the longest String first.","D. TreeMap and TreeSet keep track of sort order when you insert elements. TreeMap sorts the keys and TreeSet sorts the objects in the set. This makes Option D correct. Note that you have the option of having JellyBean implement Comparable, or you can pass a Comparator to the constructor of TreeMap or TreeSet.","C. Option A is incorrect because a pipeline still runs if the source doesn\u2019t generate any items and the rest of the pipeline is correct. Granted some of the operations have nothing to do, but control still passes to the terminal operation. Option B is incorrect because intermediate operations are optional. Option C is the answer. The terminal operation triggers the pipeline to run.","B. The Iterator interface uses the hasNext() and next() methods to iterate. Since there is not a hasMore() method, it should be changed to hasNext(), making Option B the answer. With respect to Option A, the missing generic type gives a warning, but the code still runs. For Option C, iterators can run as many times as you want, as can the forEach() method on list.","A. First the code creates an ArrayList of three elements. Then the list is transformed into a TreeSet. Since sets are not allowed to have duplicates, the set only has two elements. Remember that a TreeSet is sorted, which means that the first element in the TreeSet is 3. Therefore, Option A is correct.","C. The word reduction is used with streams for a terminal operation, so Options A and B are incorrect. Option D describes a valid terminal operation like anyMatch(), but is not a reduction. Option C is correct because a reduction has to look at each element in the stream in order to determine the result.","A. The offer() method adds an element to the back of the queue. After line 7 completes, the queue contains 18 and 5 in that order. The push() method adds an element to the front of the queue. How rude! The element 13 pushes past everyone on the line. After line 8 completes, the queue now contains 13, 18, and 5, in that order. Then we get the first two elements from the front, which are 13 and 18, making Option A correct.","D. The Magazine class doesn\u2019t implement Comparable<Magazine>. It happens to implement the compareTo() method properly, but it is missing actually writing implements Comparable. Since TreeSet doesn\u2019t look to see if the object can be compared until runtime, this code throws a ClassCastException when TreeSet calls add(), so Option D is correct.","C. Line 8 does not compile. String::new is a constructor reference. A constructor or method reference is equivalent to a lambda. It participates in deferred execution. When it is executed later, it returns a String. It does not return a String on line 8. It actually returns a Supplier<String>, which cannot be stored in list. Since the code does not compile, Option C is correct.","B. This code adds two elements to a list. It then gets a stream and iterates through the list, printing two lines. The last line does the same thing again. Since a fresh stream is created, we are allowed to iterate through it, and Option B is correct.","D. The Comic interface declares a formal type parameter. This means that a class implementing it needs to specify this type. The code on line 21 compiles because the lambda reference supplies the necessary context making Option A incorrect. Option B declares a generic class. While this doesn\u2019t tell us the type is Snoopy, it punts the problem to the caller of the class. The declaration of c2 on line 22 compiles because it supplies the type, making Option B incorrect. The code on line 23 compiles because the SnoopyClass itself supplies the type making Option C incorrect. Option D has a problem. SnoopyClass and SnoopyComic appear similar. However, SnoopyComic refers to C. This type parameter exists in the interface. It isn\u2019t available in the class because the class has said it is using Snoopy as the type. Since the SnoopyComic class itself doesn\u2019t compile, the line with c4 can\u2019t instantiate it, and Option D is the answer.","A. In streams, the filter() method filters out any values that do not match. This means the only value to make it to the terminal operator count() is Chicago, and Option A is correct.","C. When implementing Comparable, you implement the compareTo() method. Since this is an instance method, it already has a reference to itself and only needs the item it is comparing. Only one parameter is specified, and Option C is correct. By contrast, the Comparator interface uses the compare() method and the method takes two parameters.","C. The source and any intermediate operations are chained and eventually passed to the terminal operation. The terminal operation is where a non-stream result is generated, making Option C correct.","A. A constructor reference uses the new keyword where a method name would normally go in a method reference. It can implicitly take zero or one parameters just like a method reference. In this case, we have one parameter, which gets passed to the constructor. Option A is correct.","D. A custom sort order is specified using a Comparator to sort in descending order. However, this Comparator is not passed when searching. When a different sort order is used for searching and sorting, the result is undefined. Therefore, Option D is correct.","D. Java only allows you to operate on a stream once. The final line of code throws an IllegalStateException because the stream has already been used up. Option D is the correct answer.","D. The Wash class takes a formal type parameter named T. Option C shows the best way to call it. This option declares a generic reference type that specifies the type is String. It also uses the diamond syntax to avoid redundantly specifying the type on the right-hand side of the assignment. Options A and B show that you can omit the generic type in the reference and still have the code compile. You do get a compiler warning scolding you for having a raw type. But compiler warnings do not prevent compilation. With the raw type, the compiler treats T as if it is of type Object. That is OK in this example because the only method we call is toString() implicitly when printing the value. Since toString() is defined on the Object class, we are safe, and Options A and B work. Since all three can fill in the blank, Option D is the answer.","D. The missing generic type gives a warning, but the code still runs, so Option A is incorrect. The Iterator interface uses hasNext() and next() methods to iterate, so Option B is incorrect. Option C applies to calling the same stream twice. One of our calls is to an Iterator anyway, so Option C is incorrect. This code is in fact correct, making the answer Option D.","B. This is a static method reference. It uses :: to separate the class name and method name. Option B is correct.","B. A source and the terminal operation are required parts of a stream pipeline and must occur exactly once. The intermediate operation is optional. It can appear zero or more times. Since more than once falls within zero or more, Option B is correct.","B. ArrayList allows null elements, making Option B correct. TreeSet does not allow nulls because they need to compare the values. ArrayDeque uses null for a special meaning, so it doesn\u2019t allow it in the data structure either.","D. Option A is the only one of the three options to compile. However, it results in no lines being output since none of the three strings are empty. Options B and C do not even compile because a method reference cannot have an operator next to it. Therefore, Option D is correct.","A. Unfortunately you do have to memorize two facts about sort order. First, numbers sort before letters. Second, uppercase sorts before lowercase. Since TreeMap orders by key, the first key is 3 and the last is three, making Option A correct.","C. The ? is an unbounded wildcard. It is used in variable references but is not allowed in declarations. In a static method, the type parameter specified inside the <> is used in the rest of the variable declaration. Since it needs an actual name, Options A and B are incorrect. We need to specify a type constraint so we can call the add() method. Regardless of whether the type is a class or interface, Java uses the extends keyword for generics. Therefore, Option D is incorrect, and Option C is the answer.","B. On a stream, the filter() method only keeps values matching the lambda. The removeIf() does the reverse on a Collection and keeps the elements that do not match. In this case, that is Austin and Boston so Option B is correct.","D. The code correctly creates an ArrayDeque with three elements. The stream pipeline does compile. However, there is no terminal operation, which means the stream is never evaluated and the output is something like java.util.stream.ReferencePipeline$2@404b9385. This is definitely not one of the listed choices, so Option D is correct.","C. The forEach() method that takes one parameter is defined on the Collection interface. However, a map is not a Collection. There is a version of forEach() defined on the Map interface, but it uses two parameters. Since two parameters can\u2019t be used with a method reference, Option C is the answer.","C. This code is almost correct. Calling two different streams is allowed. The code attempts to use a method reference when calling the forEach() method. However, it does not use the right syntax for a method reference. A double colon needs to be used. The code would need to be changed to System.out::println to work and print two lines for each call. Since it does not compile, Option C is correct.","B. This code shows a proper implementation of Comparable. It has the correct method signature. It compares the magazine names in alphabetical order. Remember that uppercase letters sort before lowercase letters. Since Newsweek is uppercase, Option B is correct.","C. The filter() method requires a boolean returned from the lambda or method reference. The getColor() method returns a String and is not compatible. This causes the code to not compile and Option C to be correct.","A. Option A is correct as the source and terminal operation are mandatory parts of a stream pipeline. Option B is incorrect because a Stream must return non-primitives. Specialized interfaces like IntStream are needed to return primitives. Option C is incorrect because Stream has methods such as of() and iterate() that return a Stream. Option D is incorrect because infinite streams are possible.","B. The stream pipeline is correct and filters all values out that are 10 characters or smaller. Only San Francisco is long enough, so c is 1. The stream() call creates a new object, so stream operations do not affect the original list. Since the original list is still 3 elements, Option B is correct.","B. Options A and C are incorrect because a generic type cannot be assigned to another direct type unless you are using upper or lower bounds in that statement. Now, we just have to decide whether a lower or upper bound is correct for the T formal type parameter in Wash. The clue is that the method calls size(). This method is available on Collection and all classes that extend/implement it. Therefore, Option B is correct.","C. A Comparator takes two parameters, so Options A and B are incorrect. Option D doesn\u2019t compile. When using brackets, a return keyword and semicolon are required. Option C is a correct implementation.","B. Option D is incorrect because there is a charAt() instance method. While Option C is correct that the method takes in an int parameter, autoboxing would take care of conversion for us if there were no other problems. So Option C is not the answer. Option A is not true because there are constructor and instance method references. Option B is the answer. With method references, only one item can be supplied at runtime. Here, we need either a String instance with no parameters in the method or a static method with a single parameter. The charAt() method is an instance method with a single parameter so does not meet this requirement."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"Which of the following can fill in the blank to make the code compile?",code:"<code>public class News&lt;________&gt; {}</code>",answers:["None of them","I","II and III","I, II, and III"],ol:["?","News","Object"]},{title:"Which method is available on both List and Stream implementations?",code:null,answers:["filter()","forEach()","replace()","sort()"]},{title:"We are running a library. Patrons select books by name. They get at the back of the checkout line. When they get to the front, they scan the book\u2019s ISBN. The checkout system finds the book based on this number and marks the book as checked out. Of these choices, which data structures best represent the line to check out the book and the book lookup to mark it as checked out, respectively?",code:null,answers:["ArrayDeque, TreeMap","ArrayDeque, TreeSet","ArrayList, TreeMap","ArrayList, TreeSet"]},{title:"Which cannot fill in the blank for this code to compile?",code:'<code>Collection&lt;String&gt; c = new ____________&lt;&gt;();</code>\n<code>c.add("pen");</code>\n<code>c.remove("pen");</code>\n<code>System.out.println(c.isEmpty());</code>',answers:["ArrayDeque","TreeMap","TreeSet","All of these can fill in the blank."]},{title:"Suppose we want to implement a Comparator<String> so that it sorts the longest strings first. You may assume there are no nulls. Which method could implement such a comparator?",code:null,answers:["\n\n\xa0 \n\npublic int compare(String s1, String s2) { \n\n   return s1.length() - s2.length(); \n\n}\n","\n\n\xa0 \n\npublic int compare(String s1, String s2) { \n\n   return s2.length() \u2013 s1.length(); \n\n}\n","\n\n\xa0 \n\npublic int compare(Object obj1, object obj2) { \n\n   String s1 = (String) obj1; \n\n   String s2 = (String) obj2; \n\n   return s1.length() - s2.length(); \n\n}\n","\n\n\xa0 \n\npublic int compare(Object obj1, object obj2) { \n\n   String s1 = (String) obj1; \n\n   String s2 = (String) obj2; \n\n   return s2.length() \u2013 s1.length(); \n\n}\n"]},{title:"Suppose we want to store JellyBean objects. Which of the following pairs require  JellyBean to implement the Comparable interface or create a Comparator in order to add them to the Collection?",code:null,answers:["ArrayList and ArrayDeque","HashMap and HashSet","HashMap and TreeMap","TreeMap and TreeSet"]},{title:"What is a common reason for a stream pipeline not to run?",code:null,answers:["The source doesn\u2019t generate any items.","There are no intermediate operations.","The terminal operation is missing.","None of the above"]},{title:"We want this code to print the titles of each book twice. Why doesn\u2019t it?",code:'<code>LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();</code>\n<code>list.add("Grapes of Wrath");</code>\n<code>list.add("1984");</code>\n<code>&nbsp;</code>\n<code>list.forEach(System.out::println);</code>\n<code>&nbsp;</code>\n<code>Iterator it = list.iterator();</code>\n<code>while (it.hasMore())</code>\n<code>  System.out.println(it.next());</code>',answers:["The generic type of Iterator is missing.","The hasMore() method should be changed to hasNext().","The iteration code needs to be moved before the forEach() since the stream is used up.","None of the above. The code does print each book title twice."]},{title:"What is the result of the following?",code:'<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code>\n<code>list.add(56);</code>\n<code>list.add(56);</code>\n<code>list.add(3);</code>\n<code>&nbsp;</code>\n<code>TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(list);</code>\n<code>System.out.print(set.size());</code>\n<code>System.out.print(" " );</code>\n<code>System.out.print(set.iterator().next());</code>',answers:["2 3","2 56","3 3","3 56"]},{title:"What best describes a reduction?",code:null,answers:["An intermediate operation where it filters the stream it receives","An intermediate operation where it mathematically divides each element in the stream","A terminal operation where a single value is generated by reading each element in the prior step in a stream pipeline","A terminal operation where one element is returned from the prior step in a stream pipeline without reading all the elements"]},{title:"What is the output of the following?",code:'<code>5:   ArrayDeque&lt;Integer&gt; d = new ArrayDeque&lt;&gt;();</code>\n<code>6:   d.offer(18);</code>\n<code>7:   d.offer(5);</code>\n<code>8:   d.push(13);</code>\n<code>9:   System.out.println(d.poll() + " " + d.poll());</code>',answers:["13 18","18 5","18 13","None of the above"]},{title:"What is the output of the following?",code:'<code>class Magazine {</code>\n<code>   private String name;</code>\n<code>   public Magazine(String name) {</code>\n<code>      this.name = name;</code>\n<code>   }</code>\n<code>   public int compareTo(Magazine m) {</code>\n<code>      return name.compareTo(m.name);</code>\n<code>   }</code>\n<code>   public String toString() {</code>\n<code>      return name;</code>\n<code>   }</code>\n<code>}</code>\n<code>public class Newstand {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Set&lt;Magazine&gt; set = new TreeSet&lt;&gt;();</code>\n<code>      set.add(new Magazine("highlights"));</code>\n<code>      set.add(new Magazine("Newsweek"));</code>\n<code>      set.add(new Magazine("highlights"));</code>\n<code>      System.out.println(set.iterator().next());</code>\n<code>   }</code>\n<code>}</code>',answers:["highlights","Newsweek","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What is the result of the following?",code:'<code>6:   List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>\n<code>7:   list.add("Monday");</code>\n<code>8:   list.add(String::new);</code>\n<code>9:   list.add("Tuesday");</code>\n<code>10:  list.remove(0);</code>\n<code>11:  System.out.println(list.get(0));</code>',answers:["An empty String","Monday","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"How many lines does this code output?",code:'<code>List&lt;String&gt; list = new LinkedList&lt;&gt;();</code>\n<code>list.add("Archie");</code>\n<code>list.add("X-Men");</code>\n<code>&nbsp;</code>\n<code>list.stream().forEach(s -&gt; System.out.println(s));</code>\n<code>list.stream().forEach(s -&gt; System.out.println(s));</code>',answers:["Two","Four","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which line in the main() method doesn\u2019t compile or points to a class that doesn\u2019t compile?",code:'<code>1:   interface Comic&lt;C&gt; {</code>\n<code>2:      void draw(C c);</code>\n<code>3:   }</code>\n<code>4:   class ComicClass&lt;C&gt; implements Comic&lt;C&gt; {</code>\n<code>5:      public void draw(C c) {</code>\n<code>6:         System.out.println(c);</code>\n<code>7:      }</code>\n<code>8:   }</code>\n<code>9:   class SnoopyClass implements Comic&lt;Snoopy&gt; {</code>\n<code>10:     public void draw(Snoopy c) {</code>\n<code>11:        System.out.println(c);</code>\n<code><span epub:type="pagebreak" id="Page_229"></span>12:     }</code>\n<code>13:  }</code>\n<code>14:  class SnoopyComic implements Comic&lt;Snoopy&gt; {</code>\n<code>15:     public void draw(C c) {</code>\n<code>16:        System.out.println(c);</code>\n<code>17:     }</code>\n<code>18:  }</code>\n<code>19:  public class Snoopy {</code>\n<code>20:     public static void main(String[] args) {</code>\n<code>21:       Comic&lt;Snoopy&gt; c1 = c \u2010&gt; System.out.println(c);</code>\n<code>22:       Comic&lt;Snoopy&gt; c2 = new ComicClass&lt;&gt;();</code>\n<code>23:       Comic&lt;Snoopy&gt; c3 = new SnoopyClass();</code>\n<code>24:       Comic&lt;Snoopy&gt; c4 = new SnoopyComic();</code>\n<code>25:     }</code>\n<code>26:  }</code>',answers:["Line 21","Line 22","Line 23","Line 24"]},{title:"What is the output of the following?",code:'<code>Stream&lt;String&gt; s = Stream.of("Atlanta", "Chicago", "New York");</code>\n<code>long count = s.filter(c -&gt; c.startsWith("C")).count();</code>\n<code>System.out.print(count);</code>',answers:["1","2","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Fill in the blank to make this code compile:",code:'<code>public class Truck implements Comparable&lt;Truck&gt; {</code>\n<code>   private int id;</code>\n<code>   public Truck(int id) {</code>\n<code>      this.id = id;</code>\n<code>   }</code>\n<code>   @Override</code>\n<code>      ____________________ {</code>\n<code><span epub:type="pagebreak" id="Page_230"></span>      return id - t.id;</code>\n<code>   }</code>\n<code>}</code>',answers:["public int compare(Truck t)","public int compare(Truck t1, Truck t2)","public int compareTo(Truck t)","public int compareTo(Truck t1, Truck t2)"]},{title:"In a stream pipeline, which can return a value other than a Stream?",code:null,answers:["Source","Intermediate operation","Terminal operation","None of the above"]},{title:"Rewrite this lambda using a constructor reference:",code:"<code>n -&gt; new ArrayList&lt;&gt;(n)</code>",answers:["ArrayList::new;","ArrayList::new();","ArrayList::new(n);","ArrayList::new[n];"]},{title:"What is the result of the following?",code:"<code>Comparator&lt;Integer&gt; c = (x, y) \u2010&gt; y\u2010x;</code>\n<code>List&lt;Integer&gt; ints = Arrays.asList(3, 1, 4);</code>\n<code>Collections.sort(ints, c);</code>\n<code>System.out.println(Collections.binarySearch(ints, 1));</code>",answers:["0","1","The code does not compile.","The result is not defined."]},{title:"How many lines does this code output?",code:'<code>List&lt;String&gt; list = new LinkedList&lt;&gt;();</code>\n<code>list.add("Archie");</code>\n<code>list.add("X-Men");</code>\n<code>&nbsp;</code>\n<code>Stream&lt;String&gt; s = list.stream();</code>\n<code>s.forEach(System.out::println);</code>\n<code>s.forEach(System.out::println);</code>',answers:["Two","Four","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which option cannot fill in the blank to print Clean socks?",code:'<code>class Wash&lt;T&gt; {</code>\n<code>   T item;</code>\n<code>   public void clean(T item) {</code>\n<code>      System.out.println("Clean " + item);</code>\n<code>   }</code>\n<code>}</code>\n<code>public class LaundryTime {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      ________________________</code>\n<code>      wash.clean("socks");</code>\n<code>   }</code>\n<code>}</code>',answers:["Wash wash = new Wash();","Wash wash = new Wash<String>();","Wash<String> wash = new Wash<>();","All three can fill in the blank."]},{title:"We want this code to print the titles of each book twice. Why doesn\u2019t it?",code:'<code>LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();</code>\n<code>list.add("Grapes of Wrath");</code>\n<code>list.add("1984");</code>\n<code>&nbsp;</code>\n<code>list.stream().forEach(System.out::println);</code>\n<code>&nbsp;</code>\n<code>Iterator it = list.iterator();</code>\n<code>while (it.hasNext())</code>\n<code>   System.out.println(it.next());</code>',answers:["The generic type of Iterator is missing.","The hasNext() method should be changed to isNext().","The iteration code needs to be moved before the forEach() since the stream is used up.","None of the above. The code does print each book title twice."]},{title:"Rewrite this lambda using a method reference:",code:"<code>() -&gt; Math.random()</code>",answers:["Math.random","Math::random","Math::random()","None of the above"]},{title:"Which operation can occur more than once in a stream pipeline?",code:null,answers:["Source","Intermediate operation","Terminal operation","None of the above"]},{title:"Which type allows inserting a null value?",code:null,answers:["ArrayDeque","ArrayList","TreeSet","All of these allow nulls."]},{title:"Fill in the blank so this code outputs three lines:",code:'<code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>\n<code>list.add("Atlanta");</code>\n<code>list.add("Chicago");</code>\n<code>list.add("New York");</code>\n<code>&nbsp;</code>\n<code>list.stream().filter(____________).forEach(System.out::println);</code>',answers:["String::isEmpty","! String::isEmpty","String::! isEmpty","None of the above"]},{title:"What is the output of the following?",code:'<code>TreeMap&lt;String, Integer&gt; map = new TreeMap&lt;&gt;();</code>\n<code>map.put("3", 3);</code>\n<code>map.put("three", 3);</code>\n<code><span epub:type="pagebreak" id="Page_233"></span>map.put("THREE", 3);</code>\n<code>System.out.println(map.firstKey() + " " + map.lastKey());</code>',answers:["3 three","3 THREE","three 3","THREE 3"]},{title:"Which fills in the blank in the method signature to allow this code to compile?",code:'<code>import java.util.*;</code>\n<code>public class ExtendingGenerics {</code>\n<code>   private static &lt;_____________ , U&gt; U add(T list, U element) {</code>\n<code>      list.add(element);</code>\n<code>      return element;</code>\n<code>   }</code>\n<code>   public static void main(String[] args) {</code>\n<code>      List&lt;String&gt; values = new ArrayList&lt;&gt;();</code>\n<code>      add(values, "duck");</code>\n<code>      add(values, "duck");</code>\n<code>      add(values, "goose");</code>\n<code>      System.out.println(values);</code>\n<code>   }</code>\n<code>}</code>\n<code>&nbsp;</code>',answers:["? extends Collection<U>","? implements Collection<U>","T extends Collection<U>","T implements Collection<U>"]},{title:"What is the result of the following?",code:'<code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>\n<code>list.add("Austin");</code>\n<code>list.add("Boston");</code>\n<code>list.add("San Francisco");</code>\n<code>&nbsp;</code>\n<code>list.removeIf(a -&gt; a.length() &gt; 10);</code>\n<code>System.out.println(list.size());</code>',answers:["1","2","3","None of the above"]},{title:"What does the following output?",code:"<code>ArrayDeque&lt;Integer&gt; dice = new ArrayDeque&lt;&gt;();</code>\n<code>dice.offer(3);</code>\n<code>dice.offer(2);</code>\n<code>dice.offer(4);</code>\n<code>System.out.print(dice.stream().filter(n -&gt; n != 4));</code>",answers:["2","3","The code does not compile.","None of the above"]},{title:"Which of the following cannot fill in the blank to make the code compile?",code:"<code>private void output(____________&lt;?&gt; x) {</code>\n<code>   x.forEach(System.out::println);</code>\n<code>}</code>",answers:["ArrayDeque","Collection","TreeMap","None of the above"]},{title:"How many lines does this code output?",code:'<code>List&lt;String&gt; list = new LinkedList&lt;&gt;();</code>\n<code>list.add("Archie");</code>\n<code>list.add("X-Men");</code>\n<code>&nbsp;</code>\n<code>list.stream().forEach(System.out.println);</code>\n<code>list.stream().forEach(System.out.println);</code>',answers:["Two","Four","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What is the output of the following?",code:'<code>class Magazine implements Comparable&lt;Magazine&gt; {</code>\n<code>   private String name;</code>\n<code>   public Magazine(String name) {</code>\n<code>      this.name = name;</code>\n<code>   }</code>\n<code>   @Override</code>\n<code>   public int compareTo(Magazine m) {</code>\n<code><span epub:type="pagebreak" id="Page_235"></span>      return name.compareTo(m.name);</code>\n<code>   }</code>\n<code>   @Override</code>\n<code>   public String toString() {</code>\n<code>      return name;</code>\n<code>   }</code>\n<code>}</code>\n<code>public class Newstand {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Set&lt;Magazine&gt; set = new TreeSet&lt;&gt;();</code>\n<code>      set.add(new Magazine("highlights"));</code>\n<code>      set.add(new Magazine("Newsweek"));</code>\n<code>      set.add(new Magazine("highlights"));</code>\n<code>      System.out.println(set.iterator().next());</code>\n<code>   }</code>\n<code>}</code>',answers:["highlights","Newsweek","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"How many lines does the following code output?",code:'<code>import java.util.*;</code>\n<code>class Blankie {</code>\n<code>   String color;</code>\n<code>   String getColor() {</code>\n<code>      return color;</code>\n<code>   }</code>\n<code>}</code>\n<code>public class PreSchool {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Blankie b1 = new Blankie();</code>\n<code>      Blankie b2 = new Blankie();</code>\n<code>      b1.color = "pink";</code>\n<code>      List&lt;Blankie&gt; list = Arrays.asList(b1, b2);</code>\n<code>      list.stream().filter(Blankie::getColor).forEach(System.out::println);</code>\n<code>   }</code>\n<code>}</code>',answers:["One","Two","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which statement about a source in a Stream is true?",code:null,answers:["The source is mandatory in a stream pipeline.","The source is only allowed to return primitives.","The source must be retrieved by calling the stream() method.","The source must return a finite number of elements."]},{title:"What does the following output?",code:'<code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>\n<code>list.add("Austin");</code>\n<code>list.add("Boston");</code>\n<code>list.add("San Francisco");</code>\n<code>&nbsp;</code>\n<code>long c = list.stream().filter(a -&gt; a.length() &gt; 10).count();</code>\n<code>System.out.println(c + " " + list.size());</code>',answers:["1 1","1 3","2 3","None of the above"]},{title:"Which options can fill in the blanks to print Cleaned 2 items?",code:'<code>import java.util.*;</code>\n<code>class Wash&lt;T  ____________ Collection&gt; {</code>\n<code>   T item;</code>\n<code>   public void clean(T items) {</code>\n<code>      System.out.println("Cleaned " + items.size() + " items");</code>\n<code>   }</code>\n<code>}</code>\n<code>public class LaundryTime {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Wash&lt;List&gt; wash = new ____________</code>\n<code>      wash.clean(Arrays.asList("sock", "tie"));   }</code>\n<code>}</code>',answers:["extends, Wash<ArrayList>();","extends, Wash<List>();","super, Wash<ArrayList>();","super, Wash<List>();"]},{title:"Which of the following declares a Comparator where all objects are treated as equal?",code:null,answers:["Comparator<Character> comp = (c1)-> 0;","Comparator<Character> comp = (c1)-> {0};","Comparator<Character> comp = (c1, c2)-> 0;","Comparator<Character> comp = (c1, c2)-> {0};"]},{title:"Why can\u2019t String::charAt be used as a method reference?",code:null,answers:["Method references can only be used on static methods.","Method references can pass either the instance or the parameter from the lambda, but not both.","The charAt() method takes an int rather than Integer parameter.","There is no charAt() method in the String class."]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t],ol:e.ol}});i[24].imageUrl="./images/image-ocp-ch13-25.png",t.default=i},169:function(e,t,o){"use strict";o.r(t);var n=["C. The Supplier functional interface does not take any inputs, while the Consumer functional interface does not return any data. This behavior extends to the primitive versions of the functional interfaces, making Option C the correct answer. Option A is incorrect because IntConsumer takes a value, while LongSupplier returns a value. Options B and D are incorrect because Function and UnaryOperator both take an input and produce a value. ","A. The LongSupplier interface does not take any input, making Option D incorrect. It also uses the method name getAsLong(). The rest of the functional interfaces all take a long value but vary on the name of the abstract method they use. LongFunction contains apply() and LongPredicate contains test(), making Options B and C, respectively, incorrect. That leaves us with LongConsumer, which contains accept(), making Option A the correct answer.","A. The code compiles without issue, so Options C and D are incorrect. The value for distance is 2, which based on the lambda for the Predicate will result in a true expression, and Saved will be printed, making Option A correct.","C. Both are functional interfaces in the java.util.function package, making Option A true. The major difference between the two is that Supplier<Double> takes the generic type Double, while the other does not take any generic type and instead uses the primitive double. For this reason, Options B and D are true statements. For Supplier<Double> in Option B, remember that the returned double value can be implicitly cast to Double. Option C is the correct answer. Lambdas for Supplier<Double> can return a null value since Double is an object type, while lambdas for DoubleSupplier cannot; they can only return primitive double values.","B. The lambda (s,p) -> s+p takes two arguments and returns a value. For this reason, Option A is incorrect because BiConsumer does not return any values. Option D is also incorrect, since Function only takes one argument and returns a value. This leaves us with Options B and C, which both use BiFunction, which takes two generic arguments and returns a generic value. Option C is incorrect because the datatype of the unboxed sum s+q is int and int cannot be autoboxed or implicitly cast to Double. Option B is correct. The sum s+p is of type double, and double can be autoboxed to Double.","C. To begin with, ToDoubleBiFunction<T,U> takes two generic inputs and returns a double value. Option A is compatible because it takes an Integer and Double and returns a Double value that can be implicitly unboxed to double. Option B is compatible because long can be implicitly cast to double. While we don\u2019t know the data types for the input arguments, we know that some values, such as using Integer for both, will work. Option C cannot be assigned and is the correct answer because the variable v is of type Object and Object does not have a length() method. Finally, Option D is compatible. The variable y could be declared double in the generic argument to the functional interface, making y/z a double return value.","C. The BiPredicate interface takes two generic arguments and returns a boolean value. Next, DoubleUnaryOperator takes a double argument and returns a double value. Last, ToLongFunction takes a generic argument and returns a long value. That leaves Option C, which is the correct answer. While there is an ObjDoubleConsumer functional interface, which takes a generic argument and a double value and does not return any data, there is no such thing as ObjectDoubleConsumer. Remember that Object is abbreviated to Obj in all functional interfaces in java.util.function.","C. The code does not compile, so Options A and D are incorrect. The IntUnaryOperator functional interface is not generic, so the argument IntUnaryOperator<Integer> in the takeTicket() does not compile, making Option C the correct answer. The lambda expression compiles without issue, making Option B incorrect. If the generic argument <Integer> was dropped from the argument declaration, the class would compile without issue and output 51 at runtime, making Option A the correct answer.","A. Option A is the correct answer because BiPredicate takes two generic types and returns a primitive boolean value. Option B is incorrect, since CharSupplier does not exist in java.util.function. Option C is also incorrect, since LongFunction takes a primitive long value and returns a generic type. Remember, Java only includes primitive functional interfaces that operate on double, int, or long. Finally, Option D is incorrect. UnaryOperator takes a generic type and returns a generic value.","D. First off, the forEach() method requires a Consumer instance. Option C can be immediately discarded because Supplier<Double> does not inherit Consumer. For this same reason, Option B is also incorrect. DoubleConsumer does not inherit from Consumer. In this manner, primitive functional interfaces cannot be used in the forEach() method. Option A seems correct, since forEach() does take a Consumer instance, but it is missing a generic argument. Without the generic argument, the lambda expression does not compile because the expression p<5 cannot be applied to an Object. The correct functional interface is Consumer<Double>, and since that is not available, Option D is the correct answer.","C. BiFunction<Double,Double,Double> and BinaryOperator<Double> both take two Double input arguments and return a Double value, making them equivalent to one another. On the other hand, DoubleFunction<Double> takes a single double value and returns a Double value. For this reason, it is different from the other two, making Option C correct and Option D incorrect.","B. BinaryOperator<Long> takes two Long arguments and returns a Long value. For this reason, Option A, which takes one argument, and Option D, which takes two Integer values that do not inherit from Long, are both incorrect. Option C is incorrect because the local variable c is re-declared inside the lambda expression, causing the expression to fail to compile. The correct answer is Option B because intValue() can be called on a Long object. The result can then be cast to long, which is autoboxed to Long.","C. The program does not compile, so Option A is incorrect. The Supplier functional interface normally takes a generic argument, although generic types are not strictly required since they are removed by the compiler. Therefore, line d1 compiles while triggering a compiler warning, and Options B and D are incorrect. On the other hand, line d2 does cause a compiler error, because the lambda expression does not return a value. Therefore, it is not compatible with Supplier, making Option C the correct answer.","A. The input type of a unary function must be compatible with the return type. By compatible, we mean identical or able to be implicitly cast. For this reason, Option A is the correct answer. Option B is incorrect since all of the UnaryOperator functional interfaces, generic or primitive, take exactly one value. Option C is incorrect because the primitive functional interfaces do not take a generic argument. Finally, Option D is incorrect. For example, the generic UnaryOperator<T> returns an Object that matches the generic type.","C. Remember that all Supplier interfaces take zero parameters. For this reason, the third value in the table is 0, making Options A and B incorrect. Next, DoubleConsumer and IntFunction each take one value, double and int, respectively. On the other hand, ObjDoubleConsumer takes two values, a generic value and a double, and returns void. For this reason, Option C is correct, and Option D is incorrect.","D. All Consumer functional interfaces have a void return type. For this reason, the first and last values in the table are both void, making Options A and B incorrect. IntFunction takes an int and returns a generic value, while LongSupplier does not take any values and returns a long value. For this reason, Option C is incorrect, and Option D is correct.","B. The removeIf() method requires a Predicate since it operates on a boolean result, making Option A incorrect. The forEach() method takes a Consumer and does not return any data, making Option B correct, and Options C and D incorrect.","C. The code does not compile, so Option A is incorrect. The lambda expression compiles without issue, making Option B incorrect. The task variable is of type UnaryOperator<Doll>, with the abstract method apply(). There is no accept() method defined on that interface, therefore the code does not compile, and Option C is the correct answer. If the code was corrected to use the apply() method, the rest of it would compile without issue. At runtime, it would then produce an infinite loop. On each iteration of the loop, a new Doll instance would be created with 5, since the post-decrement (--) operator returns the original value of the variable, and that would make Option D the correct answer.","C. To begin with, Consumer uses accept(), making Option A incorrect. Next, Function and UnaryOperator use apply(), making Options B and D, respectively, incorrect. Finally, Supplier uses get(), making Option C the correct answer.","D. First off, Options A and B are incorrect because the second functions for both return a double or Double value, respectively. Neither of these values can be sent to a UnaryOperator<Integer> without an explicit cast. Next, Option C is incorrect. The first functional interface Function<Double,Integer> takes only one input, but the diagram shows two inputs for the first functional interface. That leaves us with Option D. The first functional interface BiFunction<Integer,Double,Integer> takes an int, which can be implicitly autoboxed to Integer, and a Double and returns an Integer. The next functional interface, BinaryOperator<Integer>, takes two Integer values and returns an Integer value. Finally, this Integer value can be implicitly unboxed and sent to IntUnaryOperator, returning an int. Since these behaviors match our diagram, Option D is the correct answer.","D. Options A, B, and C are true statements about functional interfaces. A lambda may be compatible with multiple functional interfaces, but it must be assigned to a functional interface when it is declared or passed as a method argument. Also, a method can be created with the return type that matches a functional interface, allowing a lambda expression to be returned. Option D is the correct answer. Deferred execution means the lambda expression is not evaluated until runtime, but it is compiled. Compiler errors in the lambda expression will prevent the code from compiling.",'B. Option A is incorrect because the String "3" is not compatible with the return type int required for IntSupplier. Option B is the correct answer. Although this will result in a divide by zero issue at runtime, the lambda is valid and compatible with IntSupplier. Option C is incorrect because the lambda expression is invalid. The return statement is only allowed inside a set of brackets {}. Finally, Option D is incorrect. The method reference is used for Supplier, not Consumer, since it takes a value and does not return anything.',"C. The lambda expression is invalid because the input argument is of type Boss, and Boss does not define an equalsIgnoreCase() method, making Option C the correct answer. If the lambda was corrected to use s.getName() instead of s, the code would compile and run without issue, printing [JENNY, GRACE] at runtime and making Option A the correct answer.","D. First of all, Consumer<Object> takes a single Object argument and does not return any data. The classes ArrayList and String do not contain constructors that take an Object, so neither of the first two statements are correct. The third statement does support an Object variable, since the System.out.println(Object) method exists. For these reasons, Option D is the correct answer.","B. The java.util.function package does not include any functional interfaces that operate on the primitive float, making Option A incorrect. Remember, Java only includes primitive functional interfaces that operate on double, int, or long. Option B is correct because it is a valid functional interface. Option C is incorrect because there is no UnaryIntOperator functional interface. Note that there is one called IntUnaryOperator. Option D is incorrect. The java.util.function package does not include any tri- operators, although many are easy to write.","D. A lambda expression can match multiple functional interfaces. It matches DoubleUnaryOperator, which takes a double value and returns a double value. Note that the data type of s+1 is double because one of the operands, in this case s, is double. It also matches Function<String,String> since the (+) operator can be used for String concatenation. Finally, it matches IntToLongFunction since the int value s+1can be implicitly cast to long. On the other hand, the lambda expression is not compatible with UnaryOperator without a generic type. When UnaryOperator is used without a generic argument, the type is assumed to be Object. Since the (+) operator is not defined on Object, the code does not compile due to the lambda expression body, making Option D the correct answer. Note that if the lambda expression did not rely on the (+) operator, such as s -> s, then UnaryOperator would be allowed by the compiler, even without a generic type.","B. The BiFunction interface takes two different generic values and returns a generic value, taking a total of three generic arguments. Next, ToDoubleFunction takes exactly one generic value and returns a double value, requiring one generic argument. The ToIntBiFunction interface takes two generic values and returns an int value, for a total of two generic arguments. For these reasons, Options A, C, and D are incorrect. The correct answer is Option B. DoubleFunction takes a double value and returns a generic result, taking exactly one generic argument, not two.","D. While lambda expressions can use primitive types as arguments, the functional interface in this class uses the wrapper classes, which are not compatible. For this reason, Option A is incorrect. Option B is also incorrect, since the number of arguments and return type does not match the functional interface. Furthermore, the method reference System.out::print on the right-hand side of the lambda expression is invalid here, since it returns a method reference, not a double value. Option C is incorrect because 2*w is of type double, which cannot be returned as an Integer without an explicit cast. Option D is the correct answer. It takes exactly two arguments because the return value int can be implicitly autoboxed to Integer.","A. BooleanSupplier is the only functional interface that does not involve double, int, or long, making Option A the correct answer. The rest of the functional interfaces are not found in java.util.function. Java does not have built-in support for primitive functional interfaces that include char, float, or short.","D. The code does not compile because the lambda expression p -> p*100 is not compatible with the DoubleToIntFunction functional interface. The input to the functional interface is double, meaning p*100 is also double. The functional interface requires a return value of int, and since double cannot be implicitly cast to int, the code does not compile, making Option D the correct answer. If the correct cast was applied to make (p*100) an int, then the rest of the class would compile and 250 would be printed at runtime, making Option B correct.","B. The ToDoubleFunction interface takes a generic value, not a double value, making Option D incorrect. It also uses the method name accept(). The rest of the functional interfaces all take a double value. DoubleConsumer contains the accept() method, making Option A incorrect. DoublePredicate contains the test() method, making Option B the correct answer. Finally, DoubleUnaryOperator contains the applyAsDouble() method, making Option C incorrect.","D. To start with, line 5 does not compile because Function takes two generic arguments, not one. Second, the assignment statement on line 7 does not end with a semicolon (;), so it also does not compile. Finally, the forEach() method on line 10 requires a Consumer, not a Function, so this line does not compile. For these three reasons, Option D is the correct answer.","D. The DoubleToLongFunction interface takes a double argument and returns a long value. Option A is compatible since the int value 1 can be implicitly cast to long, and 2L is already a long. Option B is also compatible, since the double value 10.0*e is explicitly cast to int then implicitly cast to long. Next, Option C is compatible because an explicit cast of the double to a long value is used. Option D cannot be assigned and is the correct answer. Although the Double class does have a longValue() method, the left-hand side of the lambda expression must use the primitive double, not the wrapper Double. This lambda expression violates the signature of the functional interface, since it allows Double values to be sent to the interface, including those that could be null.","C. The DoublePredicate interface takes a double value and returns a boolean value. LongUnaryOperator takes a long value and returns a long value. ToIntBiFunction takes two generic values and returns an int value. The only choice that is not an existing functional interface is ShortSupplier. Recall that Java only includes primitive functional interfaces that operate on double, int, or long. For this reason, Option C is the correct answer.","A. The method reference System.out::println takes a single input and does not return any data. Consumer<Sheep> is compatible with this behavior, making Option A the correct answer and Option D incorrect. Option B is incorrect because void cannot be used as a generic argument. Option C is incorrect since System.out::println() does not return any data and UnaryOperator requires a return value.","C. The code does not compile, making Options A and B incorrect. The local variable MAX_LENGTH is neither final nor effectively final, meaning it cannot be used inside the lambda expression. The MAX_LENGTH variable starts off with an initial value of 2, but then is modified with the increment assignment (+=) operator to a value of 5, disqualifying its ability to be considered effectively final by the compiler. Since the lambda does not compile, Option C is the correct answer. If the code was rewritten so that the MAX_LENGTH variable was marked final and assigned a value of 5 from the start, then it would output 2, and Option A would be correct.","B. To begin with, all of the functional interfaces in the list of choices take two values. The difference is in the name of the method they use. BiConsumer uses accept(), making Option A incorrect. Option B is correct because BiFunction includes the apply() method. Option C is incorrect, since BiPredicate uses the test() method. DoubleBinaryOperator is almost correct but the name of the method is applyAsDouble(), not apply(), making Option D incorrect. For the exam, you should be aware of which primitive functional interfaces use a different method name than the generic ones.","B. To start with, IntFunction<Integer> takes an int value and returns an Integer. The first statement uses Integer instead of int as the input argument and is therefore not compatible. The second statement is compatible, since the return type null can be used as an Integer return type. The last statement is also valid. An int can be autoboxed to Integer. For these reasons, Option B is the correct answer.","C. The primitive Supplier functional interfaces, such as BooleanSupplier and LongSupplier, do not have a get() method. Instead, they have methods such as getAsBoolean() and getAsLong(), respectively. For this reason, the first line of the checkInventory() method does not compile, making Option C the correct answer. If the method call was changed to getAsBoolean(), then the rest of the code would compile without issue, print Plenty! at runtime, and Option A would be the correct answer.","B. Java only supports a single return data type or void. Therefore, it is not possible to define a functional interface that returns two data types, making Option A incorrect. Although Java does not include built-in support for primitive functional interfaces that include float, char, or short, there is nothing to prevent a developer from creating them in their own project, making Option B the true statement and the correct answer. Option C is incorrect because a functional interface that takes no values and returns void is possible. In fact, Runnable is one such example. Option D is also incorrect, since IntFunction<R> takes a primitive argument as input and a generic argument for the return type."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"Fill in the blanks: The____________ functional interface does not take any inputs, while the____________ functional interface does not return any data.",code:null,answers:["IntConsumer, LongSupplier","IntSupplier, Function","Supplier, DoubleConsumer","UnaryOperator, Consumer"]},{title:"Which functional interface takes a long value as an input argument and has an accept() method?",code:null,answers:["LongConsumer","LongFunction","LongPredicate","LongSupplier"]},{title:"What is the output of the following application?",code:'<code>package beach;</code>\n<code>import java.util.function.*;</code>\n<code>&nbsp;</code>\n<code>class Tourist {</code>\n<code>   public Tourist(double distance) {</code>\n<code>      this.distance = distance;</code>\n<code>   }</code>\n<code>   public double distance;</code>\n<code>}</code>\n<code>public class Lifeguard {</code>\n<code>   private void saveLife(Predicate&lt;Tourist&gt; canSave, Tourist tourist) {</code>\n<code>      System.out.print(canSave.test(tourist) ? "Saved" : "Too far");  // y1</code>\n<code>   }</code>\n<code>   public final static void main(String... sand) {</code>\n<code>      new Lifeguard().saveLife(s -&gt; s.distance&lt;4, new Tourist(2));  // y2</code>\n<code>   }</code>\n<code>}</code>',answers:["Saved","Too far","The code does not compile because of line y1.","The code does not compile because of line y2."]},{title:"Which of the following statements about DoubleSupplier and Supplier<Double> is  not true?",code:null,answers:["Both are functional interfaces.","Lambdas for both can return a double value.","Lambdas for both cannot return a null value.","One supports a generic type, the other does not."]},{title:"Which functional interface, when filled into the blank, allows the class to compile?",code:"<code>package space;</code>\n<code>import java.util.function.*;</code>\n<code>&nbsp;</code>\n<code>public class Asteroid {</code>\n<code>   public void mine(____________ lambda) {</code>\n<code>      // TODO: Apply functional interface</code>\n<code>   }</code>\n<code>   public static void main(String[] debris) {</code>\n<code>      new Asteroid().mine((s,p) -&gt; s+p);</code>\n<code>   }</code>\n<code>}</code>",answers:["BiConsumer<Integer,Double>","BiFunction<Integer,Double,Double>","BiFunction<Integer,Integer,Double>","Function<Integer,Double>"]},{title:"Assuming the proper generic types are used, which lambda expression cannot be assigned to a ToDoubleBiFunction functional interface reference?",code:null,answers:["(Integer a, Double b) -> {int c; return b;}","(h,i) -> (long)h","(String u, Object v) -> u.length()+v.length()","(x,y) -> {int z=2; return y/z;}"]},{title:"Which of the following is not a functional interface in the java.util.function package?",code:null,answers:["BiPredicate","DoubleUnaryOperator","ObjectDoubleConsumer","ToLongFunction"]},{title:"What is the output of the following application?",code:'<code>package zoo;</code>\n<code>import java.util.function.*;</code>\n<code>&nbsp;</code>\n<code>public class TicketTaker {</code>\n<code>   private static int AT_CAPACITY = 100;</code>\n<code>   public int takeTicket(int currentCount, IntUnaryOperator&lt;Integer&gt; counter) {</code>\n<code>      return counter.applyAsInt(currentCount);</code>\n<code>   }</code>\n<code>   public static void main(String...theater) {</code>\n<code>      final TicketTaker bob = new TicketTaker();</code>\n<code>      final int oldCount = 50;</code>\n<code>      final int newCount = bob.takeTicket(oldCount,t -&gt; {</code>\n<code>         if(t&gt;AT_CAPACITY) {</code>\n<code>            throw new RuntimeException("Sorry, max has been reached");</code>\n<code>         }</code>\n<code>         return t+1;</code>\n<code>      });</code>\n<code>      System.out.print(newCount);</code>\n<code>   }</code>\n<code>}</code>',answers:["51","The code does not compile because of lambda expression.","The code does not compile for a different reason.","The code compiles but prints an exception at runtime."]},{title:"Which functional interface returns a primitive value?",code:null,answers:["BiPredicate","CharSupplier","LongFunction","UnaryOperator"]},{title:"Which functional interface, when entered into the blank below, allows the class to compile?",code:'<code>package groceries;</code>\n<code>import java.util.*;</code>\n<code>import java.util.function.*;</code>\n<code>&nbsp;</code>\n<code>public class Market {</code>\n<code><span epub:type="pagebreak" id="Page_243"></span>   private static void checkPrices(List&lt;Double&gt; prices,</code>\n<code>          ____________scanner) {</code>\n<code>      prices.forEach(scanner);</code>\n<code>   }</code>\n<code>   public static void main(String[] right) {</code>\n<code>      List&lt;Double&gt; prices = Arrays.asList(1.2, 6.5, 3.0);</code>\n<code>      checkPrices(prices,</code>\n<code>            p -&gt; {</code>\n<code>               String result = p&lt;5 ? "Correct" : "Too high";</code>\n<code>               System.out.println(result);</code>\n<code>            });</code>\n<code>   }</code>\n<code>&nbsp;</code>\n<code>}</code>',answers:["Consumer","DoubleConsumer","Supplier<Double>","None of the above"]},{title:"Which of the following three functional interfaces is not equivalent to the other two?",code:null,answers:["BiFunction<Double,Double,Double>","BinaryOperator<Double>","DoubleFunction<Double>","None of the above. All three are equivalent."]},{title:"Which lambda expression can be passed to the magic() method?",code:"<code>package show;</code>\n<code>import java.util.function.*;</code>\n<code>&nbsp;</code>\n<code>public class Magician {</code>\n<code>   public void magic(BinaryOperator&lt;Long&gt; lambda) {</code>\n<code>      lambda.apply(3L, 7L);</code>\n<code>   }</code>\n<code>}</code>",answers:["magic((a) -> a)","magic((b,w) -> (long)w.intValue())","magic((c,m) -> {long c=4; return c+m;})","magic((Integer d, Integer r) -> (Long)r+d)"]},{title:"What is the output of the following program?",code:'<code>package ai;</code>\n<code>import java.util.function.*;</code>\n<code>&nbsp;</code>\n<code>public class Android {</code>\n<code>   public void wakeUp(Supplier supplier) { // d1</code>\n<code>      supplier.get();</code>\n<code>   }</code>\n<code>   public static void main(String... electricSheep) {</code>\n<code>      Android data = new Android();</code>\n<code>      data.wakeUp(() -&gt; System.out.print("Program started!")); // d2</code>\n<code>   }</code>\n<code>}</code>',answers:["Program started!","The code does not compile because of line d1 only.","The code does not compile because of line d2 only.","The code does not compile because of both lines d1 and d2."]},{title:"Which statement about all UnaryOperator functional interfaces (generic and primitive) is correct?",code:null,answers:["The input type must be compatible with the return type.","Some of them take multiple arguments.","They each take a generic argument.","They each return a primitive value."]},{title:"Starting with DoubleConsumer and going downward, fill in the missing values for the table.",code:null,answers:["0, 1, 1, 1","0, 2, 1, 2","1, 1, 0, 2","1, 1, 0, 1"]},{title:"Starting with DoubleConsumer and going downward, fill in the values for the table. For the choices below, assume R is a generic type.",code:null,answers:["double, R, long, R","R, int, long, R","void, int, R, void","void, R, long, void"]},{title:"Fill in the blanks:  In the Collection interface, the method removeIf() takes a____________ , while the method forEach() takes a____________ .",code:null,answers:["Function, Function","Predicate, Consumer","Predicate, Function","Predicate, UnaryOperator"]},{title:"What is the output of the following application?",code:'<code>package nesting;</code>\n<code>import java.util.function.*;</code>\n<code>&nbsp;</code>\n<code>public class Doll {</code>\n<code>   private int layer;</code>\n<code>   public Doll(int layer) {</code>\n<code>      super();</code>\n<code>      this.layer = layer;</code>\n<code>   }</code>\n<code>   public static void open(UnaryOperator&lt;Doll&gt; task, Doll doll) {</code>\n<code>      while((doll = task.accept(doll)) != null) {</code>\n<code>         System.out.print("X");</code>\n<code>      }</code>\n<code>   }</code>\n<code><span epub:type="pagebreak" id="Page_246"></span>   public static void main(String[] wood) {</code>\n<code>      open(s -&gt; {</code>\n<code>         if(s.layer&lt;=0) return null;</code>\n<code>         else return new Doll(s.layer\x96\x96);</code>\n<code>      }, new Doll(5));</code>\n<code>   }</code>\n<code>}</code>',answers:["XXXXX","The code does not compile because of the lambda expression.","The code does not compile for a different reason.","The code compiles but produces an infinite loop at runtime."]},{title:"Which functional interface has a get() method?",code:null,answers:["Consumer","Function","Supplier","UnaryOperator"]},{title:"The following diagram shows input arguments being applied to three functional interfaces of unknown type. Which three functional interfaces, inserted in order from left to right, could be used to complete the diagram?",code:null,answers:["\n\nDoubleBinaryOperator \n\nToDoubleBiFunction<Integer,Double> \n\nUnaryOperator<Integer>\n","\n\nBinaryOperator<Double> \n\nBiFunction<Integer,Integer,Double> \n\nUnaryOperator<Integer>\n","\n\nFunction<Double,Integer> \n\nBiFunction<Integer,Integer,Double> \n\nDoubleToIntFunction\n","\n\nBiFunction<Integer,Double,Integer> \n\nBinaryOperator<Integer> \n\nIntUnaryOperator\n"]},{title:"Which statement about functional interfaces and lambda expressions is not true?",code:null,answers:["A lambda expression may be compatible with multiple functional interfaces.","A lambda expression must be assigned to a functional interface when it is declared.","A method can return a lambda expression in the form of a functional interface instance.","The compiler uses deferred execution to skip determining whether a lambda expression compiles or not."]},{title:"Which expression is compatible with the IntSupplier functional interface?",code:null,answers:['() -> 1<10 ? "3" : 4',"() -> {return 1/0;}","() -> return 4","System.out::print"]},{title:"What is the output of the following application?",code:'<code>package tps;</code>\n<code>import java.util.*;</code>\n<code>&nbsp;</code>\n<code>class Boss {</code>\n<code>   private String name;</code>\n<code>   public Boss(String name) {</code>\n<code>      this.name = name;</code>\n<code>   }</code>\n<code>   public String getName() {return name.toUpperCase();}</code>\n<code>   public String toString() {return getName();}</code>\n<code>}</code>\n<code>public class Initech {</code>\n<code>   public static void main(String[] reports) {</code>\n<code>      final List&lt;Boss&gt; bosses = new ArrayList(8);</code>\n<code>      bosses.add(new Boss("Jenny"));</code>\n<code>      bosses.add(new Boss("Ted"));</code>\n<code>      bosses.add(new Boss("Grace"));</code>\n<code>      bosses.removeIf(s -&gt; s.equalsIgnoreCase("ted"));</code>\n<code>      System.out.print(bosses);</code>\n<code>   }</code>\n<code>}</code>',answers:["[JENNY, GRACE]","[tps.Boss@4218224c, tps.Boss@815f19a]","The code does not compile because of the lambda expression.","The code does not compile for a different reason."]},{title:"Which of the following method references can be passed to a method that takes Consumer<Object> as an argument?",code:null,answers:["I only","I, II, and III","I and III","III only"],ol:["ArrayList::new","String::new","System.out::println"]},{title:"Which of the following is a valid functional interface in the java.util.function package?",code:null,answers:["FloatPredicate","ToDoubleBiFunction","UnaryIntOperator","TriPredicate"]},{title:"Which functional interface, when filled into the blank, prevents the class from compiling?",code:"<code>package morning;</code>\n<code>import java.util.function.*;</code>\n<code>&nbsp;</code>\n<code>public class Sun {</code>\n<code>   public static void dawn(____________ sunrise) {}</code>\n<code>   public void main(String... rays) {</code>\n<code>      dawn(s -&gt; s+1);</code>\n<code>   }</code>\n<code>}</code>",answers:["DoubleUnaryOperator","Function<String,String>","IntToLongFunction","UnaryOperator"]},{title:"Which functional interface does not have the correct number of generic arguments?",code:null,answers:["BiFunction<T,U,R>","DoubleFunction<T,R>","ToDoubleFunction<T>","ToIntBiFunction<T,U>"]},{title:"Which lambda expression, when filled into the blank, allows the code to compile?",code:"<code>package ballroom;</code>\n<code>import java.util.function.*;</code>\n<code>&nbsp;</code>\n<code>public class Dance {</code>\n<code>   public static Integer rest(BiFunction&lt;Integer,Double,Integer&gt; takeABreak) {</code>\n<code>      return takeABreak.apply(3, 10.2);</code>\n<code>   }</code>\n<code>   public static void main(String[] participants) {</code>\n<code>      rest(____________);</code>\n<code>   }</code>\n<code>}</code>",answers:["(int n, double e) -> (int)(n+e)","(n,w,e) -> System.out::print","(s,w) -> 2*w","(s,e) -> s.intValue()+e.intValue()"]},{title:"Fill in the blank:  ____________is the only functional interface that does not involve double, int, or long.",code:null,answers:["BooleanSupplier","CharPredicate","FloatUnaryOperator","ShortConsumer"]},{title:"What is the output of the following application?",code:'<code>package savings;</code>\n<code>import java.util.function.*;</code>\n<code>&nbsp;</code>\n<code>public class Bank {</code>\n<code>   private int savingsInCents;</code>\n<code>   private static class ConvertToCents {</code>\n<code>      static DoubleToIntFunction f = p -&gt; p*100;</code>\n<code>   }</code>\n<code>   public static void main(String... currency) {</code>\n<code>      Bank creditUnion = new Bank();</code>\n<code>      creditUnion.savingsInCents = 100;</code>\n<code>      double deposit = 1.5;</code>\n<code>&nbsp;</code>\n<code>      creditUnion.savingsInCents += ConvertToCents.f.applyAsInt(deposit);  // j1</code>\n<code><span epub:type="pagebreak" id="Page_250"></span>      System.out.print(creditUnion.savingsInCents);</code>\n<code>   }</code>\n<code>}</code>',answers:["200","250","The code does not compile because of line j1.","None of the above"]},{title:"Which functional interface takes a double value and has a test() method?",code:null,answers:["DoubleConsumer","DoublePredicate","DoubleUnaryOperator","ToDoubleFunction"]},{title:"Given the following class, how many lines contain compilation errors?",code:'<code>1:  package showtimes;</code>\n<code>2:  import java.util.*;</code>\n<code>3:  import java.util.function.*;</code>\n<code>4:  public class FindMovie {</code>\n<code>5:     private Function&lt;String&gt; printer;</code>\n<code>6:     protected FindMovie() {</code>\n<code>7:         printer = s -&gt; {System.out.println(s); return s;}</code>\n<code>8:     }</code>\n<code>9:     void printMovies(List&lt;String&gt; movies) {</code>\n<code>10:       movies.forEach(printer);</code>\n<code>11:    }</code>\n<code>12:    public static void main(String[] screen) {</code>\n<code>13:       List&lt;String&gt; movies = new ArrayList&lt;&gt;();</code>\n<code>14:       movies.add("Stream 3");</code>\n<code>15:       movies.add("Lord of the Recursion");</code>\n<code>16:       movies.add("Silence of the Lambdas");</code>\n<code>17:       new FindMovie().printMovies(movies);</code>\n<code>18:    }</code>\n<code>19: }</code>',answers:["None. The code compiles as is.","One","Two","Three"]},{title:"Which lambda expression cannot be assigned to a DoubleToLongFunction functional interface?",code:null,answers:["a -> null==null ? 1 : 2L","e -> (int)(10.0*e)","(double m) -> {long p = (long)m; return p;}","(Double s) -> s.longValue()"]},{title:"Which of the following is not a functional interface in the java.util.function package?",code:null,answers:["DoublePredicate","LongUnaryOperator","ShortSupplier","ToIntBiFunction"]},{title:"Which functional interface, when filled into the blank, allows the class to compile?",code:"<code>package sleep;</code>\n<code>import java.util.function.*;</code>\n<code>&nbsp;</code>\n<code>class Sheep {}</code>\n<code>public class Dream {</code>\n<code>   int MAX_SHEEP = 10;</code>\n<code>   int sheepCount;</code>\n<code>   public void countSheep( ____________backToSleep) {</code>\n<code>      while(sheepCount&lt;MAX_SHEEP) {</code>\n<code>         // TODO: Apply lambda</code>\n<code>         sheepCount++;</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] dark) {</code>\n<code>      new Dream().countSheep(System.out::println);</code>\n<code>   }</code>\n<code>}</code>",answers:["Consumer<Sheep>","Function<Sheep,void>","UnaryOperator<Sheep>","None of the above"]},{title:"What is the output of the following application?",code:'<code>package pet;</code>\n<code>import java.util.*;</code>\n<code>import java.util.function.*;</code>\n<code>&nbsp;</code>\n<code>public class DogSearch {</code>\n<code>   void reduceList(List&lt;String&gt; names, Predicate&lt;String&gt; tester) {</code>\n<code>      names.removeIf(tester);</code>\n<code>   }</code>\n<code>   public static void main(String[] treats) {</code>\n<code>      int MAX_LENGTH = 2;</code>\n<code>      DogSearch search = new DogSearch();</code>\n<code>      List&lt;String&gt; names = new ArrayList&lt;&gt;();</code>\n<code>      names.add("Lassie");</code>\n<code>      names.add("Benji");</code>\n<code>      names.add("Brian");</code>\n<code>      MAX_LENGTH += names.size();</code>\n<code>      search.reduceList(names, d -&gt; d.length()&gt;MAX_LENGTH);</code>\n<code>      System.out.print(names.size());</code>\n<code>   }</code>\n<code>}</code>',answers:["2","3","The code does not compile because of lambda expression.","The code does not compile for a different reason."]},{title:"Which functional interface takes two values and has an apply() method?",code:null,answers:["BiConsumer","BiFunction","BiPredicate","DoubleBinaryOperator"]},{title:"Which of the following lambda expressions can be passed to a method that takes IntFunction<Integer> as an argument?",code:null,answers:["I, II, and III","II and III only","III only","None of the above"],ol:["(Integer f) -> f","(v) -> null","s -> s"]},{title:"What is the output of the following application?",code:'<code>package lot;</code>\n<code>import java.util.function.*;</code>\n<code>&nbsp;</code>\n<code>public class Warehouse {</code>\n<code>   private int quantity = 40;</code>\n<code>   private final BooleanSupplier stock;</code>\n<code>   {</code>\n<code>      stock = () -&gt; quantity&gt;0;</code>\n<code>   }</code>\n<code>   public void checkInventory() {</code>\n<code>      if(stock.get())</code>\n<code>         System.out.print("Plenty!");</code>\n<code>      else {</code>\n<code>         System.out.print("On Backorder!");</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String... widget) {</code>\n<code>      final Warehouse w13 = new Warehouse();</code>\n<code>      w13.checkInventory();</code>\n<code>   }</code>\n<code>}</code>',answers:["Plenty!","On Backorder!","The code does not compile because of the checkInventory() method.","The code does not compile for a different reason."]},{title:"Which of the following statements about functional interfaces is true?",code:null,answers:["It is possible to define a functional interface that returns two data types.","It is possible to define a primitive functional interface that uses float, char, or short.","It is not possible to define a functional interface that does not take any arguments nor return any value.","None of the primitive functional interfaces include generic arguments."]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t],ol:e.ol}});i[14].imageUrl="./images/image-ocp-ch14-15.png",i[15].imageUrl="./images/image-ocp-ch14-16.png",i[19].imageUrl="./images/image-ocp-ch14-20.png",t.default=i},170:function(e,t,o){"use strict";o.r(t);var n=["D. Option A is incorrect because it doesn\u2019t print out one line. The peek() method is an intermediate operation. Since there is no terminal operation, the stream pipeline is not executed, so the peek() method is never executed. Options B and C are incorrect because they correctly output one line using a method reference and lambda, respectively, and don\u2019t use any bad practices. Option D is the answer. It does output one line. However, it is bad practice to have a peek() method that has side effects like modifying a variable.","A. This code generates an infinite stream of integers: 1, 2, 3, 4, 5, 6, 7, etc. The Predicate checks if the element is greater than 5. With anyMatch(), the stream pipeline ends once element 6 is hit and the code prints true. For both the allMatch() and noneMatch() operators, they see that the first element in the stream does not match and the code prints false. Therefore, Option A is correct.","B. Only the average() method returns an OptionalDouble. This reflects that it doesn\u2019t make sense to calculate an average when you don\u2019t have any numbers. By contrast, counting without any numbers gives the long number 0 and summing gives the double number 0.0. Since only one method matches the return type, Option B is correct.","C. The map() method can fill in the blank. The lambda converts a String to an int and Java uses autoboxing to turn that into an Integer. The mapToInt() method can also fill in the blank and Java doesn\u2019t even need to autobox. There isn\u2019t a mapToObject() in the stream API. Note there is a similarly named mapToObj() method on IntStream. Since both map() and mapToInt() work here, Option C is correct.","D. The average() method returns an OptionalDouble. This interface has a getAsDouble() method rather than a get() method, so the code does compile. However, the stream is empty, so the optional is also empty. When trying to get the value, the code throws a NoSuchElementException, making Option D correct.","D. Option A is incorrect because anyMatch() returns a boolean. Option B is incorrect because filter() is an intermediate operation, not a terminal operation, and therefore returns a Stream. Both of these methods do take a Predicate as a parameter. While findAny() does return an Optional, it doesn\u2019t take any parameters. Therefore, Option C is incorrect, and Option D is the answer.","B. This code builds a list with two elements. It then uses that list as a source for the stream, sorts the stream as it goes by, and grabs the first sorted element. This does not change the original list. The first element in the sorted stream is 1.2, but the first element of list remains as 5.4. This makes Option B correct.","B. Primitive streams, like LongStream, declare an average() method, while summary statistics classes, like LongSummaryStatistics, declare a getAverage() method, making Options C and D incorrect. The average() method returns an OptionalDouble object, which declares a getAsDouble() method rather than a get() method. Therefore, Option A is incorrect, and Option B is correct.","B. Since the result of the collect() is not stored in a variable or used in any way, all the code needs to do is compile. There is no Collectors.toArrayList() method. If you want to specify an ArrayList, you can call Collectors.toCollection(ArrayList::new). The Collectors.toList() method does in fact exist and compile. While there is a Collectors.toMap() method, it requires two parameters to specify the key and value functions, respectively. Since only one can compile, Option B is correct.","C. As tempting as it is, you can\u2019t actually convert a Map into a Stream directly, which means you can\u2019t call the map() method on it either. However, you can build a Stream out of the keys or values or key/value pairs. Since this code doesn\u2019t compile, Option C is correct.","D. I is incorrect because isPresent() returns false for an empty Optional. II is incorrect because of() throws a NullPointerException if you try to pass a null reference. III doesn\u2019t throw an exception as the ofNullable() is designed to allow a null reference. However, it returns false because no value is present. Since none of the choices are correct, Option D is the answer.","A. This code does compile. Remember that imports are implied, including the static import for Collectors. The collector tries to use the number of characters in each stream element as the key in a map. This works fine for the first two elements, speak and bark, because they are of length 5 and 4, respectively. When it gets to meow, it sees another key of 4. The merge function says to use the first one, so it chooses bark for the value. Similarly, growl is 5 characters, but the first value of speak is used. There are only two distinct lengths, so Option A is correct.","C. For the primitive stream that contains the int primitives, the interface names are incorrect. They should be IntStream and IntSummaryStatistics, making Option C correct. If this was fixed, Option B would be the answer.","B. This code does compile. As an intermediate operation, you are allowed to call peek() many times in a stream pipeline. You can even call it multiple times in a row. While it is common to write System.out::println directly as a parameter to peek(), nothing prevents you from creating a Consumer variable. Since the forEach() method also takes a Consumer, we can reuse it. The three peek() intermediate operations and one forEach() operation total four lines of output. The map() operation could be omitted since it simply passes the input through.","B. Character objects are allowed in a Stream, so line z1 compiles, making Option C incorrect. Line z2 also compiles since findAny() returns an Optional and ifPresent() is declared on Optional. Therefore, Option D is also incorrect. Now let\u2019s look at the Stream. The source has three elements. The intermediate operation sorts the elements and then we request one from findAny(). The findAny() method is not guaranteed to return a specific element. Since we are not using parallelization, it is highly likely that the code will print a. However, you need to know this is not guaranteed, making Option B the answer.","A. The sorted() method takes an optional Comparator as the parameter, which takes two String parameters and returns an int. Option A is correct because the lambda implements this interface. Option B is incorrect because the method reference doesn\u2019t take any parameters, nor does it return an int.","D. The Optional class has an isPresent() method that doesn\u2019t take any parameters. It returns a boolean and is commonly used in if statements. There is also an ifPresent() method that takes a Consumer parameter and runs it only if the Optional is non-empty. The methods isNotNull() and forEach()are not declared in Optional. Therefore, Option D is correct.","C. The first intermediate operation, limit(1), turns the infinite stream into a stream with one element: true. The partitioningBy() method returns a map with two keys, true and false, regardless of whether any elements actually match. If there are no matches, the value is an empty list, making Option C correct.","B. The flatMap() method is used to turn a stream of streams into a one-dimensional stream. This means it gets rid of the empty list and flattens the other two. Option A is incorrect because this is the output you\u2019d get using the regular map() method. Option B is correct because it flattens the elements. Notice how it doesn\u2019t matter that all three elements are different types of Collection implementations.","D. The sorted() method allows an optional Comparator to be passed as a reference. However, Comparator.reverseOrder() does not implement the Comparator interface. It takes zero parameters instead of the required two. Since it cannot be used as a method reference, the code does not compile, and Option D is correct.","D. Option A is incorrect because the findAny() might not return 1. The result could be any of the three numbers. Option B is incorrect because there is no first() method available as a terminal operation. Option C is tempting because there is a min() method. However, since we are working with a Stream, this method requires a Comparator as a parameter. Therefore, Option D is the answer.","C. List doesn\u2019t have a filter() method, so Option A is incorrect. Stream does have filter() and map() methods. However, Stream doesn\u2019t have an ifPresent() method. This makes IV incorrect, so Options B and D are incorrect. Both Collection and String have an isEmpty() method, so either can be used with the Optional, making Option C the answer.","D. This code generates an infinite stream of the number 1. The Predicate checks if the element is greater than 5. This will never be true. With allMatch(), the stream pipeline ends after checking the first element. It doesn\u2019t match, so the code prints false. Both anyMatch() and noneMatch() keep checking and don\u2019t find any matches. However, they don\u2019t know if a future stream element will be different, so the code executes infinitely until the process is terminated. Therefore, Option D is correct.","D. Both Collectors.groupingBy() and Collectors.partitioningBy() are useful for turning a stream into a Map. The other two methods do not exist. However, when using a condition, you should use partitioningBy() as it automatically groups using a Boolean key. Therefore, Option D is correct.","B. Option A is incorrect because we are working with primitives rather than objects. Option C compiles but outputs the stream references rather than the contents. Option B is correct because it flattens the int primitives into one stream.","D. The summary statistics classes provide getters in order to access the data. The getAverage() method returns a double and not an OptionalDouble. Option D is the only option to compile.","D. Option A doesn\u2019t compile because the get() method on Optional doesn\u2019t take any parameters. Options B and C do compile, but both print Cupcake since the Optional is not empty. Therefore, Option D is correct.","C. The first line generates an infinite stream. The stream pipeline has a filter that lets all these elements through. Since sorted() requires all the elements be available to sort, it never completes, making Option C correct.","A. The mapToDouble() method compiles. However, it converts 9 into 9.0 rather than the single digit 9. The mapToInt() method does not compile because a long cannot be converted into an int without casting. The mapToLong() method is not available on LongStream so it does not compile. It is available on DoubleStream, IntStream, and Stream implementations. Since none of the options outputs the single digit 9, Option A is correct.","A. The filter() method either passes along a given element or doesn\u2019t, making Option D incorrect. The flatMap() method doesn\u2019t pass along any elements for empty streams. For non-empty streams, it flattens the elements, allowing it to return zero or more elements. This makes Option B incorrect. Finally, the map() method applies a one-to-one function for each element. It has to return exactly one element, so Option A is the correct answer.","D. First, we sort the stream. Option B is incorrect because findFirst() is guaranteed to return the first element. However, the findFirst() method returns an Optional. Therefore, the output of this code is Optional[a] rather than the letter a, making Option D correct.","C. There is not a stream pipeline method called sort(). There is one called sorted(). Since the code does not compile, Option C is correct. If this was fixed, Option A would be correct since the Comparator sorts in ascending order.","B. This code compiles. It creates a stream of Ballot objects. Then it creates a map with the contestant\u2019s name as the key and the sum of the scores as the value. For Mario, this is 10 + 9, or 19, so Option B is correct.","D. Both anyMatch() and allMatch() take a Predicate as a parameter. This code does not compile because the parameter is missing.","D. The flatMap() method works with streams rather than collections. The code does not compile because the x is not a stream, making Option D correct. If this was fixed, Option B would be the answer.","C. The groupingBy() collector always returns a Map (or a specific implementation class of Map), so III can\u2019t be right. The other two are definitely possible. To get I, you can group using a Function that returns an Integer such as s.collect(Collectors .groupingBy(String::length)). To get II, you need to group using a Function that returns a Boolean and specify the type, such as s.collect(Collectors .groupingBy(String::isEmpty, Collectors.toSet())). Notice that autoboxing is used for both. Therefore, Option C is correct.","D. There is no built-in method to map a value to a boolean primitive. Therefore, Options B and C don\u2019t even compile, so they are incorrect. Option A does compile as it maps a Runner to a Boolean. However, it doesn\u2019t actually filter() the stream to eliminate any values, so the output is not the same. It prints 3 instead of 1. None of these are correct, making Option D the answer.","A. Option A is the answer because there is a getCount() method that returns a long rather than a method named getCountAsLong(). Option B is incorrect because there is in fact a getMax() method. Option C is incorrect because toString() is declared on Object, which means it is inherited by all classes.","C. The main() method has warnings, but it does compile, making Option D incorrect. The warnings are both about not declaring the generic type for Optional. Option A does not compile because the orElse() method expects an Exception as the alternate value passed as a parameter. IllegalArgumentException::new is a Supplier instead. Options B and C both compile as both methods expect a Supplier as the parameter. However, orElseGet() simply returns the exception from the method rather than throwing it. Option C actually throws the exception the Supplier created and is the correct answer.","B. Option A happens to output the same result for both pairs. It outputs a blank line in withFlatMap() because empty streams are removed and in withoutFlatMap() because the filter() method removes the empty list. Option B outputs different results. The withFlatMap() method outputs lastall queued up since it flattens the streams. By contrast, the withoutFlatMap() method outputs [last, all queued up] since it leaves the structure intact. Since the output is different. Option B produces different results so it is the answer."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"Which of the following fills in the blank so that the code outputs one line but uses a poor practice?",code:'<code>import java.util.*;</code>\n<code>&nbsp;</code>\n<code>public class Cheater {</code>\n<code>   int count = 0;</code>\n<code>   public void sneak(Collection&lt;String&gt; coll) {</code>\n<code>      coll.stream().________________________;</code>\n<code>   }</code>\n<code>&nbsp;</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Cheater c = new Cheater();</code>\n<code>      c.sneak(Arrays.asList("weasel"));</code>\n<code>  }</code>\n<code>}</code>',answers:["peek(System.out::println)","peek(System.out::println) .findFirst()","peek(r -> System.out.println(r)) .findFirst()","peek(r -> {count++; System.out.println(r); }) .findFirst()"]},{title:"Which can fill in the blank to have the code print true?",code:"<code>Stream&lt;Integer&gt; stream = Stream.iterate(1, i \u2010&gt; i+1);</code>\n<code>boolean b = stream.____________(i -&gt; i &gt; 5);</code>\n<code>System.out.println(b);</code>",answers:["anyMatch","allMatch","noneMatch","None of the above"]},{title:"On a DoubleStream, how many of the methods average(), count(), and sum() return an OptionalDouble?",code:null,answers:["None","One","Two","Three"]},{title:"How many of the following can fill in the blank to have the code print 44?",code:'<code>Stream&lt;String&gt; stream = Stream.of("base", "ball");</code>\n<code>stream._____________(s -&gt; s.length()).forEach(System.out::print);</code>',answers:["None","One","Two","Three"],ol:["map","mapToInt","mapToObject"]},{title:"What is the result of the following?",code:"<code>IntStream s = IntStream.empty();</code>\n<code>System.out.print(s.average().getAsDouble());</code>",answers:["The code prints 0.","The code prints 0.0.","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which of these stream pipeline operations takes a Predicate as a parameter and returns an Optional?",code:null,answers:["anyMatch()","filter()","findAny()","None of the above"]},{title:"What is the result of the following?",code:'<code>List&lt;Double&gt; list = new ArrayList&lt;&gt;();</code>\n<code>list.add(5.4);</code>\n<code>list.add(1.2);</code>\n<code>Optional&lt;Double&gt; opt = list.stream().sorted().findFirst();</code>\n<code>System.out.println(opt.get() + " " + list.get(0));</code>',answers:["1.2 1.2","1.2 5.4","5.4 5.4","None of the above"]},{title:"Fill in the blank so this code prints 8.0.",code:"<code>IntStream stream = IntStream.of(6, 10);</code>\n<code>LongStream longs = stream.mapToLong(i -&gt; i);</code>\n<code>System.out.println(____________);</code>",answers:["longs.average().get()","longs.average().getAsDouble()","longs.getAverage().get()","longs.getAverage().getAsDouble()"]},{title:"How many of these collectors can fill in the blank to make this code compile?",code:"<code>Stream&lt;Character&gt; chars = Stream.of(</code>\n<code>   'o', 'b', 's', 't', 'a', 'c', 'l', 'e');</code>\n<code>chars.map(c -&gt; c).collect(Collectors.____________ );</code>",answers:["None","One","Two","Three"],ol:["toArrayList()","toList()","toMap()"]},{title:"What does the following output?",code:"<code>import java.util.*;</code>\n<code>&nbsp;</code>\n<code>public class MapOfMaps {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</code>\n<code>      map.put(9, 3);</code>\n<code>      Map&lt;Integer, Integer&gt; result = map.stream().map((k,v) \u2010&gt; (v,k));</code>\n<code>      System.out.println(result.keySet().iterator().next());</code>\n<code>   }</code>\n<code>}</code>",answers:["3","9","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which of the following creates an Optional that returns true when calling opt.isPresent()? ",code:null,answers:["I","I and II","I and III","None of the above"],ol:["Optional<String> opt = Optional.empty();","Optional<String> opt = Optional.of(null);","Optional<String> opt = Optional.ofNullable(null);"]},{title:"What is the output of the following?",code:'<code>Stream&lt;String&gt; s = Stream.of("speak", "bark", "meow", "growl");</code>\n<code>BinaryOperator&lt;String&gt; merge = (a, b) \u2010&gt; a;</code>\n<code>Map&lt;Integer, String&gt; map = s.collect(toMap(String::length, k \u2010&gt; k, merge));</code>\n<code>System.out.println(map.size() + " " + map.get(4));</code>',answers:["2 bark","2 meow","4 bark","None of the above"]},{title:"What is the output of the following?",code:'<code>1:   package reader;</code>\n<code>2:   import java.util.stream.*;</code>\n<code>3:</code>\n<code>4:   public class Books {</code>\n<code>5:      public static void main(String[] args) {</code>\n<code>6:         IntegerStream pages = IntegerStream.of(200, 300);</code>\n<code>7:         IntegerSummaryStatistics stats = pages.summaryStatistics();</code>\n<code>8:         long total = stats.getSum();</code>\n<code>9:         long count = stats.getCount();</code>\n<code>10:        System.out.println(total + "-" + count);</code>\n<code>11:     }</code>\n<code>12:  }</code>',answers:["500-0","500-2","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:'If this method is called with Stream.of("hi"), how many lines are printed?',code:"<code>public static void print(Stream&lt;String&gt; stream) {</code>\n<code>   Consumer&lt;String&gt; print = System.out::println;</code>\n<code>   stream.peek(print)</code>\n<code>         .peek(print)</code>\n<code>         .map(s -&gt; s)</code>\n<code>         .peek(print)</code>\n<code>         .forEach(print);</code>\n<code>}</code>",answers:["Three","Four","The code compiles but does not output anything.","The code does not compile."]},{title:"What is true of the following code?",code:"<code>Stream&lt;Character&gt; stream = Stream.of('c', 'b', 'a');       // z1</code>\n<code>stream.sorted().findAny().ifPresent(System.out::println);  // z2</code>",answers:["It is guaranteed to print the single character a.","It can print any single character of a, b, or c.","It does not compile because of line z1.","It does not compile because of line z2."]},{title:"Suppose you have a stream pipeline where all the elements are of type String. Which of the following can be passed to the intermediate operation sorted()?",code:null,answers:["(s,t) -> s.length() - t.length()","String::isEmpty","Both of these","Neither of these"]},{title:"Fill in the blanks so that both methods produce the same output for all inputs.",code:'<code>private static void longer(Optional&lt;Boolean&gt; opt) {</code>\n<code>   if (opt.____________())</code>\n<code>      System.out.println("run: " + opt.get());</code>\n<code>}</code>\n<code>private static void shorter(Optional&lt;Boolean&gt; opt) {</code>\n<code>   opt.map(x -&gt; "run: " + x).____________(System.out::println);</code>\n<code>}</code>',answers:["isNotNull, isPresent","ifPresent, isPresent","isPresent, forEach","isPresent, ifPresent"]},{title:"What is the output of this code?",code:"<code>Stream&lt;Boolean&gt; bools = Stream.iterate(true, b \u2010&gt; !b);</code>\n<code>Map&lt;Boolean, List&lt;Boolean&gt;&gt; map = bools.limit(1)</code>\n<code>    .collect(partitioningBy(b -&gt; b));</code>\n<code>System.out.println(map);</code>",answers:["{true=[true]}","{false=null, true=[true]}","{false=[], true=[true]}","None of the above"]},{title:"What does the following output?",code:'<code>Set&lt;String&gt; set = new HashSet&lt;&gt;();</code>\n<code>set.add("tire-");</code>\n<code>List&lt;String&gt; list = new LinkedList&lt;&gt;();</code>\n<code>Deque&lt;String&gt; queue = new ArrayDeque&lt;&gt;();</code>\n<code>queue.push("wheel-");</code>\n<code>Stream.of(set, list, queue)</code>\n<code>   .flatMap(x -&gt; x.stream())</code>\n<code>   .forEach(System.out::print);</code>',answers:["[tire-][wheel-]","tire-wheel-","None of the above.","The code does not compile."]},{title:"What is the output of the following?",code:'<code>Stream&lt;String&gt; s = Stream.of("over the river",</code>\n<code>    "through the woods",</code>\n<code>    "to grandmother\'s house we go");</code>\n<code>s.filter(n -&gt; n.startsWith("t"))</code>\n<code> .sorted(Comparator::reverseOrder)</code>\n<code> .findFirst()</code>\n<code> .ifPresent(System.out::println);</code>',answers:["over the river","through the woods","to grandmother's house we go ","None of the above"]},{title:"Which fills in the blank so the code is guaranteed to print 1?",code:"<code>Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3);</code>\n<code>System.out.println(stream.____________);</code>",answers:["findAny()","first()","min()","None of the above"]},{title:"Which of the following can be the type for x?",code:"<code>private static void spot(____________ x) {</code>\n<code>   x.filter(y -&gt; ! y.isEmpty())</code>\n<code>     .map(y -&gt; 8)</code>\n<code>     .ifPresent(System.out::println);</code>\n<code>}</code>",answers:["I","IV","II and III","II and IV"],ol:["List<String>","Optional<Collection>","Optional<String>","Stream<Collection>"]},{title:"Which can fill in the blank to have the code print true?",code:"<code>Stream&lt;Integer&gt; stream = Stream.iterate(1, i \u2010&gt; i);</code>\n<code>boolean b = stream.____________(i -&gt; i &gt; 5);</code>\n<code>System.out.println(b);</code>",answers:["anyMatch","allMatch","noneMatch","None of the above"]},{title:"What collector turns the stream at left to the Map at right?",code:null,answers:["grouping()","groupingBy()","partitioning()","partitioningBy()"]},{title:"Which fills in the blank for this code to print 667788?",code:"<code>IntStream ints = IntStream.empty();</code>\n<code>IntStream moreInts = IntStream.of(66, 77, 88);</code>\n<code>Stream.of(ints, moreInts).____________(x -&gt; x).forEach(System.out::print);</code>",answers:["flatMap","flatMapToInt","map","None of the above"]},{title:"Fill in the blank so this code prints 8.0. Note that it must not print OptionalDouble[8.0].",code:"<code>LongStream stream = LongStream.of(6, 10);</code>\n<code>LongSummaryStatistics stats = stream.summaryStatistics();</code>\n<code>System.out.println(____________);</code>",answers:["stats.avg()","stats.average()","stats.average().get()","stats.getAverage()"]},{title:"Which can independently fill in the blank to output No dessert today?",code:'<code>import java.util.*;</code>\n<code>public class Dessert {</code>\n<code>  public static void main(String[] yum) {</code>\n<code>    eatDessert(Optional.of("Cupcake"));</code>\n<code>  }</code>\n<code><span epub:type="pagebreak" id="Page_264"></span>  private static void eatDessert(Optional&lt;String&gt; opt) {</code>\n<code>     System.out.println(opt.____________);</code>\n<code>  }</code>\n<code>}</code>',answers:['get("No dessert today")','orElse("No dessert today")','orElseGet(() -> "No dessert today")',"None of the above"]},{title:"What does the following output?",code:"<code>Stream&lt;Character&gt; chars = Stream.generate(() \u2010&gt; 'a');</code>\n<code>chars.filter(c -&gt; c &lt; 'b')</code>\n<code>     .sorted()</code>\n<code>     .findFirst()</code>\n<code>     .ifPresent(System.out::print);</code>",answers:["a","The code runs successfully without any output.","The code enters an infinite loop.","The code compiles but throws an exception at runtime."]},{title:"How many of the following can fill in the blank to have the code print the single digit 9?",code:"<code>LongStream stream = LongStream.of(9);</code>\n<code>stream.____________(p -&gt; p).forEach(System.out::print);</code>",answers:["None","One","Two","Three"],ol:["mapToDouble","mapToInt","mapToLong"]},{title:"Suppose you have a stream with one element and the code  stream.xxxx.forEach(System.out::println). Filling in xxxx from  top to bottom in the table, how many elements can be printed out?",code:null,answers:["Zero or one, zero or more, exactly one","Zero or one, exactly one, zero or more","Zero or one, zero or more, zero or more","Exactly one, zero or more, zero or more"]},{title:"What is the output of the following?",code:"<code>Stream&lt;Character&gt; stream = Stream.of('c', 'b', 'a');</code>\n<code>System.out.println(stream.sorted().findFirst());</code>",answers:["It is guaranteed to print the single character a.","It can print any single character of a, b, or c.","The code does not compile.","None of the above"]},{title:"What is the output of the following?",code:"<code>public class Compete {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Stream&lt;Integer&gt; is = Stream.of(8, 6, 9);</code>\n<code>      Comparator&lt;Integer&gt; c = (a, b) \u2010&gt; a \u2010 b;</code>\n<code>      is.sort(c).forEach(System.out::print);</code>\n<code>  }</code>\n<code>}</code>",answers:["689","986","The code does not compile","The code compiles but throws an exception at runtime."]},{title:"What is the result of the following?",code:'<code>class Ballot {</code>\n<code>   private String name;</code>\n<code>   private int judgeNumber;</code>\n<code>   private int score;</code>\n<code>&nbsp;</code>\n<code>   public Ballot(String name, int judgeNumber, int score) {</code>\n<code>      this.name = name;</code>\n<code>      this.judgeNumber = judgeNumber;</code>\n<code>      this.score = score;</code>\n<code>   }</code>\n<code>   // all getters and setters</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code><span epub:type="pagebreak" id="Page_266"></span>public class Speaking {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Stream&lt;Ballot&gt; ballots = Stream.of(</code>\n<code>         new Ballot("Mario", 1, 10),</code>\n<code>         new Ballot("Christina", 1, 8),</code>\n<code>         new Ballot("Mario", 2, 9),</code>\n<code>         new Ballot("Christina", 2, 8)</code>\n<code>      );</code>\n<code>&nbsp;</code>\n<code>      Map&lt;String, Integer&gt; scores = ballots.collect(</code>\n<code>         groupingBy(Ballot::getName, summingInt(Ballot::getScore))); // w1</code>\n<code>      System.out.println(scores.get("Mario"));</code>\n<code>  }</code>\n<code>}</code>',answers:["The code prints 2.","The code prints 19.","The code does not compile due to line w1.","The code does not compile due to a different line."]},{title:"Which can fill in the blank so this code outputs true?",code:"<code>import java.util.function.*;</code>\n<code>import java.util.stream.*;</code>\n<code>&nbsp;</code>\n<code>public class HideAndSeek {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Stream&lt;Boolean&gt; hide = Stream.of(true, false, true);</code>\n<code>      boolean found = hide.filter(b -&gt; b).__________();</code>\n<code>      System.out.println(found);</code>\n<code>   }</code>\n<code>}</code>",answers:["Only anyMatch","Only allMatch","Both anyMatch and allMatch","The code does not compile with any of these options."]},{title:"What does the following output?",code:'<code>Set&lt;String&gt; set = new HashSet&lt;&gt;();</code>\n<code>set.add("tire-");</code>\n<code>List&lt;String&gt; list = new LinkedList&lt;&gt;();</code>\n<code>Deque&lt;String&gt; queue = new ArrayDeque&lt;&gt;();</code>\n<code>queue.push("wheel-");</code>\n<code><span epub:type="pagebreak" id="Page_267"></span>Stream.of(set, list, queue)</code>\n<code>   .flatMap(x -&gt; x)</code>\n<code>   .forEach(System.out::print);</code>',answers:["[tire-][wheel-]","tire-wheel-","None of the above","The code does not compile."]},{title:"When working with a Stream<String>, which of these types can be returned from the collect() terminal operator by passing arguments to Collectors.groupingBy()?",code:null,answers:["I","II","I and II","I, II, and III"],ol:["Map<Integer, List<String>>","Map<Boolean, HashSet<String>>","List<String>"]},{title:"Which line can replace line 18 without changing the output of the program?",code:"<code>1:   class Runner {</code>\n<code>2:      private int numberMinutes;</code>\n<code>3:      public Runner(int n) {</code>\n<code>4:         numberMinutes = n;</code>\n<code>5:      }</code>\n<code>6:      public int getNumberMinutes() {</code>\n<code>7:         return numberMinutes;</code>\n<code>8:      }</code>\n<code>9:      public boolean isFourMinuteMile() {</code>\n<code>10:        return numberMinutes &lt; 4*60;</code>\n<code>11:     }</code>\n<code>12:   }</code>\n<code>13:   public class Marathon {</code>\n<code>14:     public static void main(String[] args) {</code>\n<code>15:        Stream&lt;Runner&gt; runners = Stream.of(new Runner(250),</code>\n<code>16:           new Runner(600), new Runner(201));</code>\n<code>17:        long count = runners</code>\n<code>18:             .filter(Runner::isFourMinuteMile)</code>\n<code>19:             .count();</code>\n<code>20:        System.out.println(count);</code>\n<code>21:    }</code>\n<code>22:  }</code>",answers:[".map (Runner::isFourMinuteMile)",".mapToBool (Runner::isFourMinuteMile) .filter(b -> b == true)",".mapToBoolean (Runner::isFourMinuteMile) .filter(b -> b == true)","None of the above"]},{title:"Which method is not available on the IntSummaryStatistics class?",code:null,answers:["getCountAsLong()","getMax()","toString()","None of the above\u2014all three methods are available."]},{title:"Which can fill in the blank so this code outputs Caught it?",code:'<code>import java.util.*;</code>\n<code>public class Catch {</code>\n<code><span epub:type="pagebreak" id="Page_269"></span>   public static void main(String[] args) {</code>\n<code>      Optional opt = Optional.empty();</code>\n<code>      try {</code>\n<code>         apply(opt);</code>\n<code>      } catch (IllegalArgumentException e) {</code>\n<code>         System.out.println("Caught it");</code>\n<code>      }</code>\n<code>   }</code>\n<code>   private static void apply(Optional&lt;Exception&gt; opt) {</code>\n<code>      opt.__________(IllegalArgumentException::new);</code>\n<code>   }</code>\n<code>}</code>',answers:["orElse","orElseGet","orElseThrow","None of the above. The main() method does not compile."]},{title:"A developer tries to rewrite a method that uses flatMap() without using that intermediate operator. Which pair of method calls shows the withoutFlatMap() method is not equivalent to the withFlatMap() method?",code:'<code>public static void main(String[] args) {</code>\n<code>   List&lt;String&gt; list = new LinkedList&lt;&gt;();</code>\n<code>   Deque&lt;String&gt; queue = new ArrayDeque&lt;&gt;();</code>\n<code>   queue.push("all queued up");</code>\n<code>   queue.push("last");</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>private static void withFlatMap(Collection&lt;?&gt; coll) {</code>\n<code>   Stream.of(coll)</code>\n<code>      .flatMap(x -&gt; x.stream())</code>\n<code>      .forEach(System.out::print);</code>\n<code>   System.out.println();</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>private static void withoutFlatMap(Collection&lt;?&gt; coll) {</code>\n<code>   Stream.of(coll)</code>\n<code>      .filter(x -&gt; !x.isEmpty())</code>\n<code>      .map(x -&gt; x)</code>\n<code>      .forEach(System.out::print);</code>\n<code>   System.out.println();</code>\n<code>}</code>',answers:["withFlatMap(list); withoutFlatMap(list);","withFlatMap(queue); withoutFlatMap(queue);","Both pairs disprove the claim.","Neither pair disproves this claim."]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t],ol:e.ol}});i[23].imageUrl="./images/image-ocp-ch15-24.png",i[29].imageUrl="./images/image-ocp-ch15-30.png",t.default=i},171:function(e,t,o){"use strict";o.r(t);var n=["D. If no exception is thrown, then the catch block will not be executed. The try block is always visited first, followed by the finally block, which is guaranteed to execute regardless of whether an exception is thrown. For these reasons, Option D is the correct answer, with the statements in the correct order.","C. Unlike a try-with-resources statement, in which the catch and finally blocks are optional, a try statement requires a catch or finally block to be used, or both. For this reason, Option C is the correct answer.","D. The code does not compile because the throw keyword is incorrectly used in the toss() method declaration. The keyword throws should have been used instead. For this reason, Option D is the correct answer. Since LostBallException inherits Throwable and the main() method handles Throwable, LostBallException is handled by the main() method, making Option B incorrect. Option C is also incorrect because ArrayStoreException is an unchecked exception that extends RuntimeException and is not required to be handled or declared. Finally, if throws was used instead of throw, the entire application would compile without issue and print Caught!, making Option A the correct answer.","A. The only symbol permitted to separate exception types in a multi-catch statement is a single pipe character (|). For this reason, Option A is correct.","D. In Java, assert is a keyword, meaning it cannot be used as a variable, class, or method name. For this reason, line 5 does not compile. Line 6 also does not compile because the assert statement is not a method and does not support parentheses around both expressions. Because neither of these lines compile, Option D is the correct answer.","C. First off, Error is an unchecked exception. It is recommended that Error not be caught by most application processes, making Option A incorrect. IllegalStateException inherits RuntimeException, both of which are unchecked, making Options B and D, respectively, incorrect. Option C is correct because ParseException must be handled or declared.","D. The Exception class contains multiple constructors, including one that takes Throwable, one that takes String, and a no-argument constructor. The first WhaleSharkException constructor compiles, using the Exception constructor that takes a String. The second WhaleSharkException constructor also compiles. The two statements, super() and new Exception(), actually call the same constructor in the Exception class, one after another. The last WhaleSharkException compiles with the compiler inserting the default no-argument constructor super(), because it exists in the Exception class. For these reasons, all of the constructors compile, and Option D is the correct answer.","B. The UnsupportedOperationException class is an unchecked exception, which means it inherits from RuntimeException. While Error also is an unchecked exception, the diagram indicates that the class does not inherit from Error. There is only one class between Throwable and RuntimeException in the diagram, and since we know RuntimeException inherits Exception, the other missing class must be Exception. For these reasons, Option B is the correct answer.","C. The code does not compile because the variable b is used twice in the main() method, both in the method declaration and in the catch block, making Option C the correct answer. If a different variable name was used in one of the locations, the program would print one line, complete, making Option A the correct answer. Note that while an exception is created inside the turnOn() method, it is not thrown.","D. First off, unless assertions are enabled at runtime, no assertion statement guarantees an assertion will be thrown at runtime, making Option D the correct answer. Next, Option A does not compile because the assert statement is not a method and does not take arguments in parentheses. It\u2019s also invalid because it requires a boolean expression for the first expression, not a numeric one. An additional value can be specified, but it requires a colon separator (:). Option B would be the correct answer and trigger an error if assertions are enabled, since 0==1 evaluates to false. Option C is incorrect. Even if assertions were enabled, it would not trigger an error since 0==0 evaluates to true.","C. The class does not compile because in line r2, brackets {} are used instead of parentheses () in the try-with-resources statement, making Option C the correct answer. If this line was fixed to use parentheses (), then the rest of the class would compile without issue and print This just in! at runtime, making Option A the correct answer.","C. When both a try block and close() method throw exceptions, the one in the try block is the primary, while the one in the close() method is suppressed. For this reason, Option A is a true statement. Option B is also a true statement, since a catch block is not required when using a try-with-resources statement. Option C is the correct answer, since resources are closed in reverse order in which they are created, not the other way around. Option D is a true statement because multiple resources can be declared within a single set of parentheses, each separated by a semicolon (;).","A. The program compiles without issue, so Option D is incorrect. The narrower SpellingException and NullPointerException, which inherit from Exception, are correctly presented in the first catch block, with the broader Exception being in the second catch block. The if-then statement evaluates to true, and a new SpellingException instance is created, but it is not thrown because it is missing the throw keyword. For this reason, the try block ends without any of the catch blocks being executed. The finally block is then called, making it the only section of code in the program that prints a line of text. For this reason, Option A is the correct answer.","C. First off, the try block is capable of throwing two checked exceptions, MissingMoneyException and MissingFoodException. The catch block uses the Exception class to handle this, since both have Exception as a supertype. It then rethrows the Exception. For this reason, Exception would be appropriate in the blank, making the first statement correct. The compiler is also smart enough to know that there are only two possible subclasses of Exception that can actually be thrown in the main() method, so declaring MissingMoneyException and MissingFoodException together also allows the code to compile, making the third statement correct. The second statement, only inserting MissingMoneyException, would not allow the code to compile because the main() method could throw a checked MissingFoodException that was not handled. For these reasons, Option C is the correct answer.","C. First off, Closeable extends AutoCloseable, making Option A incorrect. The difference between the two is that the close() method in AutoCloseable throws Exception, while the close() method in Closeable throws IOException, making Option D incorrect. Since IOException is a subclass of Exception, both close() methods can throw an IOException, making Option B incorrect. On the other hand, Exception is not a subclass of IOException. For this reason, the close() method in a class that implements Closeable cannot throw an instance of the Exception class, because it is an invalid override using a broader exception type, making Option C the correct answer.","B. Option A does not compile because a multi-catch expression uses a single variable, not two variables. Option C does not compile because it is not possible to throw this checked IOException in the try block. Option D does not compile because multi-catch blocks cannot contain two exceptions in which one is a subclass of the other. If it did, one of the two exceptions would be redundant. Option B is the correct answer and the only expression that allows the class to compile. While both exceptions in the multi-catch block inherit from Exception, neither is a subclass of the other.","C. First off, the order of exceptions in a multi-catch does not matter, only that they not be subclasses of one another, making Options A and B incorrect. Option C is the correct answer because a multi-catch variable is effectively final. Java forbids reassigning of multi-catch variables since it is unclear what the precise reference type is. Option D is incorrect because a multi-catch with a single exception type is just a regular catch block. A regular catch variable is not required to be effectively final and can be reassigned within the catch block.","D. The code does not compile, so Option A is incorrect. The first compilation error is that Shelf does not implement AutoCloseable, meaning a try-with-resources statement cannot be used. Even though Shelf does implement Closing, an interface that uses the same abstract method signature as AutoCloseable, the JVM requires AutoCloseable be implemented to use try-with-resources. The second compilation problem is that throws is used instead of throw inside the try block. Remember that throws is only used in method signatures. The third compilation issue is that the order of exceptions in the two catch blocks are reversed. Since Exception will catch all IllegalArgumentException instances, the second catch block is unreachable. The final compilation error is that the shelf variable is used in the finally block, which is out of scope. Remember that the scope of try-with-resources variables ends when the try statement is complete. For these four reasons, Option D is the correct answer.","A. Option A is the correct answer. Any catch or finally blocks used with a try-with-resources statement are executed after the declared resources have been closed, not before. Options B and C are true statements, since Closeable extends AutoCloseable and the requirement for try-with-resources is that they must be of type AutoCloseable. Finally, Option D is a true statement and one of the primary motivations for using try-with-resources statements.","D. The optional second parameter of an assert statement, when used, must return a value. The second assert statement uses System.out.print() as its second parameter, which has a return type of void. For this reason, the code does not compile, making Option D the correct answer. Other than this one line, the rest of the class compiles without issue.","D. Only one of the classes, MissingResourceException, inherits from the unchecked RuntimeException class, making Option D the correct answer. In fact, IOException and SQLException extend the checked Exception class directly. The NotSerializableException is also checked, since it is a subclass of IOException via ObjectStreamException.","D. The code does not compile, making Options A and B incorrect. The declaration of weatherTracker uses an anonymous inner class that correctly overrides the close() method. Remember that overridden methods cannot throw any new or broader checked exceptions than the inherited method. Alternatively, they can avoid throwing inherited checked exceptions or declare new unchecked exceptions, such as RuntimeException. The compilation error is in the catch block of the main() method, where the weatherTracker variable is out of scope. In try-with-resources statements, the resources are only accessible in the try block. For this reason, Option D is the correct answer.","A. Asserts can be enabled by using the command-line options -ea or -enableassertions and disabled by using -da or -disableassertions. Passing -di does not enable or disable assertions, making Option A the correct answer.","A. The application compiles without issue and prints Hello, making Option A the correct answer. The ReadSign and MakeSign classes are both correctly implemented, with both overridden versions of close() dropping the checked exception. The try-with-resources statement is also correctly implemented for two resources and does not cause any compilation errors or runtime exceptions. Note that the semicolon (;) after the second resource declaration is optional.","B. The code compiles, so Option D is incorrect. The order of evaluation for a try-with-resources statement is that the resources are closed before any associated catch or finally blocks are executed. For this reason, 2 is printed first, followed by 1. The ArithmeticException is then caught and 3 is printed. The last value printed is 4, since the finally block runs at the end. For these reasons, Option B is the correct answer.","B. First off, Option A is an incorrect statement because the AutoCloseable interface does not define a default implementation of close(). Next, the close() method should be idempotent, which means it is able to be run multiple times without triggering any side effects. For this reason, Option B is correct. After being run once, future calls to close() should not change any data. Option C is incorrect because the close() method is fully capable of throwing exceptions. In fact, the signature of the method in AutoCloseable throws a checked Exception, although classes that override it may choose to drop the checked exception. Option D is incorrect because the return type of close() is void, which means no return value can be returned.","D. The play() method compiles without issue, rethrowing a wrapped exception in the catch block. While the main() method does declare RuntimeException, it does not declare or catch the Exception thrown by the calls to play(). Even though the play() method does not appear to actually throw an instance of Exception, because it is declared, the main() method must catch or declare it. Since the checked exception is not handled, the main() method does not compile, and Option D is the correct answer. If the main() method was changed to declare the appropriate checked exception, then the rest of the code would compile, and exactly one exception would be printed, making Option A the correct answer.","B. Assertions are often used to check method post conditions, test control flow invariants, and validate class invariants, making Options A, C, and D true statements. Option B is the correct answer. An assertion should never modify any data because it may be disabled at runtime, leading to unintended side effects.","B. A multi-catch block cannot contain two exceptions in which one is a subclass of the other, since it is a redundant expression. Since CarCrash is a subclass of RuntimeException and RuntimeException is a subclass of Exception, line w2 contains a compilation error, making Option B the correct answer. The rest of the lines of code do not contain any compilation errors.","B. First off, a class must inherit from RuntimeException or Error to be considered an unchecked exception. Dopey and Grumpy both are subclasses of Exception, but not RuntimeException, making them both checked exceptions. Since IOException is a checked exception, the subclass Happy is also a checked exception. Sleepy extends IllegalStateException, which is an unchecked exception that extends RuntimeException. Finally, Sneezy extends Throwable, which does not inherit RuntimeException or Error, making it a checked exception. Therefore, there are a total of four checked exceptions and one unchecked exception within the classes listed here. Since there are no compilation errors in any of the class declarations, Option B is the correct answer, with the first and third statement being true.","D. The close() method in each of the resources throws an Exception, which must be handled or declared in the main() method. The catch block supports TimeException, but it is too narrow to catch Exception. Since there are no other catch blocks present and the main() method does not declare Exception, the try-with-resources statement does not compile, and Option D is the correct answer. If the catch block was modified to handle Exception instead of TimeException, the code would compile without issue and print 3215 at runtime, closing the resources in the reverse order in which they were declared and making Option B the correct answer.","A. The try-catch block already catches Exception, so the correct answer would be the one that is not a subclass of Exception. In this case, Error extends Throwable and is the only choice that allows the code to compile. Because IllegalStateException and RingException both inherit from Exception, Options B and C, respectively, are incorrect. Finally, Option D is incorrect because there is an answer choice that allows the code to compile.","B. Option A does not compile because the assignment (age=2) has a value of int, not boolean, which is required for an assert statement. Option B compiles without issue and is the correct answer. Even though Error and 10 are different data types, String and int respectively, the second assert parameter only needs to be a value, so both are allowed. Option C does not compile because the usage of the lambda expression does not match a functional interface. Option D is incorrect because a return statement is not allowed in the second expression of an assert statement.","D. The MissedCallException is a checked exception since it extends Exception and does not inherit RuntimeException. For this reason, the first catch block fails to compile, since the compiler detects that it is not possible to throw this checked exception inside the try block, making Option D the correct answer. Note that if MissedCallException was changed to extend the checked RuntimeException, then the code would compile and the RuntimeException from the finally block would replace the ArrayIndexOutOfBoundsException from the try block in the message reported to the caller, making Option C the correct answer.","D. The catch variable d is of type BearException that cannot be assigned an instance of the superclass RuntimeException without an explicit cast. For this reason, the first catch block does not compile in tellStory(). The second catch block also does not compile, albeit for a slightly different reason. A catch variable in a multi-catch block must be effectively final because the precise type is not known until runtime. Therefore, the compiler does not allow the variable e to be reassigned. For these two reasons, Option D is the correct answer. Note that the first catch block does allow the catch variable d to be reassigned, it just must be to a class that inherits BearException or is an instance of BearException.","D. The play() method declares two checked exceptions, OutOfTuneException and FileNotFoundException, which are handled in the main() method\u2019s catch block using the Exception type. The catch block then rethrows the Exception. The compiler is smart enough to know that only two possible checked exceptions can be thrown here, but they both must be handled or declared. Since the main() method only declares one of the two checked exceptions, FileNotFoundException is not handled, and the code does not compile. For this reason, Option D is the correct answer. Note that the main() could have also handled or declared Exception, since both checked exceptions inherit it. If the main() method had declared Exception, then Song finished! would have been printed followed by a stack trace, making Option C the correct answer.","C. The code compiles without issue, making Option D incorrect. Option A is incorrect because assertions are not enabled by default in Java. Therefore, the code will run without throwing any exceptions. Option B is also incorrect because the command enables assertions everywhere but disables them for the Falcon class. Option C is the correct answer, with the command disabling assertions everywhere except in the Falcon class, causing an AssertionError to be thrown at runtime.","C. The Closeable interface defines a close() method that throws IOException. The overridden implementation of MyDatabase, which implements Closeable, declares a SQLException. This is a new checked exception not found in the inherited method signature. Therefore, the method override is invalid and the close() method in MyDatabase does not compile, making Option C the correct answer.","D. The code does not compile because the close() method throws an Exception that is not handled or declared in the main() method, making Option D the correct answer. When a try-with-resources statement is used with a close() method that throws a checked exception, it must be handled by the method or caught within the try-with-resources statement. ","B. The code compiles without issue, making Option C incorrect. In the climb() method, two exceptions are thrown. One is thrown by the close() method and the other by the try block. The exception thrown in the try block is considered the primary exception and reported to the caller on line e1, while the exception thrown by the close() method is suppressed. For this reason, java.lang.RuntimeException is thrown to the main() method, and Option B is the correct answer."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"If a try, a catch, and a finally statement are used together but no exception is generated, which blocks are executed and in which order?",code:null,answers:["try","try, catch","try, catch, finally","try, finally"]},{title:"Fill in the blanks: A try statement__________ a catch or a finally block, while a try-with-resources statement __________.",code:null,answers:["is not required to contain, is not required to contain either","is not required to contain, must contain one of them","must contain, is not required to contain either","must contain, must contain a catch block"]},{title:"What is the output of the following application?",code:'<code>package park;</code>\n<code>&nbsp;</code>\n<code>class LostBallException extends Exception {}</code>\n<code>public class Ball {</code>\n<code>   public void toss() throw LostBallException {</code>\n<code>      throw new ArrayStoreException();</code>\n<code>   }</code>\n<code>   public static void main(String[] bouncy) {</code>\n<code>      try {</code>\n<code>         new Ball().toss();</code>\n<code>      } catch (Throwable e) {</code>\n<code>         System.out.print("Caught!");</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["Caught!","The code does not compile because LostBallException is not handled or declared in the main() method.","The code does not compile because ArrayStoreException is not handled or declared in the toss() method.","The code does not compile for a different reason."]},{title:"Which symbol(s) can be used to separate exception types in a multi-catch statement?",code:null,answers:["II only","III only","II and III","I, II, and III"],ol:["&","|","||"]},{title:"What is the result of executing the following application with assertions enabled?",code:'<code>1: package ice;</code>\n<code>2: public class Igloo {</code>\n<code>3:    public static void main(String[] bricks) {</code>\n<code>4:       int flakes = 10;</code>\n<code>5:       double assert = 7.0;</code>\n<code>6:       assert (true :"");</code>\n<code>7:       assert flakes++&gt;5;</code>\n<code>8:    }</code>\n<code>9: }</code>',answers:["It throws an AssertionError at runtime.","It prints nothing at runtime.","Exactly one line of code does not compile.","Two lines of code do not compile."]},{title:"Which of the following classes is a checked exception?",code:null,answers:["java.lang.Error","java.lang.IllegalStateException","java.text.ParseException","java.lang.RuntimeException"]},{title:"How many constructors in WhaleSharkException compile in the following class?",code:'<code>package friendly;</code>\n<code>public class WhaleSharkException extends Exception {</code>\n<code>   public WhaleSharkException() {</code>\n<code>      super("Friendly shark!");</code>\n<code>   }</code>\n<code>&nbsp;</code>\n<code>   public WhaleSharkException(String message) {</code>\n<code>      super(new Exception(new WhaleSharkException()));</code>\n<code>   }</code>\n<code>&nbsp;</code>\n<code>   public WhaleSharkException(Exception cause) {}</code>\n<code>}</code>',answers:["None","One","Two","Three"]},{title:"Given the following class diagram, which two classes are missing in the hierarchy starting with the bottom and going upward?",code:null,answers:["IOException, Exception","RuntimeException, Exception","IllegalArgumentException, RuntimeException","IllegalStateException, RuntimeException"]},{title:"How many lines of text does the following program print?",code:'<code>package lighting;</code>\n<code>import java.io.IOException;</code>\n<code>public class Light {</code>\n<code>   public void turnOn() throws IOException {</code>\n<code>      new IOException("Not ready");</code>\n<code>   }</code>\n<code>   public static void main(String[] b) throws Exception {</code>\n<code>      try {</code>\n<code>         new Light().turnOn();</code>\n<code>      } catch (RuntimeException b) {  // y1</code>\n<code>         System.out.println(b);</code>\n<code>         throw new IOException();  // y2</code>\n<code>      } finally {</code>\n<code>         System.out.println("complete");</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["One","Two","The code does not compile because of line y1.","The code does not compile because of line y2."]},{title:"Which statement, when inserted into the main() method of a program, guarantees an AssertionError will be thrown at runtime?",code:null,answers:['assert(0,"Invalid");',"assert 0==1;","assert 0==0;","None of the above"]},{title:"What is the output of the following application?",code:'<code>package paper;</code>\n<code>import java.io.Closeable;</code>\n<code>public class PrintCompany {</code>\n<code>   class Printer implements Closeable {  // r1</code>\n<code>      public void print() {</code>\n<code>         System.out.println("This just in!");</code>\n<code>      }</code>\n<code>      public void close() {}</code>\n<code>   }</code>\n<code>   public void printHeadlines() {</code>\n<code>      try {Printer p = new Printer()} {  // r2</code>\n<code>         p.print();</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] headlines) {</code>\n<code>      new PrintCompany().printHeadlines();  // r3</code>\n<code>   }</code>\n<code>}</code>',answers:["This just in!","The code does not compile because of line r1.","The code does not compile because of line r2.","The code does not compile because of line r3."]},{title:"Which statement about try-with-resources is not true?",code:null,answers:["If the try block and close() method both throw an exception, the one thrown by the close() method is suppressed.","A catch block is not required.","If more than one resource is used, the resources are closed in the order they were  created.","Parentheses are used for the resource declaration section, even if more than one resource is used."]},{title:"How many lines of text does the following program print?",code:'<code>package bee;</code>\n<code>class SpellingException extends RuntimeException {}</code>\n<code>public class SpellChecker {</code>\n<code>   public final static void main(String... participants) {</code>\n<code>      try {</code>\n<code>         if(!"cat".equals("kat")) {</code>\n<code>            new SpellingException();</code>\n<code>         }</code>\n<code>      } catch (SpellingException | NullPointerException e) {</code>\n<code>         System.out.println("Spelling problem!");</code>\n<code>      } catch (Exception e) {</code>\n<code>         System.out.println("Unknown Problem!");</code>\n<code>      } finally {</code>\n<code>         System.out.println("Done!");</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["One","Two","Three","The code does not compile."]},{title:"Which exception classes, when inserted into the blank in the Problems class, allow the code to compile?",code:'<code>package more;</code>\n<code>class MissingMoneyException extends Exception {}</code>\n<code>class MissingFoodException extends Exception {}</code>\n<code>public class Problems {</code>\n<code>   public void doIHaveAProblem() throws MissingMoneyException,          MissingFoodException {</code>\n<code>      System.out.println("No problems");</code>\n<code>   }</code>\n<code>   public static void main(String[] lots) throws  ________________{</code>\n<code>      try {</code>\n<code>         final Problems p = new Problems();</code>\n<code>         p.doIHaveAProblem();</code>\n<code>      } catch (Exception e) {</code>\n<code><span epub:type="pagebreak" id="Page_277"></span>         throw e;</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["I only","III only","I and III","I, II, and II"],ol:["Exception","MissingMoneyException","MissingMoneyException, MissingFoodException"]},{title:"Which statement about Closeable and AutoCloseable is true?",code:null,answers:["AutoCloseable extends Closeable.","The close() method in a class that implements AutoCloseable cannot throw an IOException.","The close() method in a class that implements Closeable cannot throw an  Exception.","There is no difference; one was added for backward compatibility."]},{title:"Which expression, when inserted into the blank in the following class, allows the code to compile?",code:"<code>package sun;</code>\n<code>import java.io.*;</code>\n<code>public class Beach {</code>\n<code>   class TideException extends Exception {}</code>\n<code>   public void surf() throws RuntimeException {</code>\n<code>      try {</code>\n<code>         throw new TideException();</code>\n<code>      } catch (________________) {}</code>\n<code>   }</code>\n<code>}</code>",answers:["Exception a | RuntimeException f","IllegalStateException | TideException t","TideException | IOException i","TideException | Exception x"]},{title:"Which statement about a multi-catch statement is true?",code:null,answers:["The exception types must be ordered from broadest to narrowest.","The exception types must be ordered from narrowest to broadest.","The variable of a multi-catch block with more than one exception cannot be reassigned within the block.","The variable of a multi-catch block with one exception type cannot be reassigned within the block."]},{title:"Given the following class, how many lines contain compilation errors?",code:"<code>package move;</code>\n<code>interface Closing {</code>\n<code>   void close() throws Exception;</code>\n<code>}</code>\n<code>class Shelf implements Closing {</code>\n<code>   public void close() throws Exception {}</code>\n<code>}</code>\n<code>public class Step {</code>\n<code>   static {</code>\n<code>      try (Shelf shelf = new Shelf()) {</code>\n<code>         throws new IllegalArgumentException();</code>\n<code>      } catch (Exception e) {</code>\n<code>      } catch (IllegalArgumentException e) {</code>\n<code>      } finally {</code>\n<code>         shelf.close();</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>",answers:["None","Two","Three","Four"]},{title:"Which of the following is not true of using a try-with-resources statement?",code:null,answers:["Associated catch blocks are run before the declared resources have been closed.","It is compatible with all classes that implement the AutoCloseable interface.","It is compatible with all classes that implement the Closeable interface.","It shortens the amount of code a developer must write."]},{title:"Assuming the following application is executed with assertions enabled, what is the result?",code:'<code>package input;</code>\n<code>public class DataIntegrity {</code>\n<code>   private int score;</code>\n<code>   public DataIntegrity() {</code>\n<code>      super();</code>\n<code>      DataIntegrity.this.score = 5;</code>\n<code>   }</code>\n<code>   public static void main(String[] books) {</code>\n<code>      final DataIntegrity johnny5 = new DataIntegrity();</code>\n<code>      assert(johnny5.score&gt;2) : johnny5.score++;</code>\n<code>      assert johnny5.score&gt;=5 : System.out.print("No input");</code>\n<code>      System.out.print("Made it!");</code>\n<code>   }</code>\n<code>}</code>',answers:["An AssertionError is thrown with a message of 5.","An AssertionError is thrown with a message of No input.","Made it! is printed.","The code does not compile."]},{title:"Which of the following classes is an unchecked exception?",code:null,answers:["java.io.IOException","java.io.NotSerializableException","java.sql.SQLException","java.util.MissingResourceException"]},{title:"What is the result of compiling and executing the following class?",code:'<code>package wind;</code>\n<code>public class Storm {</code>\n<code>   public static void main(String... rain) throws Exception {</code>\n<code>      try (final AutoCloseable weatherTracker = new AutoCloseable() {</code>\n<code>         public void close() throws RuntimeException {}</code>\n<code>      }) {</code>\n<code>         System.out.println(weatherTracker.toString());</code>\n<code>      } catch (Exception e) {</code>\n<code>         if(weatherTracker != null) {</code>\n<code>            weatherTracker.close();</code>\n<code>         }</code>\n<code><span epub:type="pagebreak" id="Page_280"></span>      } finally {</code>\n<code>         System.out.println("Storm gone");</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["It prints one line.","It prints two lines.","It does not compile due to an error in the declaration of the weatherTracker resource.","It does not compile for a different reason."]},{title:"Which of the following is not a command that enables or disables assertions at runtime?",code:null,answers:["-di","-disableassertions","-ea","-enableassertions"]},{title:"What is the output of the following application?",code:'<code>package signlanguage;</code>\n<code>import java.io.Closeable;</code>\n<code>class ReadSign implements Closeable {</code>\n<code>   public void close() {}</code>\n<code>   public String get() {return "Hello";}</code>\n<code>}</code>\n<code>class MakeSign implements AutoCloseable {</code>\n<code>   public void close() {}</code>\n<code>   public void send(String message) {</code>\n<code>      System.out.print(message);</code>\n<code>   }</code>\n<code>}</code>\n<code>public class Translate {</code>\n<code>   public static void main(String... hands) {</code>\n<code>      try (ReadSign r = new ReadSign();</code>\n<code>         MakeSign w = new MakeSign();) {</code>\n<code>         w.send(r.get());</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["Hello","The code does not compile because of the ReadSign class.","The code does not compile because of the try-with-resources statement.","None of the above"]},{title:"What is the output of the following application?",code:'<code>package what;</code>\n<code>class FunEvent implements AutoCloseable {</code>\n<code>   public void close() {</code>\n<code>      System.out.print("1");</code>\n<code>   }</code>\n<code>}</code>\n<code>public class Happening {</code>\n<code>   public static void main(String... lots) {</code>\n<code>      try (FunEvent f = new FunEvent()) {</code>\n<code>         System.out.print("2");</code>\n<code>         throw new ArithmeticException();</code>\n<code>      } catch (Exception e) {</code>\n<code>         System.out.print("3");</code>\n<code>      } finally {</code>\n<code>         System.out.print("4");</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["214","2134","2314","The code does not compile."]},{title:"Which statement best describes how a class that implements the AutoCloseable interface should be written?",code:null,answers:["The close() method is optional since the AutoCloseable interface defines a default implementation.","The close() method should avoid modifying data after it has been run once.","The close() method should not throw any exceptions.","The close() method should return a status code."]},{title:"Which statement about the following program is correct?",code:'<code>package dogpark;</code>\n<code>public class Fetch {</code>\n<code>   public int play(String dogName) throws Exception {</code>\n<code>      try {</code>\n<code>         throw new RuntimeException(dogName);</code>\n<code>      } catch (Exception e) {</code>\n<code>         throw new RuntimeException(e);</code>\n<code>      }</code>\n<code>   }</code>\n<code><span epub:type="pagebreak" id="Page_282"></span>   public static final void main(String[] ball) throws RuntimeException {</code>\n<code>      new Fetch().play("Webby");</code>\n<code>      new Fetch().play("Georgette");</code>\n<code>   }</code>\n<code>}</code>',answers:["The program prints one exception at runtime.","The program prints two exceptions at runtime.","The class does not compile because of the play() method.","The class does not compile because of the main() method."]},{title:"Which of the following is not a good use of assertions?",code:null,answers:["Check method post conditions.","Modify local variables.","Test control flow invariants.","Validate class invariants."]},{title:"Which statement about the following application is correct?",code:'<code>package highway;</code>\n<code>import java.io.*;</code>\n<code>class CarCrash extends RuntimeException {}</code>\n<code>public class Car {</code>\n<code>   public static void main(String[] seatbelts) throws Exception {  // w1</code>\n<code>      try {</code>\n<code>         throw new IOException("Auto-pilot error");</code>\n<code>      } catch (Exception | CarCrash e) {  // w2</code>\n<code>         throw e;</code>\n<code>      } catch (Exception a) {  // w3</code>\n<code>         throw a;</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["The code does not compile because of line w1.","The code does not compile because of line w2.","The code does not compile because of line w3.","The code compiles and runs without issue."]},{title:"Which statements about the following classes are true?",code:"<code>public class Dopey extends Grumpy {}</code>\n<code>public class Grumpy extends Exception {}</code>\n<code>public class Happy extends IOException {}</code>\n<code>public class Sleepy extends IllegalStateException {}</code>\n<code>public class Sneezy extends Throwable {}</code>",answers:["I only","I and III","II and III","I, II, and III"],ol:["Four of the classes are checked exceptions.","Two of the classes are unchecked exceptions.","None of the class declarations contain any compilation errors."]},{title:"What is the output of the following application?",code:"<code>package vortex;</code>\n<code>class TimeException extends Exception {}</code>\n<code>class TimeMachine implements AutoCloseable {</code>\n<code>   int v;</code>\n<code>   public TimeMachine(int v) {this.v = v;}</code>\n<code>   public void close() throws Exception {</code>\n<code>      System.out.print(v);</code>\n<code>   }</code>\n<code>}</code>\n<code>public class TimeTraveler {</code>\n<code>   public static void main(String[] twelve) {</code>\n<code>      try (TimeMachine timeSled = new TimeMachine(1);</code>\n<code>            TimeMachine delorean = new TimeMachine(2);</code>\n<code>            TimeMachine tardis = new TimeMachine(3)) {</code>\n<code>      } catch (TimeException e) {</code>\n<code>         System.out.print(4);</code>\n<code>      } finally {</code>\n<code>         System.out.print(5);</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>",answers:["1235","3215","41235","The code does not compile."]},{title:"Which expression, when inserted into the blank in the following class, allows the code to compile?",code:"<code>package music;</code>\n<code>public class Bells {</code>\n<code>   class Player implements AutoCloseable {</code>\n<code>      @Override public void close() throws RingException {}</code>\n<code>   }</code>\n<code>   class RingException extends Exception {</code>\n<code>      public RingException(String message) {}</code>\n<code>   }</code>\n<code>   public static void main(String[] notes) throws Throwable {</code>\n<code>      try (Player p = null) {</code>\n<code>         throw new Exception();</code>\n<code>      } catch (Exception e) {</code>\n<code>      } catch (_______________) {</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>",answers:["Error r","IllegalStateException b","RingException p","The code does not compile regardless of the expression used."]},{title:"Given the following two variables, which assertion statement compiles successfully?",code:'<code>int age = 22;</code>\n<code>final String name = "Josephine";</code>',answers:["assert (age=2);",'assert age!=age : (1<age ? "Error" : 10);','assert name.equals("") : () -> "Oops";','assert name.length()<(long)age : return "Mistake";']},{title:"Which statement about the following program is true?",code:'<code>package tag;</code>\n<code>class MissedCallException extends Exception {}</code>\n<code>public class Phone {</code>\n<code>   static void makeCall() throws RuntimeException {</code>\n<code>      throw new ArrayIndexOutOfBoundsException("Call");</code>\n<code>   }</code>\n<code>   public static void main(String[] messages) {</code>\n<code><span epub:type="pagebreak" id="Page_285"></span>      try {</code>\n<code>         makeCall();</code>\n<code>      } catch (MissedCallException e) {</code>\n<code>         throw new RuntimeException("Voicemail");</code>\n<code>      } finally {</code>\n<code>         throw new RuntimeException("Text");</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["An exception is printed at runtime with Call in the message.","An exception is printed at runtime with Voicemail in the message.","An exception is printed at runtime with Text in the message.","The code does not compile."]},{title:"Which statement about the following program is correct?",code:"<code>package fairy;</code>\n<code>public class Tale {</code>\n<code>   class BearException extends RuntimeException {}</code>\n<code>   class WolfException extends RuntimeException {}</code>\n<code>   class DragonException extends RuntimeException {}</code>\n<code>   public int tellStory() {</code>\n<code>      try {} catch (BearException d) {</code>\n<code>         d = new RuntimeException();</code>\n<code>         throw d;</code>\n<code>      } catch (WolfException | DragonException e) {</code>\n<code>         e = new RuntimeException();</code>\n<code>         throw e;</code>\n<code>      }</code>\n<code>      return 3;</code>\n<code>   }</code>\n<code>   public static void main(String... wand) throws RuntimeException{</code>\n<code>      new Tale().tellStory();</code>\n<code>   }</code>\n<code>}</code>",answers:["The class compiles and does not print anything at runtime.","The code does not compile solely due to the first catch block in tellStory().","The code does not compile solely due to the second catch block in tellStory().","The code does not compile due to errors in both catch blocks in tellStory()."]},{title:"What is the output of the following application?",code:'<code>package classical;</code>\n<code>import java.io.*;</code>\n<code>class OutOfTuneException extends Exception {</code>\n<code>   OutOfTuneException(String message) { super(message); }</code>\n<code>}</code>\n<code>public class Piano {</code>\n<code>   public void play() throws OutOfTuneException, FileNotFoundException {</code>\n<code>      throw new OutOfTuneException("Sour note!");</code>\n<code>   }</code>\n<code>   public static void main(String... keys) throws OutOfTuneException {</code>\n<code>      final Piano piano = new Piano();</code>\n<code>      try {</code>\n<code>         piano.play();</code>\n<code>      } catch (Exception e) {</code>\n<code>         throw e;</code>\n<code>      } finally {</code>\n<code>         System.out.println("Song finished!");</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["Song finished!","An exception is printed with Sour note! in the stack trace.","Both of the above","None of the above"]},{title:"Given the following class, which command causes the class to throw an AssertionError at runtime?",code:"<code>public class Falcon extends Exception {</code>\n<code>   private int parsec = 12;</code>\n<code>   public Falcon(String name) {</code>\n<code>      super(name);</code>\n<code>   }</code>\n<code>   public static void main(String[] aluminum) {</code>\n<code>      assert new Falcon(null).parsec&lt;12;</code>\n<code>   }</code>\n<code>}</code>",answers:["java Falcon","java -ea -da:Falcon Falcon","java -da -ea:Falcon Falcon","The code does not compile."]},{title:"What is the output of the following application?",code:'<code>package db;</code>\n<code>import java.io.*;</code>\n<code>import java.sql.*;</code>\n<code>public class DatabaseHelper {</code>\n<code>   static class MyDatabase implements Closeable {</code>\n<code>      public void close() throws SQLException {</code>\n<code>         System.out.print("2");</code>\n<code>      }</code>\n<code>      public void write(String data) {}</code>\n<code>      public String read() {return null;}</code>\n<code>   }</code>\n<code>   public static void main(String... files) throws Exception {</code>\n<code>      try (MyDatabase myDb = new MyDatabase()) {</code>\n<code>         // TODO: Decide what to read/rite</code>\n<code>      } finally {</code>\n<code>         System.out.print("1");</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["12","21","The code does not compile because of the MyDatabase class.","The code does not compile because of the try-with-resources statement."]},{title:"How many lines of text does the following program print?",code:'<code>package tron;</code>\n<code>class DiskPlayer implements AutoCloseable {</code>\n<code>   public void close() throws Exception {}</code>\n<code>}</code>\n<code>public class LightCycle {</code>\n<code>   public static void main(String... bits) {</code>\n<code>      try (DiskPlayer john = new DiskPlayer()) {</code>\n<code>         System.out.println("ping");</code>\n<code>      } finally {</code>\n<code>         System.out.println("pong");</code>\n<code>      }</code>\n<code><span epub:type="pagebreak" id="Page_288"></span>      System.out.println("return");</code>\n<code>   }</code>\n<code>}</code>',answers:["One","Two","Three","The code does not compile."]},{title:"Given the application below, what is the name of the class printed at line e1?",code:"<code>package canyon;</code>\n<code>final class FallenException extends Exception {}</code>\n<code>final class HikingGear implements AutoCloseable {</code>\n<code>   @Override public void close() throws Exception {</code>\n<code>      throw new FallenException();</code>\n<code>   }</code>\n<code>}</code>\n<code>public class Cliff {</code>\n<code>   public final void climb() throws Exception {</code>\n<code>      try (HikingGear gear = new HikingGear()) {</code>\n<code>         throw new RuntimeException();</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String... rocks) {</code>\n<code>      try {</code>\n<code>         new Cliff().climb();</code>\n<code>      } catch (Throwable t) {</code>\n<code>         System.out.println(t);  // e1</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>",answers:["canyon.FallenException","java.lang.RuntimeException","The code does not compile.","The code compiles, but the answer cannot be determined until runtime."]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t],ol:e.ol}});i[7].imageUrl="./images/image-ocp-ch16-8.png",t.default=i},172:function(e,t,o){"use strict";o.r(t);var n=["C. The date and time classes added in Java 8 are in the java.time package, making Option C correct. The older date classes are in the java.util package.","A. The Duration class is used to reflect an amount of time using small units like minutes. Since it just uses units of time, it does not involve time zones. The LocalTime class contains units of hours, minutes, seconds, and fractional seconds. The LocalDateTime class contains all the data in a LocalTime and adds on a year, month, and date. Neither of these classes uses time zones. There is a ZonedDateTime class when you need to use time zones. Since none of the three classes listed includes a time zone, Option A is correct.","A. A Period is measured in days, weeks, months, or years. A Duration is measured in smaller units like minutes or seconds. Only Duration has a getSeconds() method, making Option A correct.","D. To compare times in different time zones, you can subtract the time zone from the time to convert to GMT. This makes it 02:00 in Berlin because we subtract 1 from 3. Similarly, it is 02:00 in Helsinki due to subtracting 2 from 4. Finally, it is 04:00 in Warsaw because we subtracted 1 from 5. We have a tie because it is the same time in Berlin and Helsinki, so Option D is correct.","B. On a normal night, adding three hours to 1 a.m. makes it 4 a.m. However, this date begins daylight savings time. This means we add an extra hour to skip the 2 a.m. hour. This makes later contain 05:00 instead of 04:00. Therefore, the code prints 5, and Option B is correct.","C. LocalDate allows passing the month as an int or Month enum parameter. However, Month.MARCH is an enum. It cannot be assigned to an int variable, so the declaration of month does not compile, and Option C is correct.","C. Both LocalDate and DateTimeFormatter have a format() method. This makes II incorrect. While it is tricky, you do need to know that the format() method can be called on either object. Since I and III are correct, Option C is the answer.","C. Converting to GMT by subtracting the time zone offset, it is 17:00 for the Phoenix time since 10 minus negative 7 is 17. In GMT, the Vancouver time is 16:00 due to subtracting negative 8 from 8. Remember that subtracting a negative number is the same as adding. Therefore, the Vancouver time is an hour earlier than the Phoenix time, and Option C is correct.","C. While there is no 2 a.m. on the clock that night, Java adjusts the time to 3\xa0a.m. automatically and changes the time zone. It does not throw an exception, so Option D is incorrect. Option B is a valid expression, since any value after the time adjustment is just a normal time on the clock. Since both A and B are valid expressions, Option C is the correct answer.","B. Line 12 creates a Period representing a year, six months, and three days. Adding this to waffleDay gives us the year 2018, the month of September, and a day of 28. This new date is stored in later on line 13 and represents September 28, 2018. Line 14 has no effect as the return value is ignored. Line 17 checks that you know that isBefore() returns false if the value is an exact match. Since thisOne is an exact match but thatOne is a whole day before, the output is false true, making Option B correct.","D. Duration is supposed to be used with objects that contain times. While it has an ofDays() method, this is a convenience method to represent a large number of seconds. This means that calling Duration.ofDays(1) is fine. However, this code throws an UnsupportedTemporalTypeException when you try to pass it the minus() method on LocalDate, making Option D correct. Note that the question asks about a possible result rather than the definitive result because the format of dates varies by region.","C. The DateTimeFormatter is created with ofLocalizedDate(). It knows how to format date fields but not time fields. Line 18 is fine because a LocalDate clearly has date fields. Line 19 is also fine. Since a LocalDateTime has both date and time fields, the formatter just looks at the date fields. Line 20 is a problem. A LocalTime object does not have any date fields so the formatter throws an UnsupportedTemporalTypeException, making Option C the answer.","D. This question is tricky. It appears to be about daylight savings time. However, the result of z.plusHours(1) is never stored in a variable or used. Since ZonedDateTime is immutable, the time remains at 01:00. The code prints out 1, making none of these correct and Option D the answer.","D. For dates, a lowercase m means minute while an uppercase M means month. This eliminates Options A and C. A lowercase h means hour. Therefore, Option B is incorrect, and Option D is the answer.","D. There are three overloads for LocalTime.of(). Options A, B, and C are all valid overloads. Option D is not because Java only allows passing one fractional second parameter. Java does support nanoseconds, but not the further granularity of picoseconds.","C. The LocalDate class represents a date using year, month, and day fields. There is a getYear() method to get the year. The Period class holds units of years, months, and days. It has a getYears() method. There is not a date/time class called ZonedDate. There is a class called ZonedDateTime, which does have a getYear() method. Since only LocalDate and Period have a method to get the year, Option C is correct.","A. Duration is used for units of time a day and smaller, making Option B a true statement. Period is used for units of time a day and larger, making Option C a true statement. While both represent the same length of time, they output different values when calling toString(). The Duration object outputs PT24H, and the Period object outputs P1D. This shows that Duration is providing the ofDays() method as a convenience instead of requiring the programmer to type 24 hours. Option A is the answer.","B. The first thing to notice is that this is a LocalTime object. Since there is no date component, Options C and D are incorrect. Four parameters are passed to this LocalTime method. The first three are the hour, minute, and second. The fourth is nanoseconds, which are fractions of a second. While you aren\u2019t expected to do calculations with nanoseconds, you should know that a fraction of a second is at the end of the output. Option A is incorrect because .4 is 40 percent of a second. That\u2019s far larger than 4 nanoseconds. Therefore, Option B is correct.","B. LocalDate starts counting months from one, so month 2 is February. This rules out Options A and C. The pattern specifies that the date should appear before the month, making Option B correct.","A. The ChronoUnit enum contains values for various measures of time including HOURS, so Option A is correct.","B. Adding three hours to 13:00 makes it 16:00. While this date happens to be the start of daylight savings time, the change occurs at 2 a.m. This code uses 13:00, which is 1 p.m. Since the calculation does not cross 2 a.m., the fact that it is the date that starts daylight savings time is irrelevant. Option B is correct because the hour is 16 and the time is 16:00.","B. This code correctly subtracts a day from montyPythonDay. It then outputs a LocalDateTime value. Option A is incorrect because it omits the time. Option B is correct because it represents one day earlier than the original date and includes a time in the output.","D. There is a DateTimeFormatter class, but not a DateFormatter class. The DateTimeFormatter class is used for formatting dates, times, or both. Since the provided code does not compile, nothing can fill in the blank to make the code print 2017-01-15, and Option D is the answer.","B. There are many overloads for LocalDateTime.of(). Option A is a valid overload because it uses date and time objects. Options C and D are also valid overloads, showing you can pass the month as an int or Month enum. Option B is the answer. Java doesn\u2019t allow combining a LocalDate object with time fields directly.","C. In the first time change of the year, clocks \u201cspring ahead\u201d and skip the 02:00\u201303:00 hour entirely. This means 1:59 is followed by 03:00 on March 12, 2017. By contrast, July 4 is a normal day and 1:59 is followed by 02:00. In the second time change of the year, clocks \u201cfall back\u201d and repeat an hour, so 1:59 is followed by 01:00. Granted, you can\u2019t tell whether this is the first or second 1:59 from the image. If this information is relevant to a question\u2019s context, the question will specify this fact. In this case, 03:00, 02:00, 02:00 is not a choice. Option C is the answer.","D. February has 28 or 29 days, depending on the year. There is never a February 31. Java throws a DateTimeException when you try to create an invalid date, making Option D correct.","A. This one is tricky. In order to determine GMT, you need to subtract the time zone offset from the hour. In this case, the time zone offset is negative 10. Since subtracting a negative number is like adding a positive number, this means we are adding 16 and 10. That gives us 26. However, there are only 24 hours in a day. We\u2019ve crossed a time zone boundary, so we can remove a whole 24-hour day. Subtracting 24 from 26 gives us 2. This means it is 02:00 in GMT, and Option A is correct. It\u2019s also a day later in GMT, but the question didn\u2019t ask that.","D. An Instant represents a specific moment in time using GMT. Since there are no time zones included, Options A and C are incorrect. This code correctly adds one day to the instant, making Option D correct.","D. Make sure to pay attention to date types. This code attempts to add a month to a LocalTime value. There is no plusMonths() method on LocalTime, so Option D is correct.","D. The format of the pattern is incorrect. You can\u2019t just put literal text in there. Most of the characters of Holiday: are not defined formatting symbols. The code throws an IllegalArgumentException, so Option D is correct.","A. To compare times in different time zones, you can subtract the time zone from the time. This makes it 09:00 in Bangkok because we subtract 7 from 16. Similarly, it is 14:00 in Dubai due to subtracting 4 from 18. Finally, it is 12:00 in Kuala Lumpur because we subtracted 8 from 20. Notice how we used a 24-hour clock to make comparing times easier. The earliest time is in Bangkok, so Option A is correct.","C. Line 12 creates a Period representing three days. Period objects do not chain, so only the last method call, which is to ofDays(3), is used in determining the value. Adding three days sets later to March 28, 2017. Line 14 has no effect as the return value is ignored. March 28, 2017, is before both thisOne and thatOne, so Option C is correct.","B. The TemporalUnit interface does not define a DAYS constant, making II and IV incorrect. The until() and between() methods have the same behavior. They determine how many units of time are between two dates. One takes both dates as parameter and the other is an instance method on the date. Since I and III are equivalent, Option B is the answer. Note that while we don\u2019t have date times in this question, the until() and between() methods work the same way for them.","A. The DateTimeFormatter class is used to format all of these objects. The method will throw an exception if called with a LocalDate since the formatter only knows about time fields. However, it will still compile, making Option A correct.","B. This code begins by correctly creating four objects. It then adds a month to date. Since Java 8 date/time classes are immutable, this does not affect the value of iceCreamDay. Therefore, iceCreamDay remains in July. Since months count from one, Option B is correct.","A. Java 8 date and time classes are immutable. They use a static factory method to get the object reference rather than a constructor. This makes Options B and D incorrect. Further, there is not a ZonedDate class. There is a ZonedDateTime class. As a result, Option C is incorrect, and Option A is the answer.","B. The first line of code correctly creates a LocalDate object representing March 3, 2017. The second line adds two days to it, making it March 5. It then subtracts a day, making it March 4. Finally, it subtracts yet another day ending at March 3. The outcome of all this is that we have two dates that have the same value, and Option B is correct.","C. An Instant represents a specific moment in time using GMT. Since LocalDateTime does not have a time zone, it cannot be converted to a specific moment in time. Therefore, the toInstant() call does not compile, and Option C is correct.","A. While it is traditional to include the year when outputting a date, it is not required. This code correctly prints the month followed by a decimal point. After the decimal point, it prints the day of the month followed by the hours and minutes. Happy Pi Day!","C. Normally, adding an hour would result in 02:00 in the same time zone offset of \u201305:00. Since the hour is repeated, it is 01:00 again. However, the time zone offset changes instead. Therefore, Option C is correct."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"What package is the LocalTime class in?",code:null,answers:["java.date","java.lang","java.time","java.util"]},{title:"How many of the classes Duration, LocalDateTime, and LocalTime have the concept of a time zone?",code:null,answers:["None","One","Two","Three"]},{title:"Which class has a getSeconds() method?",code:null,answers:["Only the Duration class","Only the Period class","Both the Duration and Period classes","Neither class"]},{title:"Which of these represents the earliest date/time?",code:null,answers:["2017-02-15T03:00+01:00[Europe/Berlin]","2017-02-15T04:00+02:00[Europe/Helsinki]","2017-02-15T05:00+01:00[Europe/Warsaw]","None of the above. We have a tie."]},{title:"Most of the United States observes daylight savings time on March 12, 2017, by moving the clocks forward an hour at 2 a.m. What does the following code output?",code:'<code>LocalDate localDate = LocalDate.of(2017, 3, 12);</code>\n<code>LocalTime localTime = LocalTime.of(1, 0);</code>\n<code>ZoneId zone = ZoneId.of("America/New_York");</code>\n<code>ZonedDateTime z = ZonedDateTime.of(localDate, localTime, zone);</code>\n<code>Duration duration = Duration.ofHours(3);</code>\n<code>ZonedDateTime later = z.plus(duration);</code>\n<code>System.out.println(later.getHour());</code>',answers:["4","5","6","None of the above"]},{title:"What does the following output?",code:"<code>int year = 1874;</code>\n<code>int month = Month.MARCH;</code>\n<code>int day = 24;</code>\n<code>LocalDate date = LocalDate.of(year, month, day);</code>\n<code>System.out.println(date.isBefore(LocalDate.now()));</code>",answers:["false","true","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which correctly fills in the blank to print 2017-01-15?",code:"<code>LocalDate hatDay = LocalDate.of(2017, Month.JANUARY, 15);</code>\n<code>DateTimeFormatter f = DateTimeFormatter.ISO_DATE;</code>\n<code>System.out.println(_______________________);</code>",answers:["I","III","I and III","II and III"],ol:["f.format(hatDay)","f.formatDate(hatDay)","hatDay.format(f)"]},{title:"Which of the answer choices is true given the following?",code:"<code>2017-01-07T10:00-07:00[America/Phoenix]</code>\n<code>2017-01-07T08:00-08:00[America/Vancouver]</code>",answers:["The first date/time is one hour earlier than the second.","The first date/time is three hours earlier than the second.","The first date/time is one hour later than the second.","The first date/time is three hours later than the second."]},{title:"Given that daylight savings time starts on March 12, 2017, at 2 a.m. and clocks jump from 1:59 a.m. to 03:00 a.m., which of the following can fill in the blank so the code doesn\u2019t throw an exception?",code:'<code>LocalDate localDate = LocalDate.of(2017, 3, 12);</code>\n<code>LocalTime localTime = LocalTime.of(__________);</code>\n<code>ZoneId zone = ZoneId.of("America/New_York");</code>\n<code>ZonedDateTime z = ZonedDateTime.of(localDate, localTime, zone);</code>',answers:["2, 0","3, 0","Either of the above will run without throwing an exception.","Both of these will cause an exception to be thrown."]},{title:"What is the result of the following?",code:'<code>11:  LocalDate waffleDay = LocalDate.of(2017, Month.MARCH, 25);</code>\n<code>12:  Period period = Period.of(1, 6, 3);</code>\n<code>13:  LocalDate later = waffleDay.plus(period);</code>\n<code>14:  later.plusDays(1);</code>\n<code>15:  LocalDate thisOne = LocalDate.of(2018, Month.SEPTEMBER, 28);</code>\n<code>16:  LocalDate thatOne = LocalDate.of(2018, Month.SEPTEMBER, 29);</code>\n<code>17:  System.out.println(later.isBefore(thisOne) + " "</code>\n<code>18:     + later.isBefore(thatOne));</code>',answers:["false false","false true","true true","The code does not compile."]},{title:"What is a possible result of the following?",code:'<code>LocalDate montyPythonDay = LocalDate.of(2017, Month.MAY, 10);</code>\n<code>LocalDate aprilFools = LocalDate.of(2018,  Month.APRIL, 1);</code>\n<code>Duration duration = Duration.ofDays(1);</code>\n<code>LocalDate result = montyPythonDay.minus(duration);</code>\n<code>System.out.println(result + " " + aprilFools.isBefore(result));</code>',answers:["2017-05-09 false","2017-05-09 true","The code does not compile.","None of the above"]},{title:"What is the result of running this code?",code:"<code>12:  LocalDate pieDay = LocalDate.of(2017, Month.JANUARY, 23);</code>\n<code>13:  LocalTime midnight = LocalTime.of(0, 0);</code>\n<code>14:  LocalDateTime pieTime = LocalDateTime.of(pieDay, midnight);</code>\n<code>15:</code>\n<code>16:  DateTimeFormatter f = DateTimeFormatter</code>\n<code>17:     .ofLocalizedDate(FormatStyle.SHORT);</code>\n<code>18:  f.format(pieDay);</code>\n<code>19:  f.format(pieTime);</code>\n<code>20:  f.format(midnight);</code>",answers:["The code runs successfully.","The code throws an exception on line 19.","The code throws an exception on line 20.","The code does not compile."]},{title:"In the United States, daylight savings time ends on November 5th, 2017 at 02:00 a.m. and we repeat the previous hour. What is the output of the following?",code:'<code>import java.time.*;</code>\n<code> </code>\n<code>public class FallBack {</code>\n<code>&nbsp;</code>\n<code>   public static void main(String[] args) {</code>\n<code>      LocalDate localDate = LocalDate.of(2017, Month.NOVEMBER, 5);</code>\n<code>      LocalTime localTime = LocalTime.of(1, 0);</code>\n<code>      ZoneId zone = ZoneId.of("America/New_York");</code>\n<code>      ZonedDateTime z = ZonedDateTime.of(localDate, localTime, zone);</code>\n<code>&nbsp;</code>\n<code>      for (int i = 0; i &lt; 6; i++)</code>\n<code>         z.plusHours(1);</code>\n<code>&nbsp;</code>\n<code>      System.out.println(z.getHour());</code>\n<code>   }</code>\n<code>}</code>',answers:["5","6","7","None of the above"]},{title:"What format pattern would you pass to a DateTimeFormatter so it creates hour and minute output such as 02:33?",code:null,answers:["HH:MM","HH:mm","hh:MM","hh:mm"]},{title:"LocalTime.of() has a number of overloads. Which of the following is not one of them?",code:null,answers:["LocalTime.of(int hour, int minute)","LocalTime.of(int hour, int minute, int second)","LocalTime.of(int hour, int minute, int second, int nanoOfSecond)","LocalTime.of(int hour, int minute, int second, int nanoOfSecond,  int picoSeconds)"]},{title:"How many of the classes LocalDate, Period, and ZonedDate have a method to get the\xa0year?",code:null,answers:["None","One","Two","Three"]},{title:"Which statement is not true about these two variables?",code:"<code>Duration duration = Duration.ofDays(1);</code>\n<code>Period period = Period.ofDays(1);</code>",answers:["Both output the same value when calling toString().","The Duration object compiles because durations are for smaller units of time.","The Period object compiles because periods are for larger units of time.","None of the above"]},{title:"What is a possible output of this code?",code:"<code>LocalTime time = LocalTime.of(1,2,3,4);</code>\n<code>System.out.println(time);</code>",answers:["01:02:03.4","01:02:03.000000004","01/01/1970 01:02:03.4","01/01/1970 01:02:03.000000004"]},{title:"What does the following print?",code:'<code>import java.time.*;</code>\n<code>import java.time.format.*;</code>\n<code>&nbsp;</code>\n<code>public class PolarBear {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      LocalDate polarBearDay = LocalDate.of(2017, 2, 27);</code>\n<code>      DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy dd MMM");</code>\n<code>      System.out.println(polarBearDay.format(formatter));</code>\n<code>   }</code>\n<code>}</code>\n<code>&nbsp;</code>',answers:["2017 27 Jan","2017 27 Feb","2017 Jan 27","2017 Feb 27"]},{title:"Which contains a constant named HOURS?",code:null,answers:["ChronoUnit","Duration","Instant","Period"]},{title:"The United States observes daylight savings time on March 12, 2017, by moving the clocks forward an hour at 2 a.m. What does the following code output?",code:'<code>LocalDate localDate = LocalDate.of(2017, 3, 12);</code>\n<code>LocalTime localTime = LocalTime.of(13, 0);</code>\n<code>ZoneId zone = ZoneId.of("America/New_York");</code>\n<code>ZonedDateTime z = ZonedDateTime.of(localDate, localTime, zone);</code>\n<code>Duration duration = Duration.ofHours(3);</code>\n<code>ZonedDateTime later = z.plus(duration);</code>\n<code>System.out.println(later.getHour());</code>',answers:["13","16","17","None of the above"]},{title:"What is a possible result of the following?",code:"<code>LocalDate montyPythonDay = LocalDate.of(2017, Month.MAY, 10);</code>\n<code>LocalTime time = LocalTime.of(5, 40);</code>\n<code>LocalDateTime dateTime = LocalDateTime.of(montyPythonDay, time);</code>\n<code>Duration duration = Duration.ofDays(1);</code>\n<code>LocalDateTime result = dateTime.minus(duration);</code>\n<code>System.out.println(result);</code>",answers:["2017-05-09","2017-05-09T05:40","2017-05-10T05:40","None of the above"]},{title:"Which correctly fills in the blank to print 2017-01-15?",code:"<code>LocalDate hatDay = LocalDate.of(2017, Month.JANUARY, 15);</code>\n<code>DateFormatter f = DateFormatter.ISO_DATE;</code>\n<code>System.out.println(______________________________);</code>",answers:["f.format(hatDate)","hatDay.format(f)","Both of the above","Neither of the above"]},{title:"LocalDateTime.of() has a number of overloads. Which of the following is not one of\xa0them?",code:null,answers:["LocalDateTime.of(LocalDate date, LocalTime time)","LocalDateTime.of(LocalDate date, int hour, int minute)","LocalDateTime.of(int year, int month, int day, int hour, int minute)","LocalDateTime.of(int year, Month month, int day, int hour, int minute)"]},{title:"In the United States, daylight savings time for 2017 starts at 2 a.m. on March 12th and ends at 2 a.m. on November 5th. Given the sequence in the following image, what time comes next on March 12th, July 4th, and November 5th, respectively?",code:null,answers:["01:00, 02:00, 01:00","01:00, 02:00, 03:00","03:00, 02:00, 01:00","03:00, 02:00, 03:00"]},{title:"What is the output of the following?",code:"<code>LocalDate date1 = LocalDate.of(2017, Month.MARCH, 3);</code>\n<code>LocalDate date2 = LocalDate.of(2017, Month.FEBRUARY, 31);</code>\n<code>System.out.println(date1.equals(date2));</code>",answers:["false","true","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Given this date/time and time zone offset, what time is it in GMT?",code:"<code>2017-03-09T16:00-10:00[US/Hawaii]</code>",answers:["02:00","04:00","06:00","10:00"]},{title:"What is a possible output of the following?",code:'<code>LocalDate trainDay = LocalDate.of(2017, 5, 13);</code>\n<code>LocalTime time = LocalTime.of(10, 0);</code>\n<code>ZoneId zone = ZoneId.of("America/Los_Angeles");</code>\n<code><span epub:type="pagebreak" id="Page_297"></span>ZonedDateTime zdt = ZonedDateTime.of(trainDay, time, zone);</code>\n<code>Instant instant = zdt.toInstant();</code>\n<code>instant = instant.plus(1, ChronoUnit.DAYS);</code>\n<code>System.out.println(instant);</code>',answers:["2017-05-13T10:00-07:00[America/Los_Angeles]","2017-05-13T17:00:00Z","2017-05-14T10:00-07:00[America/Los_Angeles]","2017-05-14T17:00:00Z"]},{title:"What is the output of the following?",code:'<code>LocalDate date = LocalDate.of(2017, Month.JULY, 17);</code>\n<code>LocalTime time = LocalTime.of(10, 0);</code>\n<code>ZoneId zone = ZoneId.of("America/New_York");</code>\n<code>ZonedDateTime iceCreamDay = ZonedDateTime.of(date, time, zone);</code>\n<code>time = time.plusMonths(1);</code>\n<code>System.out.println(iceCreamDay.getMonthValue());</code>',answers:["6","7","8","The code does not compile."]},{title:"What does the following print?",code:'<code>import java.time.*;</code>\n<code>import java.time.format.*;</code>\n<code>&nbsp;</code>\n<code>public class PolarBear {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      LocalDate polarBearDay = LocalDate.of(2017, 2, 27);</code>\n<code>      DateTimeFormatter formatter = DateTimeFormatter</code>\n<code>         .ofPattern("Holiday: yyyy dd MMM");</code>\n<code>      System.out.println(polarBearDay.format(formatter));</code>\n<code>   }</code>\n<code>}</code>\n<code>&nbsp;</code>',answers:["Holiday: 2017 27 Jan","Holiday: 2017 27 Feb","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which of these represents the earliest date/time?",code:null,answers:["2017-02-15T16:00+07:00 [Asia/Bangkok]","2017-02-15T18:00+04:00 [Asia/Dubai]","2017-02-15T20:00+08:00 [Asia/Kuala_Lumpur]","None of the above. We have a tie."]},{title:"What is the result of the following?",code:'<code>11:  LocalDate waffleDay = LocalDate.of(2017, Month.MARCH, 25);</code>\n<code>12:  Period period = Period.ofYears(1).ofMonths(6).ofDays(3);</code>\n<code>13:  LocalDate later = waffleDay.plus(period);</code>\n<code>14:  later.plusDays(1); 15:  LocalDate thisOne = LocalDate.of(2018, Month.SEPTEMBER, 28);</code>\n<code>16:  LocalDate thatOne = LocalDate.of(2018, Month.SEPTEMBER, 29);</code>\n<code>17:  System.out.println(later.isBefore(thisOne) + " "</code>\n<code>18:     + later.isBefore(thatOne));</code>',answers:["false false","false true","true true","The code does not compile."]},{title:"",code:"<code>LocalDate xmas = LocalDate.of(2017,  12, 25);</code>\n<code>LocalDate blackFriday = LocalDate.of(2017, 11, 24);</code>\n<code>long shoppingDaysLeft =____________________ ;</code>\n<code>System.out.println(shoppingDaysLeft);</code>",answers:["One","Two","Three","Four"]},{title:"How many of these classes cause a compiler error when filling in the blank: LocalDate, LocalDateTime, LocalTime, ZonedDateTime?",code:"<code>private static String formatMe(__________ obj) {</code>\n<code>   DateTimeFormatter f = DateTimeFormatter.ofLocalizedTime(FormatStyle.MEDIUM);</code>\n<code>   return f.format(obj);</code>\n<code>}</code>",answers:["None","One","Two","Three"]},{title:"What is the output of the following?",code:'<code>LocalDate date = LocalDate.of(2017, Month.JULY, 17);</code>\n<code>LocalTime time = LocalTime.of(10, 0);</code>\n<code>ZoneId zone = ZoneId.of("America/New_York");</code>\n<code>ZonedDateTime iceCreamDay = ZonedDateTime.of(date, time, zone);</code>\n<code>date = date.plusMonths(1);</code>\n<code>System.out.println(iceCreamDay.getMonthValue());</code>',answers:["6","7","8","The code does not compile."]},{title:"Which of the following can fill in the blank to make this code compile?",code:"<code>public boolean isItMyBirthday(LocalDateTime dateTime) {</code>\n<code>  ______________________________ </code>\n<code>   return now.getMonth() == dateTime.getMonth()</code>\n<code>      &amp;&amp; now.getDayOfMonth() == dateTime.getDayOfMonth();</code>\n<code>}</code>",answers:["LocalDate now = LocalDate.now();","LocalDate now = new LocalDate();","ZonedDate now = ZonedDate.now();","ZonedDate now = new ZonedDate();"]},{title:"What is the output of the following?",code:"<code>LocalDate date1 = LocalDate.of(2017, Month.MARCH, 3);</code>\n<code>LocalDate date2 = date1.plusDays(2).minusDays(1).minusDays(1);</code>\n<code>System.out.println(date1.equals(date2));</code>",answers:["false","true","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What is a possible output of the following?",code:"<code>LocalDate date = LocalDate.of(2017, 5, 13);</code>\n<code>LocalTime time = LocalTime.of(10, 0);</code>\n<code>LocalDateTime trainDay = LocalDateTime.of(date, time);</code>\n<code>Instant instant = trainDay.toInstant();</code>\n<code>instant = instant.plus(1, ChronoUnit.DAYS);</code>\n<code>System.out.println(instant);</code>",answers:["2017-05-14T10:00-07:00[America/Los_Angeles]","2017-05-14T17:00:00Z","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What is the result of the following?",code:'<code>public class PiDay {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      LocalDateTime pi = LocalDateTime.of(2017, 3, 14, 1, 59);</code>\n<code>      DateTimeFormatter formatter = DateTimeFormatter</code>\n<code>         .ofPattern("M.ddhhmm");</code>\n<code>      System.out.println(formatter.format(pi));</code>\n<code>   }</code>\n<code>}</code>',answers:["3.140159","59.140103","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Daylight savings time ends on November 5, 2017 at 2 a.m. when we repeat the hour. Suppose we have a ZonedDateTime that outputs 2017-11-05T01:00-04:00[America/ New_York] when calling toString(). What is a possible value of the ZonedDateTime obtained by adding an hour to this value?",code:null,answers:["2017-11-05T01:00-04:00[America/New_York]","2017-11-05T02:00-04:00[America/New_York]","2017-11-05T01:00-05:00[America/New_York]","2017-11-05T02:00-05:00[America/New_York]"]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t],ol:e.ol}});i[24].imageUrl="./images/image-ocp-ch17-25.png",t.default=i},173:function(e,t,o){"use strict";o.r(t);var n=["B. Writer is an abstract class, making Option B the correct answer. Note that InputStream, OutputStream, and Reader are also abstract classes.","D. File uses mkdir() and mkdirs() to create a directory, not createDirectory(), making Option A incorrect. Note there is a createDirectory() method in the NIO.2 Files class. The getLength() method also does not exist, as the correct method is called length(). Next, there is a listFiles() method used to read the contents of a directory, but there is no listFile() method. That leaves us with renameTo(), which does exist and is used to rename file system paths.","C. The skip() method just reads a single byte and discards the value. The read() method can be used for a similar purpose, making Option C the correct answer. Option A is incorrect because there is no jump() method defined in InputStream. Options B and D are incorrect because they cannot be used to skip data, only to mark a location and return to it later, respectively.","D. Serializable is a marker or tagging interface, which means it does not contain any methods and is used to provide information about an object at runtime. Therefore, Option D is the correct answer because the interface does not define any abstract methods.","C. Given a valid instance of Console, reader() returns an instance of Reader, while writer() returns an instance of PrintWriter. Reader and PrintWriter was not an answer choice though, making Option C the next best choice since PrintWriter inherits Writer. Options A and B are incorrect because PrintReader is not defined in the java .io library. Option D is incorrect because the type of the instance returned by reader() is Reader, which does not inherit StringReader.","D. BufferedWriter is a wrapper class that requires an instance of Writer to operate on. In the Smoke class, a FileOutputStream is passed, which does not inherit Writer, causing the class not to compile, and making Option D the correct answer. If FileWriter was used instead of FileOutputStream, the code would compile without issue and print 13, making Option B the correct answer.","A. The File class is used to read both files and directories within a file system, making Option A the correct answer. The other three classes do not exist. Note there is an NIO.2 interface, java.nio.file.Path, used to read both file and path information.","C. FileOutputStream and FileReader are both low-level streams that operate directly on files, making Options A and B incorrect. ObjectInputStream is a high-level stream that can only wrap an existing InputStream. For this reason, Option C is the correct answer. PrintWriter can operate on other streams, but it can also operate on files. Since the question asks which class can only wrap low-level streams, Option D is incorrect.","D. The code compiles, so Option C is incorrect. The FileInputStream does not support marks, though, leading to an IOException at runtime when the reset() method is called. For this reason, Option D is the correct answer. Be suspicious of any code samples that call the mark() or reset() method without first calling markSupported().","C. The absolute path is the full path from the root directory to the file, while the relative path is the path from the current working directory to the file. For this reason, Option C is the correct answer.","D. The difference between the two methods is that writeSecret1() does not take any steps to ensure the close() method is called after the resource is allocated. On the other hand, writeSecret2() uses a try-with-resources block, which automatically tries to close the resource after it is used. Without a try-with-resources statement or an equivalent finally block, any exception thrown by the write() method would cause the resource not to be closed in the writeSecret1() method, possibly leading to a resource leak. For this reason, Option D is the correct answer. Option A is incorrect since they are not equivalent to each other. Finally, Options B and C are incorrect because both compile without issue.","A. The constructor for Console is private. Therefore, attempting to call new Console() outside the class results in a compilation error, making Option A the correct answer. The correct way to obtain a Console instance is to call System.console(). Even if the correct way of obtaining a Console had been used, and the Console was available at runtime, stuff is null in the printItinerary() method. Referencing stuff.activities results in a NullPointerException, which would make Option B the correct answer.","A. While you might not be familiar with FilterOutputStream, the diagram shows that the two classes must inherit from OutputStream. Options B and C can be eliminated as choices since PrintOutputStream and Stream are not the name of any java.io classes. Option D can also be eliminated because OutputStream is already in the diagram, and you cannot have a circular class dependency. That leaves us with the correct answer, Option A, with BufferedOutputStream and PrintStream both extending FilterOutputStream. Note that ByteArrayOutputStream and FileOutputStream referenced in Options C and D, respectively, do not extend FilterOutputStream, although knowing this fact was not required to solve the problem.","D. The Cereal class does not implement the Serializable interface; therefore, attempting to write the instance to disk, or calling readObject() using ObjectInputStream, will result in a NotSerializableException at runtime. For this reason, Option D is the correct answer. If the class did implement Serializable, then the value of name would be CornLoops, since none of the constructor, initializers, or setters methods are used on deserialization, making Option B the correct answer.","B. An OutputStream is used to write bytes, while a Writer is used to write character data. Both can write character data, the OutputStream just needs the data converted to bytes first. For this reason, Option A is incorrect. Option B is the correct answer, with Writer containing numerous methods for writing character or String data. Both interfaces contain a flush() method, making Option C incorrect. Finally, because both can be used with a byte array, Option D is incorrect.","C. First off, the code compiles without issue. The first method call to mkdirs() creates two directories, /templates and /templates/proofs. The next mkdir() call is unnecessary, since /templates/proofs already exists. That said, calling it on an existing directory is harmless and does not cause an exception to be thrown at runtime. Next, a file draft.doc is created in the /templates directory. The final two lines attempt to remove the newly created directories. The first call to delete() is successful because /templates/proofs is an empty directory. On the other hand, the second call to delete() fails to delete the directory /templates because it is non-empty, containing the file draft.doc. Neither of these calls trigger an exception at runtime, though, with delete() just returning a boolean value indicating whether the call was successful. Therefore, our program ends without throwing any exceptions, and Option C is the correct answer.",'D. To answer the question, you need to identify three of the four ways to call the system-independent file name separator. For example, the file name separator is often a forward-slash (/) in Linux-based systems and a backward-slash (\\) in Windows-based systems. Option A is valid because it is the fully qualified name of the property. Option B is also valid because File.separator and File.separatorChar are equivalent. While accessing a static variable using an instance is discouraged, as shown in Option B, it is allowed. Option C is valid and a common way to read the character using the System class. Finally, Option D is the correct answer and one call that cannot be used to get the system-dependent name separator character. Note that System.getProperty("path.separator") is used to separate sets of paths, not names within a single path.',"D. The first compilation error is that the FileReader constructor call is missing the new keyword. The second compilation error is that the music variable is marked final, but then modified in the while loop. The third compilation problem is that the readMusic() method fails to declare or handle an IOException. Even though the IOException thrown by readLine() is caught, the one thrown by the implicit call to close() via the try-with-resources block is not caught. Due to these three compilation errors, Option D is the correct answer.","C. Both of the methods do exist, making Option D incorrect. Both methods take the same arguments and do the exact same thing, making Option C the correct answer. The printf() was added as a convenience method, since many other languages use printf() to accomplish the same task as format().","C. FileWriter and BufferedWriter can be used in conjunction to write large amounts of text data to a file in an efficient manner, making Option C the correct answer. While you can write text data using FileOutputStream and BufferedOutputStream, they are primarily used for binary data. Since there is a better choice available, Option A is incorrect. Option B is incorrect since FileOutputWriter and FileBufferedWriter are not classes that exist within the java.io API. Option D is incorrect since ObjectOutputStream is a high-level binary stream. Also, while it can write String data, it writes it in a binary format, not a text format.","D. The code compiles and runs without issue, so Options A and B are incorrect. The problem with the implementation is that checking if ios.readObject() is null is not the recommended way of iterating over an entire file. For example, the file could have been written with writeObject(null) in-between two non-null records. In this case, the reading of the file would stop on this null value, before the end of the file has been reached. For this reason, Option D is the correct answer. Note that the valid way to iterate over all elements of a file using ObjectInputStream is to continue to call readObject() until an EOFException is thrown.","D. BufferedInputStream is the complement of BufferedOutputStream. Likewise, BufferedReader and FileReader are the complements of BufferedWriter and FileWriter, respectively. On the other hand, PrintWriter does not have an accompanying PrintReader class within the java.io API, making Option D the correct answer. Remember that this is also true of PrintStream, as there is no PrintInputStream class.","C. The File getParent() method returns a String, not a File object. For this reason, the code does not compile on the last line since there is no getParent() method defined in the String class, and Option C is correct. If the first method call on the last line was changed to getParentFile(), then the code would compile and run without issue, outputting / - null and making Option B the correct answer. The File class does not require the location to exist within the file system in order to perform some operations, like getParent(), on the path.","D. All three statements about the program are correct. If System.console() is available, then the program will ask the user a question and then print the response if one is entered. On the other hand, if System.console() is not available, then the program will exit with a NullPointerException. It is strongly recommended to always check whether or not System.console() is null after requesting it. Finally, the user may choose not to respond to the program\u2019s request for input, resulting in the program hanging indefinitely and making the last statement true.","C. The code contains two compilation errors. First, the File list() method returns a list of String values, not File values, so the call to deleteTree() with a String value does not compile. Either the call would have to be changed to f.listFiles() or the lambda expression body would have to be updated to deleteTree(new File(s)) for the code to work properly. Next, there is no deleteDirectory() method in the File class. Directories are deleted with the same delete() method used for files, once they have been emptied. With those two sets of corrections, the method would compile and be capable of deleting a directory tree. Notice we continually used the phrase \u201ccapable of deleting a directory tree.\u201d While the corrected code is able to delete a directory tree, it may fail in some cases, such as if the file system is read-only.","C. System.err, System.in, and System.out are each valid streams defined in the System class. System.info is not, making Option C the correct answer.","D. The code compiles without issue, making Options B and C incorrect. The BufferedWriter uses the existing FileWriter object as the low-level stream to write the file to disk. By using the try-with-resources block, though, the BufferedWriter calls close() before executing any associated catch or finally blocks. Since closing a high-level stream automatically closes the associated low-level stream, the w object is already closed by the time the finally block is executed. For this reason, the flush() command triggers an IOException at runtime, making Option D the correct answer. Note that the call to w.close(), if that line was reached, does not trigger an exception, because calling close() on already closed streams is innocuous.","B. The Console class contains a reader() method that returns a Reader object. The Reader class defines a read() method, but not a readLine() method. For this reason, Option B is the correct answer. Recall that a BufferedReader is required to call the readLine() method. Options A, C, and D are valid ways to read input from the user.","C. The code compiles without issue, since InputStream and OutputStream both support reading/writing byte arrays, making Option A incorrect. Option D is also incorrect. While it is often recommended that an I/O array be a power of 2 for performance reasons, it is not required, making Option D incorrect. This leaves us with Options B and C. The key here is the write() method used does not take a length value, available in the chirps variable, when writing the file. The method will always write the entire data array, even when only a handful of bytes were read into the data array, which may occur during the last iteration of the loop. The result is that files whose bytes are a multiple of 123 will be written correctly, while all other files will be written with extra data appended to the end of the file. For this reason, Option C is the correct answer. If the write(data) call was replaced with write(data,0,chirps), which does take the number of bytes read into consideration, then all files would copy correctly, making Option B the correct answer.","C. The class name has three components that tell you what it would do if it was a java.io stream. First, Buffered tells you it can be used to handle large data sets efficiently. Next, File tells you it is involved in reading or writing files. Finally, Reader tells you it is used to read character data. Therefore, the class would be useful for reading large files of character data from disk efficiently, making Option C the correct answer. Option A is incorrect because it refers to a small file over a network. Options B and D are incorrect because both involve binary data.","A. The code compiles and runs without issue. The first two values of the ByteArrayInputStream are read. Next, the markSupported() value is tested. Since -1 is not one of the possible answers, we assume that ByteArrayInputStream does support marks. Two values are read and three are skipped, but then reset() is called, putting the stream back in the state before mark() was called. In other words, everything between mark() and reset() can be ignored. The last value read is 3, making Option A the correct answer.","C. Line 5 creates a File object, but that does not create a file in the file system unless cake.createNewFile() is called. Line 6 also does not necessarily create a file, although the call to flush() will on line 7. Note that this class does not properly close the file resource, potentially leading to a resource leak. Line 8 creates a new File object, which is used to create a new directory using the mkdirs() method. Recall from your studies that mkdirs() is similar to mkdir(), except that it creates any missing directories in the path. Since directories can have periods (.) in their name, such as a directory called info.txt, this code compiles and runs without issue. Since two file system objects, a file and a directory, are created, Option C is the correct answer.","B. Since the file is stored on disk, FileInputStream is an appropriate choice. Next, because the data is quite large, a BufferedInputStream would help improve access. Finally, since the data is a set of Java values, ObjectInputStream would allow various different formats to be read. The only one that does not help in this process is BufferedReader, Option B. BufferedReader should be used with text-based Reader streams, not binary InputStream objects.","B. The flush() method is defined on classes that inherit Writer and OutputStream, not Reader and InputStream. For this reason, the r.flush() in both methods does not compile, making Option B the correct answer and Option C incorrect. The methods are not equivalent even if they did compile, since getNameSafely() ensures the resource is closed properly by using a try-with-resources statement, making Option A incorrect for two reasons. Finally, Option D would be correct if the calls to flush() were removed.","A. First off, the class compiles without issue. Although there are built-in methods to print a String and read a line of input, the developer has chosen not to use them for most of the application. The application first prints Pass, one character at a time. The flush() method does not throw an exception at runtime. In fact, it helps make sure the message is presented to the user. Next, the user enters badxbad and presses Enter. The stream stops reading on the x, so the value stored in the StringBuilder is bad. Finally, this value is printed to the user, using the format() method along with Result: as a prefix. For these reasons, Option A is the correct answer.","B. The readPassword() returns a char array for security reasons. If the data was stored as a String, it would enter the shared JVM string pool, potentially allowing a malicious user to access it, especially if there is a memory dump. By using a char array, the data can be immediately cleared after it is written and removed from memory. For this reason, Option B is the correct answer. The rest of the statements are not true.","A. The BufferedInputStream constructor in the readBook() method requires an InputStream as input. Since FileReader does not inherit InputStream, the readBook() method does not compile, and Option A is the correct answer. If FileReader was changed to FileInputStream, then the code would compile without issue. Since read() is called twice per loop iteration, the program would print every other byte, making Option C correct. Remember that InputStream read() returns -1 when the end of the stream is met. Alternatively, we use EOFException with ObjectInputStream readObject() to determine when the end of the file has been reached.","B. Generally speaking, classes should be marked with the Serializable interface if they contain data that we might want to save and retrieve later. Options A, C, and D describe the type of data that we would want to store over a long period of time. Option B, though, defines a class that manages transient or short-lived data. Application processes change quite frequently, and trying to reconstruct a process is often considered a bad idea. For these reasons, Option B is the best answer.","D. The receiveText() method compiles and runs without issue. The method correctly checks that the mark() method is supported before attempting to use it. Based on the implementation with reset(), the pointer is in the same location before/after the if-then statement. On the other hand, the sendText() method does not compile. The skip() method is defined on InputStream and Reader, not OutputStream and Writer, making Option D the correct answer. If this line was removed, the rest of the code would compile and run without issue, printing You up? at runtime and making Option A the correct answer.","B. The class compiles and runs without issue, so Option D is incorrect. The class defines three variables, only one of which is serializable. The first variable, chambers, is serializable, with the value 2 being written to disk and then read from disk. Note that constructors and instance initializers are not executed when a class is deserialized. The next variable, size, is transient. It is discarded when it is written to disk, so it has the default object value ofnull when read from disk. Finally, the variable color is static, which means it is shared by all instances of the class. Even though the value was RED when the instance was serialized, this value was not written to disk, since it was not part of the instance. The constructor call new Value() between the two try-with-resources blocks sets this value to BLUE, which is the value printed later in the application. For these reasons, the class prints 2,null,BLUE, making Option B the correct answer."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"Fill in the blanks: Writer is__________ that related stream classes__________ .",code:null,answers:["a concrete class, extend","an abstract class, extend","an interface, extend","an interface, implement"]},{title:"Which of the following methods is defined in java.io.File?",code:null,answers:["createDirectory()","getLength()","listFile()","renameTo()"]},{title:"Which method in InputStream can be used in place of calling skip(1)?",code:null,answers:["jump()","mark()","read()","reset()"]},{title:"Which methods are classes that implement java.io.Serializable required to implement?",code:null,answers:["deserialize()","serial()","serialize()","None of the above"]},{title:"Fill in the blanks: Given a valid Console instance, reader() returns a__________ , while writer() returns a __________.",code:null,answers:["PrintReader, PrintWriter","PrintReader, Writer","Reader, Writer","StringReader, Writer"]},{title:"Assuming the file path referenced in the following class is accessible and able to be written, what is the output of the following program?",code:'<code>package alarm;</code>\n<code>import java.io.*;</code>\n<code>public class Smoke {</code>\n<code>   public void sendAlert(File fn) {</code>\n<code>      try(BufferedWriter w = new BufferedWriter(new FileOutputStream(fn))) {</code>\n<code>         w.write("ALERT!");</code>\n<code>         w.flush();</code>\n<code>         w.write(\'!\');</code>\n<code><span epub:type="pagebreak" id="Page_303"></span>         System.out.print("1");</code>\n<code>      } catch (IOException e) {</code>\n<code>         System.out.print("2");</code>\n<code>      } finally {</code>\n<code>         System.out.print("3");</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] testSignal) {</code>\n<code>      new Smoke().sendAlert(new File("alarm.txt"));</code>\n<code>   }</code>\n<code>}</code>',answers:["3","13","23","The code does not compile."]},{title:"Which class is used to read information about a directory within the file system?",code:null,answers:["java.io.File","java.io.Directories","java.io.Directory","java.io.Path"]},{title:"Which of the following is a high-level stream class that can only be used to wrap a  low-level stream?",code:null,answers:["FileOutputStream","FileReader","ObjectInputStream","PrintWriter"]},{title:"Assume the file prime6.txt exists and contains the first six prime numbers as bytes: 2, 3, 5, 7, 11, 13. What is the output of the following application?",code:'<code>package numbers;</code>\n<code>import java.io.*;</code>\n<code>public class PrimeReader {</code>\n<code>   public static void main(String[] real) throws Exception {</code>\n<code>      try (InputStream is = new FileInputStream("prime6.txt")) {</code>\n<code>         is.skip(1);</code>\n<code>         is.read();</code>\n<code>         is.skip(1);</code>\n<code>         is.read();</code>\n<code><span epub:type="pagebreak" id="Page_304"></span>         is.mark(4);</code>\n<code>         is.skip(1);</code>\n<code>         is.reset();</code>\n<code>         System.out.print(is.read());</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["11","13","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Fill in the blanks: For a given file, the absolute is the path from the  __________to the file, while the relative path is the path from the  __________to the file.",code:null,answers:["current directory, current working directory","parent directory, temporary directory","root directory, current working directory","root directory, parent directory"]},{title:"Which statement best describes the following two methods?",code:'<code>public void writeSecret1() throws IOException {</code>\n<code>   final Writer w = new BufferedWriter(</code>\n<code>         new FileWriter("dont.open"));</code>\n<code>   w.write("Secret passcode");</code>\n<code>   w.close();</code>\n<code>}</code>\n<code>public void writeSecret2() throws IOException {</code>\n<code>   try(final Writer w = new BufferedWriter(</code>\n<code>         new FileWriter("dont.open"))) {</code>\n<code>      w.write("Secret passcode");</code>\n<code>   }</code>\n<code>}</code>',answers:["Both methods compile and are equivalent to each other.","Neither method compiles.","Only one of the methods compiles.","The methods compile, but one method may lead to a resource leak."]},{title:"What is the result of compiling and executing the following program?",code:'<code>package vacation;</code>\n<code>import java.io.*;</code>\n<code>import java.util.*;</code>\n<code>public class Itinerary {</code>\n<code>   private List&lt;String&gt; activities = new ArrayList&lt;&gt;();</code>\n<code>   private static Itinerary getItinerary(String name) {</code>\n<code>      return null;</code>\n<code>   }</code>\n<code>   public static void printItinerary() throws Exception {</code>\n<code>      Console c = new Console();</code>\n<code>      final String name = c.readLine("What is your name?");</code>\n<code>      final Itinerary stuff = getItinerary(name);</code>\n<code>      stuff.activities.forEach(s -&gt; c.printf(s));</code>\n<code>   }</code>\n<code>   public static void main(String[] holidays) throws Exception {</code>\n<code>      printItinerary();</code>\n<code>   }</code>\n<code>}</code>',answers:["The code does not compile.","The code compiles and prints a NullPointerException at runtime.","The code compiles but does not print anything at runtime.","None of the above"]},{title:"Given the following diagram, which two classes can be placed in the blank boxes?",code:null,answers:["BufferedOutputStream and PrintStream","BufferedOutputStream and PrintOutputStream","ByteArrayOutputStream and Stream","FileOutputStream and OutputStream"]},{title:"Let\u2019s say we want to write an instance of Cereal to disk, having a name value of CornLoops. What is the value of name after this object has been read using the ObjectInputStream\u2019s readObject() method?",code:'<code>package breakfast;</code>\n<code>public class Cereal {</code>\n<code>   private String name = "CocoaCookies";</code>\n<code>   private transient int sugar;</code>\n<code>   public Cereal() {</code>\n<code>      super();</code>\n<code>      this.name = "CaptainPebbles";</code>\n<code>   }</code>\n<code>   {</code>\n<code>      name = "SugarPops";</code>\n<code>   }</code>\n<code>   public String getName() { return name; }</code>\n<code>   public void setName(String name) {</code>\n<code>      this.name = name;</code>\n<code>   }</code>\n<code>   public int getSugar() { return sugar; }</code>\n<code>   public void setSugar(int sugar) {</code>\n<code>      this.sugar = sugar;</code>\n<code>   }</code>\n<code>}</code>',answers:["CaptainPebbles","CornLoops","SugarPops","None of the above"]},{title:"Which statement best describes the difference between a Writer and an OutputStream class?",code:null,answers:["Only one of them can write text or character data.","Only one of them has built-in methods for writing character data.","Only one of them has a flush() method to force the data to be written out.","One uses a byte array to process character data more efficiently."]},{title:"What is the output of the following application? It is safe to assume the directories referenced in the class do not exist prior to the execution of the program and that the file system is available and able to be written.",code:'<code>package job;</code>\n<code>import java.io.*;</code>\n<code>public class Resume {</code>\n<code><span epub:type="pagebreak" id="Page_307"></span>   public void resetWorkingDirectory() throws Exception {</code>\n<code>      File f1 = new File("/templates/proofs");</code>\n<code>      f1.mkdirs();</code>\n<code>      File f2 = new File("/templates");</code>\n<code>      f2.mkdir();  // k1</code>\n<code>      new File(f2,"draft.doc").createNewFile();</code>\n<code>      f1.delete();</code>\n<code>      f2.delete();  // k2</code>\n<code>   }</code>\n<code>   public static void main(String... leads) {</code>\n<code>      try {</code>\n<code>         new Resume().resetWorkingDirectory();</code>\n<code>      } catch (Exception e) {</code>\n<code>         new RuntimeException(e);</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["Line k1 does not compile or triggers an exception at runtime.","Line k2 does not compile or triggers an exception at runtime.","The code compiles and runs without printing an exception.","None of the above"]},{title:"Given the following class, three of the values ensure it runs properly on various different systems. Which value does not?",code:"<code>package magic;</code>\n<code>import java.io.*;</code>\n<code>public class Store {</code>\n<code>   private final String directory;</code>\n<code>   public Store(String directory) {</code>\n<code>      this.directory = directory;</code>\n<code>   }</code>\n<code>   public File getDatabaseFolder(String file) {</code>\n<code>      return new File(directory + __________ + file);</code>\n<code>   }</code>\n<code>}</code>",answers:["java.io. File.separator","new File(new String()). separatorChar",'System. getProperty("file.separator")','System. getProperty("path.separator")']},{title:"How many compilation errors does the following class contain?",code:"<code>package hero;</code>\n<code>import java.io.*;</code>\n<code>public class Guitar {</code>\n<code>   public void readMusic(File f) {</code>\n<code>      try (BufferedReader r = new BufferedReader(FileReader(f))) {</code>\n<code>         final String music = null;</code>\n<code>         try {</code>\n<code>            while((music = r.readLine()) != null)</code>\n<code>               System.out.println(music);</code>\n<code>         } catch (IOException e) {}</code>\n<code>      } catch (FileNotFoundException e) {</code>\n<code>         throw new RuntimeException(e);</code>\n<code>      } finally {}</code>\n<code>}}</code>",answers:["None","One","Two","Three"]},{title:"What is the difference between the two Console methods, format() and printf()?",code:null,answers:["One of them takes an optional list of arguments; the other does not.","One of them takes String as input; the other takes an Object.","There is no difference between the two methods.","Trick question! printf() is not defined in Console."]},{title:"Let\u2019s say you want to write a lot of text data to a file in an efficient manner. Which two java.io stream classes are best to use?",code:null,answers:["FileOutputStream and BufferedOutputStream","FileOutputWriter and FileBufferedWriter","FileWriter and BufferedWriter","ObjectOutputStream and BufferedWriter"]},{title:"Assume the file referenced in the StudentManager class exists and contains data. Which statement about the following class is correct?",code:'<code>package school;</code>\n<code>import java.io.*;</code>\n<code>class Student implements Serializable {}</code>\n<code>public class StudentManager {</code>\n<code><span epub:type="pagebreak" id="Page_309"></span>   public static void main(String[] grades) {</code>\n<code>      try(ObjectInputStream ios = new ObjectInputStream(</code>\n<code>            new FileInputStream(new File("C://students.data")))) {</code>\n<code>         Student record;</code>\n<code>         while((record = (Student)ios.readObject()) != null) {</code>\n<code>            System.out.print(record);</code>\n<code>         }</code>\n<code>      } catch (EOFException e) {</code>\n<code>      } catch (Exception e) {</code>\n<code>         throw new RuntimeException(e);</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["The code does not compile.","The code compiles but prints an exception at runtime.","The program runs and prints all students in the file.","The program runs but may only print some students in the files."]},{title:"Which java.io class does not have a complementary input stream?",code:null,answers:["BufferedOutputStream","BufferedWriter","FileWriter","PrintWriter"]},{title:"Assuming the path /Earth does not exist within the file system, what is the output of the following program?",code:'<code>package center;</code>\n<code>import java.io.*;</code>\n<code>public class Journey {</code>\n<code>   public static void main(String[] dig) {</code>\n<code>      File file = new File("/Earth");</code>\n<code>      System.out.print(file.getParent()</code>\n<code>            +" - "</code>\n<code>            +file.getParent().getParent()); } }</code>',answers:["/ - /","/ - null","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which statements about executing the following program are true?",code:'<code>package test;</code>\n<code>import java.io.*;</code>\n<code>public class Turing {</code>\n<code>   public static void main(String... robots) {</code>\n<code>      Console c = System.console();</code>\n<code>      final String response = c.readLine("Are you human?");</code>\n<code>      System.err.print(response);</code>\n<code>   }</code>\n<code>}</code>',answers:["I","I and III","II and III","I, II, and III"],ol:["The program may ask the user a question and print the response to the error stream.","The program may throw a NullPointerException at runtime.","The program may wait indefinitely."]},{title:"Which of the following statements about the deleteTree() method is correct?",code:"<code>public void deleteTree(File f) {</code>\n<code>   if(!f.isDirectory())</code>\n<code>      f.delete();</code>\n<code>   else {</code>\n<code>      Stream.of(f.list())</code>\n<code>         .forEach(s -&gt; deleteTree(s));</code>\n<code>      f.deleteDirectory();</code>\n<code>   }</code>\n<code>}</code>",answers:["It compiles and is capable of deleting a directory tree.","If one line were modified, it would be capable of deleting a directory tree.","If two lines were modified, it would be capable of deleting a directory tree.","None of the above"]},{title:"Which of the following is not a built-in stream in Java?",code:null,answers:["System.err","System.in","System.info","System.out"]},{title:"Assuming the file path referenced in the following class is accessible and able to be written, what is the output of the following program?",code:'<code>package store;</code>\n<code>import java.io.*;</code>\n<code>public class Furniture {</code>\n<code>   public final static void main(String... inventory) throws Exception {</code>\n<code>      Writer w = new FileWriter("couch.txt");</code>\n<code>      try (BufferedWriter bw = new BufferedWriter(w)) {</code>\n<code>         bw.write("Blue coach on Sale!");</code>\n<code>      } finally {</code>\n<code>         w.flush();</code>\n<code>         w.close();</code>\n<code>      }</code>\n<code>      System.out.print("Done!");</code>\n<code>   }</code>\n<code>}</code>',answers:["Done!","The code does not compile for one reason.","The code does not compile for two reasons.","The code compiles but throws an exception at runtime."]},{title:"Given an instance of Console c, which of the following method calls is not a way to read input from the user?",code:null,answers:["c.reader().read()","c.reader().readLine()","c.readLine()","c.readPassword()"]},{title:"The copyPidgin() method is used to copy the contents of one file to another. Which  statement about the implementation is correct?",code:'<code>package birds;</code>\n<code>import java.io.*;</code>\n<code>public class Pidgin {</code>\n<code>   public void copyPidgin(File s, File t) throws Exception {</code>\n<code>      try(InputStream is = new FileInputStream(s);</code>\n<code>            OutputStream os = new FileOutputStream(t)) {</code>\n<code>         byte[] data = new byte[123];</code>\n<code><span epub:type="pagebreak" id="Page_312"></span>         int chirps;</code>\n<code>         while((chirps = is.read(data))&gt;0) {</code>\n<code>            os.write(data);</code>\n<code>         }}</code>\n<code>   }}</code>',answers:["The class does not compile because read(byte[]) and write(byte[]) can only be called on BufferedInputStream and BufferOutputStream, respectively.","The method correctly copies the contents of all files.","The method correctly copies the contents of some files.","The method will always throw an exception at runtime because the data array size is not a power of 2."]},{title:"Using what you know about java.io stream class names, what would a nonexistent class named BufferedFileReader most likely be used for?",code:null,answers:["Reading a small text file from a remote network","Reading an image from disk","Reading large text files from a file system","Reading serialized data from disk"]},{title:"What is the output of the following application?",code:"<code>package factory;</code>\n<code>import java.io.*;</code>\n<code>public class WidgetProcessor {</code>\n<code>   public int getWidgetNumber(byte[] data) throws Exception {</code>\n<code>      try (InputStream is = new ByteArrayInputStream(data)) {</code>\n<code>         is.read(new byte[2]);</code>\n<code>         if(!is.markSupported()) return -1;</code>\n<code>         is.mark(5);</code>\n<code>         is.read();is.read();</code>\n<code>         is.skip(3);</code>\n<code>         is.reset();</code>\n<code>         return is.read();</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String... sprockets) throws Exception {</code>\n<code>      final WidgetProcessor p = new WidgetProcessor();</code>\n<code>      System.out.print(p.getWidgetNumber(new byte[] {1,2,3,4,5,6,7}));</code>\n<code>   }</code>\n<code>}</code>",answers:["3","5","7","An exception is thrown at runtime."]},{title:"Assuming the working directory is accessible, empty, and able to be written, how many file system objects does the following class create?",code:'<code>1: package kitchen;</code>\n<code>2: import java.io.*;</code>\n<code>3: public class Bakers {</code>\n<code>4:    public static void main(String... tooMany) throws IOException {</code>\n<code>5:       File cake = new File("cake.txt");</code>\n<code>6:       Writer pie = new FileWriter("pie.txt");</code>\n<code>7:       pie.flush();</code>\n<code>8:       new File("fudge.txt").mkdirs();</code>\n<code>9:    } }</code>',answers:["None","One","Two","Three"]},{title:"Let\u2019s say you wanted to read data from a file stored on disk that consists of String, long, and Object values? Given that the file is quite large, you intend to use three classes to achieve this result. Which of the following is not one of the three classes you should use?",code:null,answers:["BufferedInputStream","BufferedReader","FileInputStream","ObjectInputStream"]},{title:"Which statement best describes the following two methods?",code:'<code>public String getNameQuick() throws IOException {</code>\n<code>   final BufferedReader r = new BufferedReader(</code>\n<code><span epub:type="pagebreak" id="Page_314"></span>         new FileReader("saved.name"));</code>\n<code>   final String name = r.readLine();</code>\n<code>   r.flush();</code>\n<code>   return name;</code>\n<code>}</code>\n<code>public String getNameSafely() throws IOException {</code>\n<code>   try(final BufferedReader r = new BufferedReader(</code>\n<code>         new FileReader("saved.name"))) {</code>\n<code>      final String name = r.readLine();</code>\n<code>      r.flush();</code>\n<code>      return name;</code>\n<code>}}</code>',answers:["Both methods compile and are equivalent to each other.","Neither method compiles.","Only one of the methods compiles.","The methods compile, but one method may lead to a resource leak."]},{title:"What is the output of the following application? Assume the System.console() is available and the user enters badxbad and presses Enter.",code:"<code>package hardway;</code>\n<code>import java.io.*;</code>\n<code>public class InconvenientImplementation {</code>\n<code>   public static void main(String... dontDoThis) throws Exception {</code>\n<code>      Console c = System.console();</code>\n<code>      if(c != null) {</code>\n<code>         c.writer().write('P');</code>\n<code>         c.writer().write('a');</code>\n<code>         c.writer().write('s');</code>\n<code>         c.writer().write('s');</code>\n<code>         c.writer().flush();  // t1</code>\n<code>         int i;</code>\n<code>         StringBuilder sb = new StringBuilder();</code>\n<code>         while((i = c.reader().read()) != 'x') {  // t2</code>\n<code>            sb.append((char)i);</code>\n<code>         }</code>\n<code>         c.writer().format(\"Result: %s\",sb.toString());</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>",answers:["Result: bad","Line t1 does not compile or triggers an exception at runtime.","Line t2 does not compile or triggers an exception at runtime.","None of the above"]},{title:"Why does Console readPassword() return a char array rather than a String?",code:null,answers:["It improves performance.","It improves security.","Passwords must be stored as a char array.","String cannot hold the individual password characters."]},{title:"Which statement about the following program is true?",code:'<code>package mystical;</code>\n<code>import java.io.*;</code>\n<code>public class Unicorn {</code>\n<code>   public void findUnicorns() {</code>\n<code>      try(InputStream o = new ObjectInputStream(readBook())) {</code>\n<code>         while(o.read() != -1) {</code>\n<code>            System.out.println(o.read());</code>\n<code>         }</code>\n<code>      } catch (Throwable t) {</code>\n<code>         throw new RuntimeException(t);</code>\n<code>      }</code>\n<code>   }</code>\n<code>   private InputStream readBook() throws IOException {</code>\n<code>      return new BufferedInputStream(new FileReader("magic.book"));</code>\n<code>   }</code>\n<code>   public static void main(String... horn) {</code>\n<code>      new Unicorn().findUnicorns();</code>\n<code>   }</code>\n<code>}</code>',answers:["The code does not compile.","The program prints every byte in the file without throwing an exception.","The program prints every other byte in the file without throwing an exception.","The program throws an EOFException when the end of the file is reached."]},{title:"Choose the class that is least likely to be marked Serializable.",code:null,answers:["A class that holds data about the amount of rain that has fallen in a given year","A class that manages the memory of running processes in an application","A class that stores information about apples in an orchard","A class that tracks the amount of candy in a gumball machine"]},{title:"What is the output of the following application?",code:'<code>package cell;</code>\n<code>import java.io.*;</code>\n<code>public class TextMessage {</code>\n<code>   public String receiveText() throws Exception {</code>\n<code>      try (Reader r = new FileReader("messages.txt")) {</code>\n<code>         StringBuilder s = new StringBuilder();</code>\n<code>         int c;</code>\n<code>         while((c = r.read()) != -1) {</code>\n<code>            s.append((char)c);</code>\n<code>            if(r.markSupported()) {</code>\n<code>               r.mark(100);</code>\n<code>               r.skip(10);</code>\n<code>               r.reset();</code>\n<code>            }</code>\n<code>         }</code>\n<code>         return s.toString();</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public void sendText(String message) throws Exception {</code>\n<code>      try (Writer w = new FileWriter("messages.txt")) {</code>\n<code>         for(int i=0; i&lt;message.length(); i++) {</code>\n<code>            w.write(message.charAt(i));</code>\n<code>            w.skip(1);</code>\n<code>         }</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] minutes) throws Exception {</code>\n<code>      final TextMessage m = new TextMessage();</code>\n<code>      m.sendText("You up?");</code>\n<code>      System.out.println(m.receiveText());</code>\n<code>   } }</code>',answers:["You up?","Y o u   u p ?","The code does not compile because of the receiveText() method.","The code does not compile because of the sendText() method."]},{title:"What is the output of the following program? Assume the file paths referenced in the class exist and are able to be written to and read from.",code:'<code>package heart;</code>\n<code>import java.io.*;</code>\n<code>public class Valve implements Serializable {</code>\n<code>   private int chambers = -1;</code>\n<code>   private transient Double size = null;</code>\n<code>   private static String color;</code>\n<code>   public Valve() {</code>\n<code>      this.chambers = 3;</code>\n<code>      color = "BLUE";</code>\n<code>   }</code>\n<code>&nbsp;</code>\n<code>   public static void main(String[] love) throws Throwable {</code>\n<code>      try (ObjectOutputStream o = new ObjectOutputStream(</code>\n<code>            new FileOutputStream("scan.txt"))) {</code>\n<code>         final Valve v = new Valve();</code>\n<code>         v.chambers = 2;</code>\n<code>         v.size = 10.0;</code>\n<code>         v.color = "RED";</code>\n<code>         o.writeObject(v);</code>\n<code>      }</code>\n<code>      new Valve();</code>\n<code>      try (ObjectInputStream o = new ObjectInputStream(</code>\n<code>            new FileInputStream("scan.txt"))) {</code>\n<code>         Valve v = (Valve)o.readObject();</code>\n<code>         System.out.print(v.chambers+","+v.size+","+v.color);</code>\n<code>      }</code>\n<code>   }</code>\n<code>   { chambers = 4; }</code>\n<code>}</code>',answers:["2,null,RED","2,null,BLUE","3,10.0,RED","The code does not compile."]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t],ol:e.ol}});i[12].imageUrl="./images/image-ocp-ch18-13.png",t.default=i},174:function(e,t,o){"use strict";o.r(t);var n=["C. A symbolic link is a file that contains a reference to another file or directory within the file system, making Options A and B incorrect. Further, there is no such thing as an irregular file. Option C is the correct answer because a regular file is not a directory and contains content, unlike a symbolic link or resource. Option D is also incorrect because all symbolic links are stored as files, not directories, even when their target is a directory.","C. The NIO.2 Path interface contains the methods getRoot() and toRealPath(). On the other hand, the method isDirectory() is found in the NIO.2 Files class, while the method listFiles() is found in the java.io.File class. For these reasons, Option C is the correct answer.","A. The code does not compile because there is no NIO.2 class File that contains an isHidden() method, making Option A the correct answer. There is a java.io.File class, but that does not contain an isHidden() method either. The correct call is Files.isHidden(). Remember to check File vs. Files as well as Path vs. Paths on the real exam. If the correct method call was used, the program would print Found!, and Option C would be the correct answer.","D. A breadth-first traversal is when all elements of the same level, or distance from the starting path, are visited before moving on to the next level. On the other hand, a depth-first traversal is when each element\u2019s entire path, from start to finish, is visited before moving onto another path on the same level. Both walk() and find() use depth-first traversals, so Option D is the correct answer.","A. Reading an attribute interface is accomplished in a single trip to the underlying file system. On the other hand, reading multiple file attributes using individual Files methods requires a round-trip to the file system for each method call. For these reasons, Option A is the correct answer. Option B is incorrect because nothing guarantees it will perform faster, especially if the Files method is only being used to read a single attribute. For multiple calls, it is expected to be faster, but the statement uses the word guarantees, which is incorrect. Option C is also incorrect because both have built-in support for symbolic links. Finally, Option D is incorrect because this discussion has nothing to do with memory leaks.","B. First off, the class compiles without issue. It is not without problems, though. The Files.isSameFile() method call on line j1 first checks if the Path values are equivalent in terms of equals(). One is absolute and the other is relative, so this test will fail. The isSameFile() method then moves on to verify that the two Path values reference the same file system object. Since we know the directory does not exist, the call to isSameFile() on line j1 will produce a NoSuchFileException at runtime, making Option B the correct answer. ","B. A cycle is caused when a path contains a symbolic link that references the path itself, or a parent of the parent, triggering an infinitely deep traversal. That said, Files.walk() does not follow symbolic links by default. For this reason, the cycle is never activated, and the code would print a number at runtime, making Option B the correct answer. If the FOLLOW_LINKS enum value was used in the call to Files.walk(), then it would trigger a cycle resulting in a FileSystemLoopException at runtime, and Option A would be the correct answer.","B. The methods length() and getLength() do not exist in the Files class, making Options A and C incorrect. Recall that the java.io.File method retrieves the size of a file on disk. The NIO.2 Files class includes the Files.size() method to accomplish this same function. For this reason, Option B is the correct answer.","D. The code compiles without issue, making Option C incorrect. Even though tricks would be dropped in the normalized path /bag/of/disappear.txt, there is no normalize() call, so path.subpath(2,3) returns tricks on line 5. On line 6, the call to getName() throws an IllegalArgumentException at runtime. Since getName() is zero-indexed and contains only one element, the call on line 6 throws an IllegalArgumentException, making Option D the correct answer. If getName(0) had been used instead of getName(1), then the program would run without issue and print /home/tricks, and Option A would have been the correct answer.","A. The NIO.2 Files class contains the method isSameFile(). The methods length() and mkdir() are found in java.io.File, with the NIO.2 equivalent versions being Files.size() and Files.createDirectory(), respectively. In addition, the relativize() method is found in NIO.2 Path, not Files. Since only isSameFile() is found in NIO.2 Files, Option A is the correct answer.","B. First off, the code compiles without issue, so Option D is incorrect. The enum value REPLACE_EXISTING does not use a type, although this compiles correctly if a static import of StandardCopyOption is used. The AtomicMoveNotSupportedException in Option A is only possible when the ATOMIC_MOVE option is passed to the move() method. Similarly, the FileAlreadyExistsException in Option C is only possible when the REPLACE_EXISTING option is not passed to the move() method. That leaves us with the correct answer of Option B. A DirectoryNotEmptyException can occur regardless of the options passed to the Files.move() method.","D. The Path method getFileName() returns a Path instance, not a String. For this reason, the code does not compile, regardless of which line of code is inserted into the blank, making Option D the correct answer. Statements I and III are two valid ways to create a Path instance. If the method was updated to use Path as the return type, then Option B would be the correct answer. Statement II would cause the method to not compile, because Path is an interface and requires a class to be instantiated.","A. The code compiles without issue, but that\u2019s about it. The class may throw an exception at runtime, since we have not said whether or not the source file exists nor whether the target file already exists, is a directory, or is write-protected. For these reason, Option B is incorrect. Option C is also incorrect because the implementation is a flawed copy method. On a regular file, the code will copy the contents but the line breaks would be missing in the target file. In order to correctly copy the original file, a line break would have to be written after each time temp is written. Since it is the only correct statement, Option A is the correct answer.","C. First off, there is no Files.readLines() method, making Options B and D immediately incorrect. The Files.readAllLines() method returns a List<String>, while the Files.lines() method returns a Stream<String>. For this reason, Option C is the correct answer, and Option A is incorrect.","A. The program compiles and runs without issue, making Options C and D incorrect. Like String instances, Path instances are immutable. For this reason, the resolve() operation on line 7 has no impact on the lessTraveled variable. Since one Path ends with /spot.txt and the other does not, they are not equivalent in terms of equals(), making Option A the correct answer. If lines 6 and 7 were combined, such that the result of the resolve() operation was stored in the lessTraveled variable, then normalize() would reduce lessTraveled to a Path value that is equivalent to oftenTraveled, making Option B the correct answer.","C. Options A, B, and D are each advantages of using NIO.2. As you may remember, using an attribute view to read multiple attributes at once is more efficient than a single attribute call since it involves fewer round trips to the file system. Option C is the correct answer. Neither API provides a single method to delete a directory tree.","C. The Files.delete() method has a return type of void, not boolean, resulting in a compilation error and making Option C the correct answer. There is another method, Files.deleteIfExists(), which returns true if the file is able to be deleted. If it was used here instead, the file would compile and print a list of true values, making Option A the correct answer. As stated in the description, the directory tree is fully accessible, so none of the Files.deleteIfExists() would return false.","D. First off, DosFileAttributes and PosixFileAttributes extend BasicFileAttributes, which means they are compatible with the readAttributes() method signature. Second, they produce instances that inherit the interface BasicFileAttributes, which means they can be assigned to a variable b of type BasicFileAttributes without an explicit cast. For this reason, all three interfaces are permitted, and Option D is the correct answer.","D. The relativize() method requires that both path values be absolute or relative. Based on the details provided, p1 is a relative path, while p2 is an absolute path. For this reason, the code snippet produces an exception at runtime, making Option D the correct answer. If the first path was modified to be absolute by dropping the leading dot (.) in the path expression, then the output would match the values in Option A.","C. First off, p2 is an absolute path, which means that p1.resolve(p2) just returns p2. For this reason, Option B is incorrect. Since p1 is a relative path, it is appended onto p2, making Option C correct and Option A incorrect.","B. The code does not compile because Files.list() returns a Stream<Path>, not a List<Path>, making Option B the correct answer. Note that java.io.File does include a list() method that returns an array of String values and a listFiles() method that returns an array of File values, but neither is applicable here.","C. For this problem, remember that the path symbols can be applied to simplify the path before needing to apply any symbolic links in the file system. The paths in Options A and B can both be reduced from /objC/bin/../backwards/../forward/Sort.java and /objC/bin/../forward/./Sort.java, respectively, to /objC/forward/Sort.java just using the path symbols. Because of the symbolic link, this references the same file as /java/Sort.java. For these reasons, Options A and B match our target path. Option C can be reduced from /objC/bin/../java/./forward/Sort.java to /objC/java/forward/Sort.java, which does not match the desired path for the file. The symbolic link is not followed since it exists in the /objC directory, not in the /objC/java directory. This causes a stack trace to be printed at runtime since the path does not exist, making Option C the correct answer. Option D can be reduced from /objC/bin/../../java/Sort.java to /java/Sort.java, which matches the target path without using the symbolic link.","B. We need to empty the /objC directory before we can delete it. First, the Heap.exe file would have to be deleted before the bin directory could be removed, for a total of two calls to Files.delete(). Next, the Heap.m file is easily deleted with a single call to Files.delete(). Calling Files.delete() on the symbolic link forward deletes the link itself and leaves the target of the symbolic link intact. With a total of four calls, Option B is the correct answer. Option A is incorrect because Java requires directories to be empty before they can be deleted. Option C is also incorrect. It might make sense if Files.delete() traversed symbolic links on a delete, but since this is not the case, it is an incorrect answer. Option D is incorrect because there is no Files.deleteSymbolicLink() method defined in the Java NIO.2 API.","C. Since System.out is a PrintStream that inherits OutputStream and implements Closeable, line y1 compiles without issue. On the other hand, the Files.copy() does not compile because there is no overloaded version of Files.copy() that takes an OutputStream as the first parameter. For this reason, Option C is the correct answer. If the order of the arguments in the Files.copy() call was switched, then the code would compile and print the contents of the file at runtime, making Option D the correct answer.","B. To begin with, the BasicFileAttributeView class contains methods to read and write file data, while the BasicFileAttributes class only contains methods to read file data. The advantage of using a BasicFileAttributeView is to also modify file data, so Option D is incorrect. Next, The BasicFileAttributeView does not include a method to modify the hidden attribute. Instead, a DosFileAttributeView is required, making Option A incorrect. Option B is the correct answer because BasicFileAttributeView includes a setTimes() method to modify the file date values. Finally, Option C is incorrect because both read file information in a single round-trip.","A. Trick question! The code does not compile, therefore no Path values are printed, and Option A is the correct answer. The key here is that toRealPath() interacts with the file system and therefore throws a checked IOException. Since this checked exception is not handled inside the lambda expression, the class does not compile. If the lambda expression was fixed to handle the IOException, then the expected number of Path values printed would be six, and Option C would be the correct answer. A maxDepth value of 1 causes the walk() method to visit two total levels, the original /flower and the files it contains.","D. The first statement returns a null value, since the path .. does not have a parent. That said, it does not throw an exception at runtime, since it is not operated upon. The second and third statements both return paths representing the root (/) at runtime. Remember that calling getRoot() on a root path returns the root path. The fourth statement throws a NullPointerException at runtime since getRoot() on a relative path returns null, with the call to getParent() triggering the exception. Since the fourth statement is the only one to produce a NullPointerException at runtime, Option D is the correct answer.","C. The code compiles without issue, so Options A and B are incorrect. While many of the Files methods do throw IOException, most of the Path methods do not throw a checked exception. The lack of indent of the return statement on line 6 is intentional and does not prevent the class from compiling. If the input argument p is null or not an absolute path, then the if-then clause is skipped, and it is returned to the caller unchanged. Alternatively, if the input argument is an absolute path, then calling toAbsolutePath() has no effect. In both cases, the return value of the method matches the input argument, making Option C the correct answer.","D. Option A is incorrect because both methods take exactly one Path parameter, along with an optional vararg of FileAttribute values. Option B is also incorrect because both methods will throw a FileAlreadyExistsException if the target exists and is a file. Option C is incorrect since both methods declare a checked IOException. The correct answer is Option D. The method createDirectory() creates a single directory, while createDirectories() may create many directories along the path value.","C. The toAbsolutePath() combines the current working directory and relative path to form a /hail/../jungle/.././rain.. path. The normalize() method removes the path symbols and leaves a /rain.. value. Note that the last double period (..) is not removed because it is part of a path name and not interpreted as a path symbol. The result is then appended with snow.txt and we are left with /rain../snow.txt, making Option C the correct answer.","A. The program compiles and runs without issue, so Options C and D are incorrect. The process breaks apart the inputted path value and then attempts to reconstitute it. There is only one problem. The method call getName(0) does not include the root element. This results in the repaired variable having a value of tissue/heart/chambers.txt, which is not equivalent to the original path. The program prints false, and Option A is the correct answer.","B. Unlike Files.delete(), the Files.deleteIfExists() method does not throw an exception if the path does not exist, making Option B the correct answer. Options A, C, and D describe situations in which the Java process encounters a path in a state that cannot be deleted. In each of these situations, an exception would be thrown at runtime.","D. The code does not compile because Path is an interface and does not contain a get() method. Since the first line contains a compilation error, Option D is the correct answer. If the code was corrected to use Paths.get(), then the output would be true false true, and Option B would be the correct answer. The normalized path of both is /desert/sand.doc, which means they would be equivalent, in terms of equals(), and point to the same path in the file system. On the other hand, the non-normalized values are not equivalent, in terms of equals(), since the objects represent distinct path values.","C. First off, the Files.getFileAttributeView() method requires a reference to a subclass of FileAttributeView, such as BasicFileAttributeView.class. The parameter must also be compatible with the reference assignment to vw. For these two reasons, this line of code does not compile. Next, BasicFileAttributeView does not contain a creationTime() method, so vw.creationTime() results in a compilation error. For the exam, remember that view classes do contain access to attributes, but only through the readAttributes method, such as vw.readAttributes().creationTime(). Since these are the only two lines that contain compilation errors, Option C is the correct answer. Note that we purposely omitted all import statements in this question, since this may happen on the real exam.","B. The program compiles and runs without issue, making Options C and D incorrect. The first variable, halleysComet, is created with normalize() being applied right away, leading to a value of stars/m1.meteor. The second variable, lexellsComet, starts with a value of ./stars/../solar/. The subpath() call reduces it to its first two components, ./stars. The resolve() method then appends m1.meteor, resulting in a value of ./stars/m1.meteor. Finally, normalize() further reduces the value to stars/m1.meteor. Since this matches our first Path, the program prints Same!, and Option B is the correct answer.","D. Both stream statements compile without issue, making Options A and B incorrect. The two statements are equivalent to one another and print the same values at runtime. For this reason, Option C is incorrect, and Option D is correct. There are some subtle differences in the implementation besides one using walk() with a filter() and the other using find(). The walk() call does not include a depth limit, but since Integer.MAX_VALUE is the default value, the two calls are equivalent. Furthermore, the walk() statement prints a stream of absolute paths stored as String values, while the find() statement prints a stream of Path values. If the input p was a relative path, then these two calls would have very different results, but since we are told p is an absolute path, the application of toAbsolutePath() does not change the results.","A. The code does not compile because Files.lines() and Files.readAllLines() throw a checked IOException, which must be handled or declared. For the exam, remember that other than a handful of test methods, like Files.exists(), most methods in the NIO.2 Files class that operate on file system records declare an IOException. Now, if the exceptions were properly handled or declared within the class, then jonReads() would likely take more time to run. Like all streams, Files.lines() loads the contents of the file in a lazy manner, meaning the time it takes for jenniferReads() to run is constant regardless of the file size. Note the stream isn\u2019t actually traversed since there is no terminal operation. Alternatively, Files.readAllLines() reads the entire contents of the file before returning a list of String values. The larger the file, the longer it takes jonReads() to execute. Since the original question says the file is significantly large, then if the compilation problems were corrected, jonReads() would likely take longer to run, and Option C would be the correct answer.","C. The first copy() method call on line q1 compiles without issue because it matches the signature of a copy() method in Files. It also does not throw an exception because the REPLACE_EXISTING option is used and we are told the file is fully accessible within the file system. On the other hand, the second copy() method on line q2 does not compile. There is a version of Files.copy() that takes an InputStream, followed by a Path and a list of copy options. Because BufferedReader does not inherit InputStream, though, there is no matching copy() method and the code does not compile. For this reason, Option C is the correct answer.","C. The Files.isSameFile() throws a checked IOException. Even though accessing the file system can be skipped in some cases, such as if the Path instances are equivalent in terms of equals(), the method still declares IOException since it may access the file system to determine if the two Path instances refer to the same file. For this reason, Option C is the correct answer. The rest of the methods listed do not throw any checked exceptions, even though they do access the file system, instead returning false if the file does not exist.","B. The program compiles and runs without issue, making Options C and D incorrect. The program uses Files.list() to iterate over all files within a single directory. For each file, it then iterates over the lines of the file and counts the sum. For this reason, Option B is the correct answer. If the count() method had used Files.walk() instead of Files.lines(), then the class would still compile and run, and Option A would be the correct answer. Note that we had to wrap Files.lines() in a try-catch block because using this method directly within a lambda expression without a try-catch block leads to a compilation error."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"Fill in the blanks: A(n)__________ is a file that contains a reference to another file or directory, while a(n)__________ is a file that contains content.",code:null,answers:["irregular file, regular file","regular file, opaque file","symbolic link, regular file","symbolic link, symbolic directory"]},{title:"Which methods listed below are found in the NIO.2 Path interface?",code:null,answers:["I only","I, II, and III","I and IV","II and III"],ol:["getRoot()","isDirectory()","listFiles()","toRealPath()"]},{title:"Assuming the file /secret/hide.txt exists and is marked hidden, what is result of executing the following program?",code:'<code>package hidden;</code>\n<code>import java.nio.file.*;</code>\n<code>public class Finder {</code>\n<code>   public void findHiddenFile(Path p) throws Exception {</code>\n<code>      if(File.isHidden(p)) {</code>\n<code>         System.out.print("Found!");</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] folders) throws Exception {</code>\n<code>      final Finder f = new Finder();</code>\n<code>      f.findHiddenFile(Paths.get("/secret/hide.txt"));</code>\n<code>   }</code>\n<code>}</code>',answers:["The class does not compile.","An exception is printed at runtime.","Found! is printed at runtime.","Nothing is printed at runtime."]},{title:"Fill in the blanks: Files.walk() performs a __________ traversal, while  Files.find() performs a __________ traversal.",code:null,answers:["breadth-first, breadth-first","breadth-first, depth-first","depth-first, breadth-first","depth-first, depth-first"]},{title:"When reading file information, what is an advantage of using an NIO.2 attribute interface rather than reading the values individually from Files methods?",code:null,answers:["Costs fewer round-trips to the file system","Guarantees performance improvement","Has support for symbolic links","Reduces memory leaks"]},{title:"What is the result of compiling and executing the following program? Assume the current directory is /stock and the path /stock/sneakers does not exist prior to execution.",code:'<code>package shoe;</code>\n<code>import java.io.*;</code>\n<code>import java.nio.file.*;</code>\n<code>public class Sneaker {</code>\n<code>   public void setupInventory(Path desiredPath) throws Exception {</code>\n<code>      Path suggestedPath = Paths.get("sneakers");</code>\n<code>      if(Files.isSameFile(suggestedPath, desiredPath)  // j1</code>\n<code>            &amp;&amp; !Files.exists(suggestedPath))</code>\n<code>         Files.createDirectories(desiredPath);  // j2</code>\n<code>   }</code>\n<code>   public static void main(String[] socks) throws Exception {</code>\n<code>      Path w = new File("/stock/sneakers").toPath();  // j3</code>\n<code>      new Sneaker().setupInventory(w);</code>\n<code>   }</code>\n<code>}</code>',answers:["The directory /stock/sneakers is created.","Line j1 does not compile or produces an exception at runtime.","Line j2 does not compile or produces an exception at runtime.","Line j3 does not compile or produces an exception at runtime."]},{title:"Assuming the path referenced below exists and contains a symbolic link that references  /again, what is the expected result of executing the following code snippet?",code:'<code>System.out.print(Files.walk(Paths.get("/again/and/again")).count());</code>',answers:["An exception is thrown at runtime.","A number is printed at runtime.","The process hangs indefinitely.","The result cannot be determined with the information given."]},{title:"Which method in the NIO.2 Files class is equivalent to the java.io.File method length()?",code:null,answers:["length()","size()","getLength()","None of the above"]},{title:"Assuming the current working directory is /home, then what is the output of the following program?",code:'<code>1:  package magic;</code>\n<code>2:  import java.nio.file.*;</code>\n<code>3:  public class Magician {</code>\n<code>4:     public String doTrick(Path path) {</code>\n<code>5:        return path.subpath(2,3)</code>\n<code>6:           .getName(1)</code>\n<code>7:           .toAbsolutePath()</code>\n<code>8:           .toString();</code>\n<code>9:     }</code>\n<code>10:    public static void main(String... cards) {</code>\n<code>11:       final Magician m = new Magician();</code>\n<code>12:       System.out.print(m.doTrick(</code>\n<code>13:          Paths.get("/bag/of/tricks/.././disappear.txt")));</code>\n<code>14:    } }</code>',answers:["/home/tricks","/home","The code does not compile.","The code compiles but prints an exception at runtime."]},{title:"Which methods listed below are found in the NIO.2 Files class?",code:null,answers:["I only","I, II, and IV","II and III","IV only"],ol:["isSameFile()","length()","relativize()","mkdir()"]},{title:"The following code snippet, which attempts to move a file system record from oldHardDrivePath to newHardDrivePath, results in an exception at runtime.  Which of the following is the most likely type of exception to be thrown?",code:"<code>Files.move(oldHardDrivePath,newHardDrivePath,REPLACE_EXISTING);</code>",answers:["AtomicMoveNotSupportedException","DirectoryNotEmptyException","FileAlreadyExistsException","None of the above since the line of code does not compile"]},{title:"Which of the following can be filled into the blank that would allow the method to compile?",code:"<code>public String getPathName(String fileName) {</code>\n<code>   final Path p = ____________________;</code>\n<code>   return p.getFileName();</code>\n<code>}</code>",answers:["I and II","I and III","II","None of the above"],ol:["new File(fileName).toPath()","new Path(fileName)","FileSystems.getDefault().getPath(fileName)"]},{title:"Which statement about the following class is correct?",code:'<code>package clone;</code>\n<code>import java.io.*;</code>\n<code>import java.nio.file.*;</code>\n<code>public class Rewriter {</code>\n<code>   public static void copy(Path source, Path target) throws Exception {</code>\n<code>      try (BufferedReader r = Files.newBufferedReader(source);</code>\n<code>            Writer w = Files.newBufferedWriter(target)) {</code>\n<code>         String temp = null;</code>\n<code>         while((temp = r.readLine()) != null) {</code>\n<code>            w.write(temp);</code>\n<code>         }</code>\n<code>      }</code>\n<code><span epub:type="pagebreak" id="Page_325"></span>   }</code>\n<code>   public static void main(String[] tooMany) throws Throwable {</code>\n<code>      Rewriter.copy(Paths.get("/original.txt"),</code>\n<code>         FileSystems.getDefault().getPath("/","unoriginal.txt"));</code>\n<code>   }</code>\n<code>}</code>',answers:["The class compiles without issue.","The class never throws an exception at runtime.","The implementation correctly copies a regular file.","All of the above"]},{title:"Fill in the blanks: The Files.__________ method returns a List, while the Files.__________ method returns a Stream.",code:null,answers:["lines(), readAllLines()","lines(), readLines()","readAllLines(), lines()","readLines(), lines()"]},{title:"What is the output of the following application?",code:'<code>1:  package yellow;</code>\n<code>2:  import java.nio.file.*;</code>\n<code>3:  public class Road {</code>\n<code>4:     public boolean findHome() {</code>\n<code>5:        Path oftenTraveled = Paths.get("/highway/street/spot.txt");</code>\n<code>6:        Path lessTraveled = Paths.get("/highway/street/house/../.");</code>\n<code>7:        lessTraveled.resolve("spot.txt");</code>\n<code>8:        return oftenTraveled.equals(lessTraveled.normalize());</code>\n<code>9:     }</code>\n<code>10:    public static void main(String... emerald) {</code>\n<code>11:       System.out.print("AM I HOME? "</code>\n<code>12:             +(new Road().findHome() ? "yes" : " no"));</code>\n<code>13:    }</code>\n<code>14: }</code>',answers:["AM I HOME? no","AM I HOME? yes","The class does not compile.","The class compiles but throws an exception at runtime."]},{title:"Which of the following is not an advantage of using an NIO.2 Path instead of a  java.io.File to work with files?",code:null,answers:["Contains built-in support for symbolic links","Has ability to read operating-system-specific attributes","Provides a single method for deleting a directory tree","Provides efficient access of file metadata"]},{title:"What is the result of executing the following program? Assume the path /driveway exists and is non-empty, and the directory tree is fully accessible within the file system.",code:'<code>package weather;</code>\n<code>import java.io.*;</code>\n<code>import java.nio.file.*;</code>\n<code>public class Snow {</code>\n<code>   public static boolean removeSnow(Path flake) throws IOException {</code>\n<code>      if(!Files.isDirectory(flake) &amp;&amp; !Files.isSymbolicLink(flake))</code>\n<code>         return Files.delete(flake);</code>\n<code>      else return true;</code>\n<code>   }</code>\n<code>   public static void main(String[] cones) throws IOException {</code>\n<code>      File driveway = new File("/driveway");</code>\n<code>      for(File f : driveway.listFiles()) {</code>\n<code>         System.out.println(removeSnow(f.toPath()));</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["The program prints a list of only true values.","The program prints a mix of true and false values.","The code does not compile.","The code compiles but prints an exception at runtime."]},{title:"Which interface name inserted into the blank below allows the code snippet to compile?",code:'<code>Path file = Paths.get("/data/movie.txt");</code>\n<code>BasicFileAttributes b = Files.readAttributes(file, __________);</code>',answers:["BasicFileAttributes.class","DosFileAttributes.class","PosixFileAttributes.class","All of the above"]},{title:"What is the output of the following code snippet? Assume that the current directory is the root path.",code:'<code>Path p1 = Paths.get("./locks");</code>\n<code>Path p2 = Paths.get("/found/red.zip");</code>\n<code>System.out.println(p1.relativize(p2));</code>\n<code>System.out.println(p2.relativize(p1));</code>',answers:["\n\n../found/red.zip \n\n../../locks\n","\n\n../../locks \n\n../found/red.zip\n","\n\nlocks/../found/red.zip \n\n../found/locks\n","None of the above"]},{title:"What is the output of the following code snippet? Assume that the current directory is the root path.",code:'<code>Path p1 = Paths.get("./found/../keys");</code>\n<code>Path p2 = Paths.get("/lost/blue.txt");</code>\n<code>System.out.println(p1.resolve(p2));</code>\n<code>System.out.println(p2.resolve(p1));</code>',answers:["\n\n/lost/blue.txt \n\n./found/../keys\n","\n\n/found/../keys/./lost/blue.txt \n\n/lost/blue.txt/keys\n","\n\n/lost/blue.txt \n\n/lost/blue.txt/./found/../keys\n","None of the above"]},{title:"What is the output of the following application? Assume the application is called with a valid path that exists and is accessible within the file system.",code:'<code>package charity;</code>\n<code>import java.nio.file.*;</code>\n<code>public class Roster {</code>\n<code>   protected void printRoster(Path p) {</code>\n<code>      for(Path f : Files.list(p)) {  // n1</code>\n<code>         if(f.toString().endsWith(".per"))  // n2</code>\n<code>            System.out.print(f);</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String... volunteers) {</code>\n<code>      new Roster().printRoster(Paths.get(volunteers[0]));</code>\n<code>   }</code>\n<code>}</code>',answers:["A list of file names is printed at runtime.","The class does not compile due to line n1.","The class does not compile due to line n2.","None of the above"]},{title:"Given the following file system diagram, in which forward is a symbolic link to the java directory, which value does not print /java/Sort.java at runtime?",code:'<code>Path p = Paths.get("/", "objC", "bin");</code>\n<code>System.out.println(p.resolve("__________").toRealPath());</code>',answers:["../backwards/../forward/Sort.java","../forward/./Sort.java","../java/./forward/Sort.java","../../java/Sort.java"]},{title:"Using the file system diagram from the previous question, including the symbolic link from forward to java, how many calls to Files.delete() would need to be made before the following line could be executed without throwing an exception?",code:'<code>Files.delete(Paths.get("/objC"));</code>',answers:["One","Four","Seven","None of the above. The symbolic link needs to be removed with  Files.deleteSymbolicLink() first."]},{title:"Assuming the course.txt file exists and is readable, what is the result of executing the following application?",code:'<code>package schoolwork;</code>\n<code>import java.io.*;</code>\n<code>import java.nio.file.*;</code>\n<code>public class Notes {</code>\n<code>   public void printNotes() {</code>\n<code>      try (OutputStream out = System.out) {  // y1</code>\n<code>         Files.copy(out, Paths.get("course.txt"));</code>\n<code>      } catch (IOException e) {</code>\n<code>         throw new RuntimeException(e);</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] coursework) {</code>\n<code>      new Notes().printNotes();</code>\n<code>   }</code>\n<code>}</code>',answers:["The code compiles but prints an exception at runtime.","The class does not compile due to line y1.","The code does not compile for some other reason.","The program prints the contents of the course.txt file."]},{title:"When reading file information, what is an advantage of loading a BasicFileAttributeView over a BasicFileAttributes?",code:null,answers:["Allows the hidden attribute to be set","Allows the last modified date to be changed","All of the file information is read in a single round-trip.","There is no advantage."]},{title:"The Rose application is run with an input argument of /flower. The /flower directory contains five subdirectories, each of which contains five files. How many Path values does the following application print?",code:"<code>import java.nio.file.*;</code>\n<code>public class Rose {</code>\n<code>   public void tendGarden(Path p) throws Exception {</code>\n<code>      Files.walk(p,1)</code>\n<code>         .map(p -&gt; p.toRealPath())</code>\n<code>         .forEach(System.out::println);</code>\n<code>   }</code>\n<code>   public static void main(String... thorns) throws Exception {</code>\n<code>      new Rose().tendGarden(Paths.get(thorns[0]));</code>\n<code>   }</code>\n<code>}</code>",answers:["None","One","Six","Thirty-one"]},{title:"Which of the following statements, when run independently, produces a NullPointerException at runtime? ",code:null,answers:["I and III","I and IV","II and III","IV only"],ol:['Paths.get("../sang").getParent().getParent()','Paths.get("/sing").getParent().getRoot()','Paths.get("/song").getRoot().getRoot()','Paths.get("../sung").getRoot().getParent()']},{title:"Which statement about the following Finalize class is correct?",code:'<code>1: package end;</code>\n<code>2: import java.nio.file.*;</code>\n<code>3: public class Finalize {</code>\n<code>4:    public Path makeAbsolute(Path p) {</code>\n<code>5:       if(p!=null &amp;&amp; !p.isAbsolute())</code>\n<code>6:       return p.toAbsolutePath();</code>\n<code><span epub:type="pagebreak" id="Page_330"></span>7:       return p;</code>\n<code>8:    }</code>\n<code>9: }</code>',answers:["It does not compile because IOException is neither handled nor declared.","It does not compile for some other reason.","The method compiles and returns a Path value that is always equivalent to the input argument.","The method compiles and returns a Path value that may not be equivalent to the input argument."]},{title:"Which of the following is a difference between the createDirectory() and createDirectories() methods found in the NIO.2 Files class?",code:null,answers:["One takes multiple Path arguments; the other does not.","One throws an exception if a file already exists at the directory path; the other does not.","One declares a checked exception; the other does not.","One creates a single directory while the other may create many directories."]},{title:"Assuming the current working directory is /hail, what is the expected output of executing the following code snippet?",code:'<code>Path w1 = Paths.get("../jungle/.././rain..")</code>\n<code>      .toAbsolutePath().normalize();</code>\n<code>System.out.print(w1.resolve("snow.txt"));</code>',answers:["/jungle/snow.txt","/hail/rain../snow.txt","/rain../snow.txt","An exception is printed at runtime."]},{title:"What is the output of the following application?",code:'<code>package med;</code>\n<code>import java.nio.file.*;</code>\n<code>public class Surgeon {</code>\n<code>   public Path rebuild(Path p) {</code>\n<code>      Path v = null;</code>\n<code>      for(int i=0; i&lt;p.getNameCount(); i++)</code>\n<code>         if(v==null) v = p.getName(i);</code>\n<code>         else v = v.resolve(p.getName(i));</code>\n<code>      return v;</code>\n<code>   }</code>\n<code>   public static void main(String... tools) {</code>\n<code>      final Surgeon al = new Surgeon();</code>\n<code><span epub:type="pagebreak" id="Page_331"></span>      Path original = Paths.get("/tissue/heart/chambers.txt");</code>\n<code>      Path repaired = al.rebuild(original);</code>\n<code>      System.out.print(original.equals(repaired));</code>\n<code>   }</code>\n<code>}</code>',answers:["false","true","The code does not compile.","The code compiles but prints an exception at runtime."]},{title:"Under which circumstances does Files.deleteIfExists() not throw an exception?",code:null,answers:["The file system suddenly becomes unavailable.","The path does not exist.","The path represents a non-empty directory.","The process does not have write access to a path."]},{title:"What is the output of the following code snippet? Assume all referenced paths exist within the file system.",code:'<code>Path v1 = Path.get("/./desert/./").resolve(Paths.get("sand.doc"));</code>\n<code>Path v2 = new File("/desert/./cactus/../sand.doc").toPath();</code>\n<code>System.out.print(Files.isSameFile(v1,v2));</code>\n<code>System.out.print(" "+v1.equals(v2));</code>\n<code>System.out.print(" "+v1.normalize().equals(v2.normalize()));</code>',answers:["false false false","true false true","true true true","None of the above"]},{title:"How many lines of the following program contain compilation errors?",code:'<code>public class Song {</code>\n<code>   public static void organize(Path folder, Path file) throws IOException {</code>\n<code>      Path p = folder.resolve(file);</code>\n<code>      BasicFileAttributeView vw = Files.getFileAttributeView(p,</code>\n<code>         BasicFileAttributes.class);</code>\n<code>      if(vw.creationTime().toMillis()&lt;System.currentTimeMillis()) {</code>\n<code>         vw.setTimes(FileTime.fromMillis(System.currentTimeMillis()),</code>\n<code>            null,null);</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] audio) throws Exception {</code>\n<code><span epub:type="pagebreak" id="Page_332"></span>      Song.organize(Paths.get("/", "pub"),new File("/songs").toPath());</code>\n<code>   }</code>\n<code>}</code>',answers:["None","One","Two","Three"]},{title:"What is the output of the following application?",code:'<code>package stars;</code>\n<code>import java.nio.file.*;</code>\n<code>public class Sun {</code>\n<code>   public void printInfo() {</code>\n<code>      Path halleysComet = Paths.get("stars/./rocks/../m1.meteor")          .normalize();</code>\n<code>      Path lexellsComet = Paths.get("./stars/../solar/");</code>\n<code>      lexellsComet = lexellsComet.subpath(0, 2)</code>\n<code>            .resolve("m1.meteor")</code>\n<code>            .normalize();</code>\n<code>      System.out.print(halleysComet.equals(lexellsComet)</code>\n<code>            ? "Same!" : "Different!");</code>\n<code>   }</code>\n<code>   public static void main(String... emerald) {</code>\n<code>      Sun s = new Sun();</code>\n<code>      s.printInfo();</code>\n<code>   }</code>\n<code>}</code>',answers:["Different!","Same!","The class does not compile.","The class compiles but throws an exception at runtime."]},{title:"Assuming the directory /eclipse/projects exists and its contents are accessible, which statement about the following code snippet is correct?",code:'<code>Path p = Paths.get("/eclipse/projects");</code>\n<code>&nbsp;</code>\n<code>Files.walk(p)</code>\n<code>   .map(z -&gt; z.toAbsolutePath().toString())</code>\n<code>   .filter(s -&gt; s.endsWith(".java"))</code>\n<code><span epub:type="pagebreak" id="Page_333"></span>   .collect(Collectors.toList()).forEach(System.out::println);</code>\n<code>&nbsp;</code>\n<code>Files.find(p,Integer.MAX_VALUE,</code>\n<code>      (w,a) -&gt; w.toAbsolutePath().toString().endsWith(".java"))</code>\n<code>   .collect(Collectors.toList()).forEach(System.out::println);</code>',answers:["The first stream statement does not compile.","The second stream statement does not compile.","Both statements compile but are unlikely to print the same results at runtime.","None of the above"]},{title:"Assuming the file referenced below exists and is significantly large, which statement about the following program is correct?",code:'<code>public class SpeedRead {</code>\n<code>   public void jenniferReads(Path p) {</code>\n<code>      Files.lines(p);</code>\n<code>   }</code>\n<code>   public void jonReads(Path p) {</code>\n<code>      Files.readAllLines(p);</code>\n<code>   }</code>\n<code>   public static void main(String[] pages) {</code>\n<code>      Path p = Paths.get("/bookshelf/mobydick.txt");</code>\n<code>      final SpeedRead r = new SpeedRead();</code>\n<code>      r.jenniferReads(p);</code>\n<code>      r.jonReads(p);</code>\n<code>   }</code>\n<code>}</code>',answers:["The code does not compile.","The method jenniferReads() is likely to take longer to run.","The method jonReads() is likely to take longer to run.","It is not possible to know which method will take longer to run."]},{title:"What is the result of executing the following program? Assume the files referenced in the application both exist and are fully accessible within the file system.",code:'<code>package duplicate;</code>\n<code>import static java.nio.file.StandardCopyOption.*;</code>\n<code>import static java.nio.file.Files.*;</code>\n<code>import java.io.*;</code>\n<code>import java.nio.file.*;</code>\n<code>public class CopyOfACopy {</code>\n<code><span epub:type="pagebreak" id="Page_334"></span>   public void main(String[] items) throws Exception {</code>\n<code>      final Path s = new File("apples.zip").toPath();</code>\n<code>      final Path t = FileSystems.getDefault().getPath("oranges.zip");</code>\n<code>      copy(s,t,REPLACE_EXISTING);  // q1</code>\n<code>      copy(Files.newBufferedReader(t),t,ATOMIC_MOVE);  // q2</code>\n<code>   }</code>\n<code>}</code>',answers:["Line q1 does not compile.","Line q1 produces an exception at runtime.","Line q2 does not compile.","Line q2 produces an exception at runtime."]},{title:"Which of the following Files methods requires the enclosing method to handle or declare a checked exception?",code:null,answers:["exists()","isDirectory()","isSameFile()","isSymbolicLink()"]},{title:"What is the output of the following application? Assume /all-data exists and is accessible within the file system.",code:'<code>package numbers;</code>\n<code>import java.nio.file.*;</code>\n<code>import java.util.stream.Stream;</code>\n<code>public class TheCount {</code>\n<code>   public static Stream&lt;String&gt; readLines(Path p) {</code>\n<code>      try {</code>\n<code>         return Files.lines(p);</code>\n<code>      } catch (Exception e) {</code>\n<code>         throw new RuntimeException(e);</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static long count(Path p) throws Exception {</code>\n<code>      return Files.list(p)</code>\n<code>         .filter(w -&gt; Files.isRegularFile(w))</code>\n<code>         .flatMap(s -&gt; readLines(s))</code>\n<code>         .count();</code>\n<code>   }</code>\n<code><span epub:type="pagebreak" id="Page_335"></span>   public final static void main(String[] day) throws Exception {</code>\n<code>      System.out.print(count(Paths.get("/all-data")));</code>\n<code>   }</code>\n<code>}</code>',answers:["The number of lines in all files in a directory tree","The number of lines in all files in a single directory","The code does not compile.","The code compiles but prints an exception at runtime."]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t],ol:e.ol}});i[21].imageUrl="./images/image-ocp-ch19-22.png",t.default=i},175:function(e,t,o){"use strict";o.r(t);var n=["A. The ExecutorService interface defines the two submit() methods shown in Options C and D. Because ExecutorService extends Executor, it inherits the execute(Runnable) method presented in Option B. That leaves us with the correct answer, Option A, because ExecutorService does not define nor inherit an overloaded method execute() that takes a Callable parameter.","B. The class compiles and runs without throwing an exception, making the first statement true. The class defines two values that are incremented by multiple threads in parallel. The first IntStream statement uses an atomic class to update a variable. Since updating an atomic numeric instance is thread-safe by design, the first number printed is always 10, and the second statement is true. The second IntStream statement uses an int with the pre-increment operator (++), which is not thread-safe. It is possible two threads could update and set the same value at the same time, a form of race condition, resulting in a value less than 5. For this reason, the third statement is not true. Since only the first two statements are true, Option B is the correct answer.","C. Option A is incorrect, although it would be correct if Executors was replaced with ExecutorService in the sentence. While an instance of ExecutorService can be obtained from the Executors class, there is no method in the Executors class that performs a task directly. Option B is also incorrect, but it would be correct if start() was replaced with run() in the sentence. It is recommended that you override the run() method, not the start() method, to execute a task using a custom Thread class. Option C is correct, and one of the most common ways to define an asynchronous task. Finally, Option D is incorrect because Options A and B are incorrect.","D. Trick question! ExecutorService does not contain any of these methods. In order to obtain an instance of a thread executor, you need to use the Executors factory class. For this reason, Option D is the correct answer. If the question had instead asked which Executors method to use, then the correct answer would be Option C. Options A and B do not allow concurrent processes and should not be used with a CyclicBarrier expecting to reach a limit of five concurrent threads. Option C, on the other hand, will create threads as needed and is appropriate for use with a CyclicBarrier.","C. CopyOnWriteArrayList makes a copy of the array every time it is modified, preserving the original list of values the iterator is using, even as the array is modified. For this reason, the for loop using copy1 does not throw an exception at runtime. On the other hand, the for loops using copy2 and copy3 both throw ConcurrentModificationException at runtime since neither allows modification while they are being iterated upon. Finally, the ConcurrentLinkedQueue used in copy4 completes without throwing an exception at runtime. For the exam, remember that the Concurrent classes order read/write access such that access to the class is consistent across all threads and processes, while the synchronized classes do not. Because exactly two of the for statements produce exceptions at runtime, Option C is the correct answer.","C. Resource starvation is when a single active thread is perpetually unable to gain access to a shared resource. Livelock is a special case of resource starvation, in which two or more active threads are unable to gain access to shared resources, repeating the process over and over again. For these reasons, Option C is the correct answer. Deadlock and livelock are similar, although in a deadlock situation the threads are stuck waiting, rather than being active or performing any work. Finally, a race condition is an undesirable result when two tasks that should be completed sequentially are completed at the same time.","B. The class does not compile because the Future.get() on line 8 throws a checked InterruptedException and ExecutionException, neither of which is handled nor declared by the submitReports() method. If the submitReports() and accompanying main() methods were both updated to declare these exceptions, then the application would print null at runtime, and Option A would be the correct answer. For the exam, remember that Future can be used with Runnable lambda expressions that do not have a return value but that the return value is always null when completed.","A. Options B and C are both proper ways to obtain instances of ExecutorService. Remember that newSingleThreadExecutor() is equivalent to calling newFixedThreadPool() with a value of 1. Option D is the correct way to request a single-threaded ScheduledExecutorService instance. The correct answer is Option A. The method newFixedScheduledThreadPool() does not exist in the Executors class, although there is one called newScheduledThreadPool().","A. The code compiles without issue but hangs indefinitely at runtime. The application defines a thread executor with a single thread and 12 submitted tasks. Because only one thread is available to work at a time, the first thread will wait endlessly on the call to await(). Since the CyclicBarrier requires four threads to release it, the application waits endlessly in a frozen condition. Since the barrier is never reached and the code hangs, the application will never output Ready, making Option A the correct answer. If newCachedThreadPool() had been used instead of newSingleThreadExecutor(), then the barrier would be reached three times, and Option C would be the correct answer.","D. First off, BlockingDeque is incorrect since it is an interface, not a class. Next, ConcurrentLinkedDeque does support adding elements to both ends of an ordered data structure but does not include methods for waiting a specified amount of time to do so, referred to as blocking. ConcurentSkipListSet is also incorrect, since its elements are sorted and not just ordered, and it does not contain any blocking methods. That leaves the correct answer, Option D. A LinkedBlockingDeque includes blocking methods in which elements can be added to the beginning or end of the queue, while waiting at most a specified amount of time. ","A. The findAny() method can return any element of the stream, regardless of whether the stream is serial or parallel. While on serial streams this is likely to be the first element in the stream, on parallel streams the result is less certain. For this reason, Option A is the correct answer. When applied to an ordered stream, the rest of the methods always produce the same results on both serial and parallel streams. For this reason, these operations can be costly on a parallel stream since it has to be forced into a serial process.","D. The static method Array.asList() returns a List instance, which inherits the Collection interface. While the Collection interface defines a stream() and parallelStream() method, it does not contain a parallel() method. For this reason, the second stream statement does not compile, and Option D is the correct answer. If the code was corrected to use parallelStream(), then the arrays would be consistently printed in the same order, and Option C would be the correct answer. Remember that the forEachOrdered() method forces parallel streams to run in sequential order.","D. To start with, the ForkJoinTask is the parent class of RecursiveAction and RecursiveTask and does not contain a compute() method, neither abstract nor concrete, making Options A and C automatically incorrect. The RecursiveTask class contains the abstract compute() method that utilizes a generic return type, while the RecursiveAction class contains the abstract compute() method that uses a void return type. For this reason, Option D is the correct answer.","B. An accumulator in a serial or parallel reduction must be associative and stateless. In a parallel reduction, invalid accumulators tend to produce more visible errors, where the result may be processed in an unexpected order. Option A is not associative, since (a-b)-c is not the same as a-(b-c) for all values a, b, and c. For example, using values of 1, 2, and 3 results in two different values, -4 and 2. Option C is not stateless, since a class or instance variable i is modified each time the accumulator runs. That leaves us with Option B, which is the correct answer since it is both stateless and associative. Even though it ignores the input parameters, it meets the qualifications for performing a reduction.","B. The code does not compile because Callable must define a call() method, not a run() method, so Option B is the correct answer. If the code was fixed to use the correct method name, then it would complete without issue, printing Done! at runtime, and Option A would be the correct answer.","C. Part of synchronizing access to a variable is ensuring that read/write operations are atomic, or happen without interruption. For example, an increment operation requires reading a value and then immediately writing it. If any thread interrupts this process, then data could be lost. In this regard, Option C shows proper synchronized access. Thread 2 reads a value and then writes it without interruption. Thread 1 then reads the new value and writes it. The rest of the answers are incorrect because one thread writes data to the variable in-between another thread reading and writing to the same variable. Because a thread is writing data to a variable that has already been written to by another thread, it may set invalid data. For example, two increment operations running at the same time could result in one of the increment operations being lost.","D. The code compiles and runs without issue. The two methods hare() and tortoise() are nearly identical, with one calling invokeAll() and the other calling invokeAny(). The key is to know that both methods operate synchronously, waiting for a result from one or more tasks. Calling the invokeAll() method causes the current thread to wait until all tasks are finished. Since each task is one second long and they are being executed in parallel, the hare() method will take about one second to complete. The invokeAny() method will cause the current thread to wait until at least one task is complete. Although the result of the first finished thread is often returned, it is not guaranteed. Since each task takes one second to complete, though, the shortest amount of time this method will return is after one second. In this regard, the tortoise() method will also take about one second to complete. Since both methods take about the same amount of time, either may finish first, causing the output to vary at runtime and making Option D the correct answer. Note that after this program prints the two strings, it does not terminate, since the ExecutorService is not shut down.","B. ConcurrentSkipListMap implements the SortedMap interface, in which the keys are kept sorted, making Option B the correct answer. While the other answers define ordered data structures, none are guaranteed to be sorted. Remember, if you see SkipList as part of a concurrent class name, it means it is sorted in some way, such as a sorted set or map.","D. The synchronized block used in the getQuestion() method requires an object to synchronize on. Without it, the code does not compile, and Option D is the correct answer. What if the command was fixed to synchronize on the current object, such as using synchronized(this)? Each task would obtain a lock for its respective object, then wait a couple of seconds before requesting the lock for the other object. Since the locks are already held, both wait indefinitely, resulting in a deadlock. In this scenario, Option A would be the correct answer since a deadlock is the most likely result. We say most likely because even with corrected code, a deadlock is not guaranteed. It is possible, albeit very unlikely, for the JVM to wait five seconds before starting the second task, allowing enough time for the first task to finish and avoiding the deadlock completely.","B. The ScheduledExecutorService does not include a scheduleAtFixedDelay() method, so Option A is incorrect. The scheduleAtFixedRate() method creates a new task for the associated action at a set time interval, even if previous tasks for the same action are still active. In this manner, it is possible multiple threads working on the same action could be executing at the same time, making Option B the correct answer. On the other hand, scheduleWithFixedDelay() waits until each task is completed before scheduling the next task, guaranteeing at most one thread working on the action is active in the thread pool.","D. The application compiles, so Option B is incorrect. The stroke variable is thread-safe in the sense that no write is lost since all writes are wrapped in a synchronized method, making Option C incorrect. Even though the method is thread-safe, the value of stroke is read while the threads may still be executing. The result is it may output 0, 1000, or anything in-between, making Option D the correct answer. If the ExecutorService method awaitTermination() is called before the value of stroke is printed and enough time elapses, then the result would be 1000, and Option A would be the correct answer.","B. A race condition is an undesirable result when two tasks that should be completed sequentially are completed at the same time. The result is often corruption of data in some way. If two threads are both modifying the same int variable and there is no synchronization, then a race condition can occur with one of the writes being lost. For this reason, Option B is the correct answer. Option A is the description of resource starvation. Options C and D are describing livelock and deadlock, respectively.","A. The code compiles, so Option C is incorrect. The application attempts to count the elements of the sheep array, recursively. For example, the first two elements are totaled by one thread and added to the sum of the remainder of the elements in the array, which is calculated by another thread. Unfortunately, the class contains a bug. The count value is not marked static and not shared by all of the CountSheep subtasks. The value of count printed in the main() menu comes from the first CountSheep instance, which does not modify the count variable. The application prints 0, and Option A is the correct answer. If count was marked static, then the application would sum the elements correctly, printing 10, and Option B would be the correct answer.","D. First off, certain stream operations, such as limit() or skip(), force a parallel stream to behave it a serial manner, so Option A is incorrect. Option B is also incorrect. Although some operations could take less time to execute, there is no guarantee any operation will actually be faster. For example, the JVM may only allocate a single thread to a parallel stream. In other words, parallel streams may improve performance but do not guarantee it. Option C is incorrect because parallel stream operations are not synchronized. It is up to the developer to provide synchronization or use a concurrent collection if required. Finally, Option D is the correct answer. The BaseStream interface, which all streams inherit, includes a parallel() method. Of course, the results of an operation may change in the presence of a parallel stream, such as when a stateful lambda expression is used, but they all can be made parallel.","A. The code compiles and runs without issue. The JVM will fall back to a single-threaded process if all of the conditions for performing the parallel reduction are not met. The stream used in the main() method is not parallel, but the groupingbyConcurrent() method can still be applied without throwing an exception at runtime. Although performance will suffer from not using a parallel stream, the application will still process the results correctly. Since the process groups the data by year, Option A is the correct answer.",'A. The code compiles and runs without issue. The three-argument reduce() method returns a generic type, while the one-argument reduce() method returns an Optional. The concat1() method is passed an identity "a", which it applies to each element, resulting in the reduction to aCataHat. The lambda expression in the concat2() method reverses the order of its inputs, leading to a value of HatCat. Therefore, Option A is the correct answer.',"A. The code compiles without issue, so Options B and C are incorrect. The f1 declaration uses the version of submit() in ExecutorService, which takes a Runnable and returns a Future<?>. The call f1.get() waits until the task is finished and always returns null, since Runnable expressions have a void return type. The f2 declaration uses an overloaded version of submit(), which takes a Callable expression and returns a generic Future object. Since the double value can be autoboxed to a Double object, the line compiles without issue with f2.get() returning 3.14159. For these reasons, Option A is the correct answer. Option D is incorrect because no exception is expected to be thrown at runtime.","C. The class compiles without issue, making Options A and D incorrect. The class attempts to create a synchronized version of a List<Integer>. The size() and addValue() help synchronize the read/write operations. Unfortunately, the getValue() method is not synchronized so the class is not thread-safe, and Option C is the correct answer. It is possible that one thread could add to the data object while another thread is reading from the object, leading to an unexpected result. Note that the synchronization of the size() method is valid, but since ThreadSafeList.class is a shared object, this will synchronize all instances of the class to the same object. This could result in a substantial performance cost if enough threads are creating ThreadSafeList objects.","D. The post-decrement operator (\u2013\u2013) decrements a value but returns the original value. It is equivalent to the atomic getAndDecrement() method. The pre-increment operator (++) increments a value and then returns the new value. It is equivalent to the incrementAndGet() atomic operation. For these reasons, Option D is the correct answer.","B. When a CyclicBarrier goes over its limit, the barrier count is reset to zero. The application defines a CyclicBarrier with a barrier limit of 5 threads. The application then submits 12 tasks to a cached executor service. In this scenario, a cached thread executor will use between 5 and 12 threads, reusing existing threads as they become available. In this manner, there is no worry about running out of available threads. The barrier will then trigger twice, printing five 1s for each of the sets of threads, for a total of ten 1s. For this reason, Option B is the correct answer. The application then hangs indefinitely, as discussed in the next question.","D. The application does not terminate successfully nor produce an exception at runtime, making Options A and B incorrect. It hangs at runtime because the CyclicBarrier limit is five, while the number of tasks submitted and awaiting activation is 12. This means that 2 of the tasks will be left over, stuck in a deadlocked state waiting for the barrier limit to be reached but with no more tasks available to trigger it. For this reason, Option D is the correct answer. If the number of tasks was a multiple of the barrier limit, such as 10 instead of 12, then the application will still hang because the ExecutorService is never shut down. The isShutdown() in the application finally block does not trigger a shutdown. Remember that it is important to shut down an ExecutorService after you are finished with it, else it can prevent a program from terminating. In this case, Option C would be the correct answer.","C. The code does not compile because the blocking methods offerLast() and pollFirst() each throw a checked InterruptedException that are not handled by the lambda expressions, so Option C is the correct answer. If the lambda expressions were wrapped with try-catch blocks, then the process would first add all items to the queue, then remove them all of them, resulting in an output of 0. In this case, Option A would be the correct answer. Even though the tasks are completed in parallel, each stream does not terminate until all tasks are done. Note that 10 seconds is more than enough time under normal circumstances to add/remove elements from the queue.","A. First of all, the for loops using copy1 and copy4 both throw ConcurrentModificationException at runtime since neither allows modification while they are being iterated upon. Next, CopyOnWriteArrayList makes a copy of the array every time it is modified, preserving the original list of values the iterator is using, even as the array is modified. For this reason, the for loop using copy2 completes without throwing an exception or creating an infinite loop. Finally, the ConcurrentLinkedDeque used in copy3 completes without producing an exception or infinite loop. The Concurrent collections order read/write access such that access to the class is consistent across all threads and processes, even iterators. Because the values are inserted at the head of the queue using push() and the underlying data structure is ordered, the new values will not be iterated upon and the loop finishes. Since none of the for statements produce an infinite loop at runtime, Option A is the correct answer. If push() had been used instead of offer() in the third loop, with new values being inserted at the tail of the queue instead of at the head, then the for loop would have entered an infinite loop, and Option B would be the correct answer.","B. Options A, C, and D are the precise requirements for Java to perform a concurrent reduction using the collect() method, which takes a Collector argument. Recall from your studies that a Collector is considered concurrent and unordered if it has the Collector.Characteristics enum values CONCURRENT and UNORDERED, respectively. Option B is the correct answer because elements of a stream are not required to implement Comparable in order to perform a parallel reduction.","D. The class compiles and runs without issue, making Options A and B incorrect. The purpose of the fork/join framework is to use parallel processing to complete subtasks across multiple threads concurrently. Unfortunately, calling the compute() method inside of an existing compute() does not spawn a new thread. The result is that this task is completed using a single thread, despite a pool of threads being available. For this reason, Option D is the correct answer. In order to properly implement the fork/join framework, the compute() method would need to be rewritten. The f1.compute() call should be replaced with f1.fork() to spawn a separate task, followed by f2.compute() to process the data on the current thread, and ending in f1.join() to retrieve the results of the first task completed while f2.compute() was being processed. If the code was rewritten as described, then Option C would be the correct answer.","D. The shutdown() method prevents new tasks from being added but allows existing tasks to finish. In addition to preventing new tasks from being added, the shutdownNow() method also attempts to stop all running tasks. Neither of these methods guarantee any task will be stopped, making Option D the correct answer. Option C is incorrect because there is no halt() method in ExecutorService.","B. First off, the class uses a synchronized list, which is thread-safe and allows modification from multiple threads, making Option D incorrect. The process generates a list of numbers from 1 to 5 and sends them into a parallel stream where the map() is applied, possibly out of order. This results in elements being written to db in a random order. The stream then applies the forEachOrdered() method to its elements, which will force the parallel stream into a single-threaded state. At runtime, line p1 will print the results in order every time as 12345. On the other hand, since the elements were added to db in a random order, the output of line p2 is random and cannot be predicted ahead of time. Since the results may sometimes be the same, Option B is the correct answer. Part of the reason that the results are indeterminate is that the question uses a stateful lambda expression, which based on your studies should be avoided in practice!","C. The program compiles and does not throw an exception at runtime, making Options B and D incorrect. The class attempts to add and remove values from a single cookie variable in a thread-safe manner but fails to do so because the methods deposit() and withdrawal() synchronize on different objects. The instance method deposit() synchronizes on the bank object, while the static method withdrawal() synchronizes on the static Bank.class object. Even though method calls of the same type are protected, calls across the two different methods are not. Since the compound assignment operators (+=) and (-=) are not thread-safe, it is possible for one call to modify the value of cookies while the other is already operating on it, resulting in a loss of information. For this reason, the output cannot be predicted, and Option C is the correct answer. If the two sets of calls were properly synchronized on the same object, then the cookies variable would be protected from concurrent modifications, and Option A would be the correct answer.","A. The code attempts to search for a matching element in an array recursively. While it does not contain any compilation problems, it does contain an error. Despite creating Thread instances, it is not a multi-threaded program. Calling run() on a Thread runs the process as part of the current thread. To be a multi-threaded execution, it would need to instead call the start() method. For this reason, the code completes synchronously, waiting for each method call to return before moving on to the next and printing true at the end of the execution, making Option A the correct answer. On the other hand, if start() had been used, then the application would be multi-threaded but then the result may not be ready by the time the println() method is called, resulting in a value that cannot be predicted ahead of time. In this case, Option D would be the correct answer.","C. Line 13 does not compile because the execute() method has a return type of void, not Future. Line 15 does not compile because scheduleAtFixedRate() requires four arguments that include an initial delay and period value. For these two reasons, Option C is the correct answer. "],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"Which of the following methods is not available on an ExecutorService instance?",code:null,answers:["execute(Callable)","execute(Runnable)","submit(Callable)","submit(Runnable)"]},{title:"Which statements about executing the following TicketTaker application multiple times are true?",code:'<code>package performance;</code>\n<code>import java.util.concurrent.atomic.*;</code>\n<code>import java.util.stream.*;</code>\n<code>public class TicketTaker {</code>\n<code>   long ticketsSold;</code>\n<code>   final AtomicInteger ticketsTaken;</code>\n<code>   public TicketTaker() {</code>\n<code>      ticketsSold = 0;</code>\n<code>      ticketsTaken = new AtomicInteger(0);</code>\n<code>   }</code>\n<code>   public void performJob() {</code>\n<code>      IntStream.iterate(1, p -&gt; p+1)</code>\n<code>         .parallel()</code>\n<code>         .limit(10)</code>\n<code>         .forEach(i -&gt; ticketsTaken.getAndIncrement());</code>\n<code>      IntStream.iterate(1, q -&gt; q+1)</code>\n<code>         .limit(5)</code>\n<code>         .parallel()</code>\n<code>         .forEach(i -&gt; ++ticketsSold);</code>\n<code>      System.out.print(ticketsTaken+" "+ticketsSold);</code>\n<code>   }</code>\n<code>   public static void main(String[] matinee) {</code>\n<code>      new TicketTaker().performJob();</code>\n<code>   }</code>\n<code>}</code>',answers:["I only","I and II","I, II, and III","None of the above"],ol:["The class compiles and runs without throwing an exception.","The first number printed is consistently 10.","The second number printed is consistently 5."]},{title:"Which of the following is a recommended way to define an asynchronous task?",code:null,answers:["Create a Callable expression and pass it to an instance of Executors.","Create a class that extends Thread and overrides the start() method.","Create a Runnable expression and pass it to a Thread constructor.","All of the above"]},{title:"Let\u2019s say you needed a thread executor to create tasks for a CyclicBarrier that has a barrier limit of five threads. Which static method in ExecutorService should you use to obtain it?",code:null,answers:["newSingleThreadExecutor()","newSingle ThreadScheduledExecutor()","newCachedThreadPool()","None of these would work."]},{title:"Given the original array, how many of the following for statements result in an exception at runtime, assuming each is executed independently?",code:"<code>List&lt;Integer&gt; original = new ArrayList&lt;&gt;(Arrays.asList(1,2,3,4,5));</code>\n<code>&nbsp;</code>\n<code>List&lt;Integer&gt; copy1 = new CopyOnWriteArrayList&lt;&gt;(original);</code>\n<code>for(Integer w : copy1)</code>\n<code>   copy1.remove(w);</code>\n<code>&nbsp;</code>\n<code>List&lt;Integer&gt; copy2 = Collections.synchronizedList(original);</code>\n<code>for(Integer w : copy2)</code>\n<code>   copy2.remove(w);</code>\n<code>&nbsp;</code>\n<code>List&lt;Integer&gt; copy3 = new ArrayList&lt;&gt;(original);</code>\n<code>for(Integer w : copy3)</code>\n<code>   copy3.remove(w);</code>\n<code>&nbsp;</code>\n<code>Queue&lt;Integer&gt; copy4 = new ConcurrentLinkedQueue&lt;&gt;(original);</code>\n<code>for(Integer w : copy4)</code>\n<code>   copy4.remove(w);</code>",answers:["Zero","One","Two","Three"]},{title:"Fill in the blanks: __________ is a special case of __________, in which two or more active threads try to acquire the same set of locks and are repeatedly unsuccessful.",code:null,answers:["Deadlock, livelock","Deadlock, resource starvation","Livelock, resource starvation","Resource starvation, race conditions"]},{title:"What is the output of the following application?",code:'<code>1:  package office;</code>\n<code>2:  import java.util.concurrent.*;</code>\n<code>3:  public class TpsReport {</code>\n<code>4:     public void submitReports() {</code>\n<code>5:        ExecutorService service = Executors.newCachedThreadPool();</code>\n<code>6:        Future bosses = service.submit(() -&gt; System.out.print(""));</code>\n<code>7:        service.shutdown();</code>\n<code>8:        System.out.print(bosses.get());</code>\n<code>9:     }</code>\n<code>10:    public static void main(String[] memo) {</code>\n<code>11:       new TpsReport().submitReports();</code>\n<code>12:    }</code>\n<code>13: }</code>',answers:["null","The code does not compile.","Line 7 throws an exception at runtime.","Line 8 throws an exception at runtime."]},{title:"Which of the following static methods does not exist in the Executors class?",code:null,answers:["newFixedScheduledThreadPool()","newFixedThreadPool()","newSingleThreadExecutor()","newSingle ThreadScheduledExecutor()"]},{title:"How many times does the following application print Ready at runtime?",code:'<code>package parade;</code>\n<code>import java.util.concurrent.*;</code>\n<code>public class CartoonCat {</code>\n<code>   private void await(CyclicBarrier c) {</code>\n<code>      try {</code>\n<code>         c.await();</code>\n<code>      } catch (Exception e) {}</code>\n<code>   }</code>\n<code>   public void march(CyclicBarrier c) {</code>\n<code>      ExecutorService s = Executors.newSingleThreadExecutor();</code>\n<code>      for(int i=0; i&lt;12; i++)</code>\n<code>         s.execute(() -&gt; await(c));</code>\n<code>      s.shutdown();</code>\n<code>   }</code>\n<code><span epub:type="pagebreak" id="Page_341"></span>   public static void main(String... strings) {</code>\n<code>      new CartoonCat().march(new CyclicBarrier(4,</code>\n<code>            () -&gt; System.out.println("Ready")));</code>\n<code>   }</code>\n<code>}</code>',answers:["Zero","One","Three","The code does not compile."]},{title:"Which thread-safe class would you use to add elements to the front and back of an ordered data structure and includes methods for waiting a specified amount of time to do so?",code:null,answers:["BlockingDeque","ConcurrentLinkedDeque","ConcurrentSkipListSet","LinkedBlockingDeque"]},{title:"Three of the four methods below always produce the same result whether they are executed on a serial or parallel ordered stream. Which one does not?",code:null,answers:["findAny()","findFirst()","limit()","skip()"]},{title:"What is the result of executing the following application multiple times?",code:"<code>package bears;</code>\n<code>import java.util.*;</code>\n<code>public class Bounce {</code>\n<code>   public static void main(String... legend) {</code>\n<code>      Arrays.asList(1,2,3,4).stream()</code>\n<code>         .forEach(System.out::println);</code>\n<code>      Arrays.asList(1,2,3,4).parallel()</code>\n<code>         .forEachOrdered(System.out::println);</code>\n<code>   }</code>\n<code>}</code>",answers:["Only the first array is printed in the same order every time.","Only the second array is printed in the same order every time.","Both arrays are printed in the same order every time.","None of the above"]},{title:"Fill in the blanks: In the fork/join framework, using the __________ class requires overriding an abstract compute() method containing a generic return type, while using the __________ class requires overriding an abstract compute() method containing a void return type.",code:null,answers:["ForkJoinTask, RecursiveAction","RecursiveAction, RecursiveTask","RecursiveTask, ForkJoinTask","RecursiveTask, RecursiveAction"]},{title:"Given the following code snippet, which lambda expression is the best choice for the accumulator, based on the rules for applying a parallel reduction?",code:"<code>public class GoodAccumulator {</code>\n<code>   int i;</code>\n<code>   public void test() {</code>\n<code>      BiFunction&lt;Integer,Integer,Integer&gt; accumulator = _________________;</code>\n<code>      System.out.print(Arrays.asList(1,2,3,4,5)</code>\n<code>         .parallelStream()</code>\n<code>         .reduce(0,accumulator,(s1, s2) -&gt; s1 + s2));</code>\n<code>   }</code>\n<code>}</code>",answers:["(a,b) -> (a-b)","(a,b) -> 5","(a,b) -> i++","None of the above are appropriate."]},{title:"What is the output of the following code snippet?",code:'<code>Callable c = new Callable() {</code>\n<code>   public Object run() {return 10;}</code>\n<code>};</code>\n<code>ExecutorService s = Executors.newScheduledThreadPool(1);</code>\n<code>for(int i=0; i&lt;10; i++) {</code>\n<code>   Future f = s.submit(c);</code>\n<code>   f.get();</code>\n<code>}</code>\n<code>s.shutdown();</code>\n<code>System.out.print("Done!");</code>',answers:["Done!","The code does not compile.","The code hangs indefinitely at runtime.","The code throws an exception at runtime."]},{title:"The following diagrams represent the order of read/write operations of two threads sharing a common variable. Each thread first reads the value of the variable from memory and then writes a new value of the variable back to memory. Which diagram demonstrates proper synchronization?",code:null,answers:["1","2","3","4"]},{title:"What is the output of the following application?",code:'<code>package story;</code>\n<code>import java.util.*;</code>\n<code>import java.util.concurrent.*;</code>\n<code>public class Race {</code>\n<code>   static ExecutorService service = Executors.newFixedThreadPool(8);</code>\n<code>   public static int sleep() {</code>\n<code>      try {</code>\n<code>         Thread.sleep(1000);</code>\n<code>      } catch (Exception e) {}</code>\n<code>      return 1;</code>\n<code>   }</code>\n<code><span epub:type="pagebreak" id="Page_344"></span>   public static void hare() {</code>\n<code>      try {</code>\n<code>         Callable c = () -&gt; sleep();</code>\n<code>         final Collection&lt;Callable&lt;Integer&gt;&gt; r = Arrays.asList(c,c,c);</code>\n<code>         List&lt;Future&lt;Integer&gt;&gt; results = service.invokeAll(r);</code>\n<code>         System.out.println("Hare won the race!");</code>\n<code>      } catch (Exception e) {e.printStackTrace();}</code>\n<code>   }</code>\n<code>   public static void tortoise() {</code>\n<code>      try {</code>\n<code>         Callable c = () -&gt; sleep();</code>\n<code>         final Collection&lt;Callable&lt;Integer&gt;&gt; r = Arrays.asList(c,c,c);</code>\n<code>         Integer result = service.invokeAny(r);</code>\n<code>         System.out.println("Tortoise won the race!");</code>\n<code>      } catch (Exception e) {e.printStackTrace();}</code>\n<code>   }</code>\n<code>   public static void main(String[] p) throws Exception {</code>\n<code>      service.execute(() -&gt; hare());</code>\n<code>      service.execute(() -&gt; tortoise());</code>\n<code>   }</code>\n<code>}</code>',answers:["Hare won the race! is printed first.","Tortoise won the race! is printed first.","The code does not compile.","The result is unknown until runtime."]},{title:"Which of the following concurrent collections is sorted?",code:null,answers:["ConcurrentLinkedQueue","ConcurrentSkipListMap","CopyOnWriteArrayList","LinkedBlockingQueue"]},{title:"What is the most likely result of executing the following application?",code:'<code>package unknown;</code>\n<code>import java.util.concurrent.*;</code>\n<code>public class Riddle {</code>\n<code>   public void sleep() {</code>\n<code>      try {</code>\n<code>         Thread.sleep(5000);</code>\n<code>      } catch (Exception e) {}</code>\n<code>   }</code>\n<code><span epub:type="pagebreak" id="Page_345"></span>   public String getQuestion(Riddle r) {</code>\n<code>      synchronized {</code>\n<code>         sleep();</code>\n<code>         if(r != null) r.getAnswer(null);</code>\n<code>         return "How many programmers does it take "</code>\n<code>               + "to change a light bulb?";</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public synchronized String getAnswer(Riddle r) {</code>\n<code>      sleep();</code>\n<code>      if(r != null) r.getAnswer(null);</code>\n<code>      return "None, that\'s a hardware problem";</code>\n<code>   }</code>\n<code>&nbsp;</code>\n<code>   public static void main(String... ununused) {</code>\n<code>      final Riddle r1 = new Riddle();</code>\n<code>      final Riddle r2 = new Riddle();</code>\n<code>      ExecutorService s = Executors.newFixedThreadPool(2);</code>\n<code>      s.submit(() -&gt; r1.getQuestion(r2));</code>\n<code>      s.execute(() -&gt; r2.getAnswer(r1));</code>\n<code>      s.shutdown();</code>\n<code>   }</code>\n<code>}</code>',answers:["A deadlock is produced at runtime.","A livelock is produced at runtime.","The application completes successfully.","The code does not compile."]},{title:"Which ScheduledExecutorService method can result in the same action being executed by two threads at the same time?",code:null,answers:["scheduleAtFixedDelay()","scheduleAtFixedRate()","scheduleWithFixedDelay()","There is no such method in ScheduledExecutorService."]},{title:"What is the output of the following application?",code:'<code>package olympics;</code>\n<code>import java.util.concurrent.*;</code>\n<code>public class Athlete {</code>\n<code>   int stroke = 0;</code>\n<code>   public synchronized void swimming() {</code>\n<code>      stroke++;</code>\n<code>   }</code>\n<code><span epub:type="pagebreak" id="Page_346"></span>   public static void main(String... laps) {</code>\n<code>      ExecutorService s = Executors.newFixedThreadPool(10);</code>\n<code>      Athlete a = new Athlete();</code>\n<code>      for(int i=0; i&lt;1000; i++) {</code>\n<code>         s.execute(() -&gt; a.swimming());</code>\n<code>      }</code>\n<code>      s.shutdown();</code>\n<code>      System.out.print(a.stroke);</code>\n<code>   }</code>\n<code>}</code>',answers:["1000","The code does not compile.","The result is unknown until runtime because stroke is not accessed in a thread-safe manner and a write may be lost.","The result is unknown until runtime for some other reason."]},{title:"Which of the following is most likely to be caused by a race condition?",code:null,answers:["A thread perpetually denied access to a resource","An int variable incorrectly reporting the number of times an operation was performed","Two threads actively trying to restart a blocked process that is guaranteed to always end the same way","Two threads endlessly waiting on each other to release shared locks"]},{title:"What is the output of the following application?",code:'<code>package farm;</code>\n<code>import java.util.concurrent.*;</code>\n<code>public class CountSheep extends RecursiveAction {</code>\n<code>   static int[] sheep = new int[] {1,2,3,4};</code>\n<code>   final int start;</code>\n<code>   final int end;</code>\n<code>   int count = 0;</code>\n<code>   public CountSheep(int start, int end) {</code>\n<code>      this.start = start;</code>\n<code>      this.end = end;</code>\n<code>   }</code>\n<code>   public void compute() {</code>\n<code>      if(end-start&lt;2) {</code>\n<code>         count+=sheep[start];</code>\n<code>         return;</code>\n<code>      } else {</code>\n<code><span epub:type="pagebreak" id="Page_347"></span>         int middle = start + (end-start)/2;</code>\n<code>         invokeAll(new CountSheep(start,middle),</code>\n<code>               new CountSheep(middle,end));</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] night) {</code>\n<code>      ForkJoinPool pool = new ForkJoinPool();</code>\n<code>      CountSheep action = new CountSheep(0,sheep.length);</code>\n<code>      pool.invoke(action);</code>\n<code>      pool.shutdown();</code>\n<code>      System.out.print(action.count);</code>\n<code>   }</code>\n<code>}</code>',answers:["0","10","The code does not compile.","None of the above."]},{title:"Which statement about parallel streams is correct?",code:null,answers:["A parallel stream always executes all stream operations faster than a serial stream.","A parallel stream always executes certain stream operations faster than a serial stream.","A parallel stream synchronizes its operations so that they are atomic.","All streams can be converted to a parallel stream."]},{title:"What is a possible output of the following application?",code:'<code>package salvage;</code>\n<code>import java.util.*;</code>\n<code>import java.util.concurrent.*;</code>\n<code>import java.util.stream.*;</code>\n<code>public class Car {</code>\n<code>   private String model;</code>\n<code>   private int year;</code>\n<code>   public Car(String name, int year) {</code>\n<code>      this.model = name; this.year = year;</code>\n<code>   }</code>\n<code>   public int getYear() {return year;}</code>\n<code>   @Override public String toString() {return model;}</code>\n<code>   public static void main(String... make) {</code>\n<code>      List&lt;Car&gt; cars = new ArrayList&lt;&gt;();</code>\n<code><span epub:type="pagebreak" id="Page_348"></span>      cars.add(new Car("Mustang",1967));</code>\n<code>      cars.add(new Car("Thunderbird",1967));</code>\n<code>      cars.add(new Car("Escort",1975));</code>\n<code>      ConcurrentMap&lt;Integer, List&lt;Car&gt;&gt; map = cars</code>\n<code>         .stream()</code>\n<code>         .collect(Collectors.groupingByConcurrent(Car::getYear));</code>\n<code>      System.out.print(map);</code>\n<code>   }</code>\n<code>}</code>',answers:["{1975=[Escort], 1967=[Thunderbird, Mustang]}","{Escort=[1975], Thunderbird=[1967], Mustang=[1967]}","The code does not compile.","The application throws an exception at runtime because the stream is not parallel."]},{title:"What is the output of the following application?",code:'<code>package exercise;</code>\n<code>import java.util.*;</code>\n<code>public class Concat {</code>\n<code>   public String concat1(List&lt;String&gt; values) {</code>\n<code>      return values.parallelStream()</code>\n<code>            .reduce("a",</code>\n<code>                  (x,y)-&gt;x+y,</code>\n<code>                  String::concat);</code>\n<code>   }</code>\n<code>   public String concat2(List&lt;String&gt; values) {</code>\n<code>      return values.parallelStream()</code>\n<code>            .reduce((w,z)-&gt;z+w).get();</code>\n<code>   }</code>\n<code>   public static void main(String... questions) {</code>\n<code>      Concat c = new Concat();</code>\n<code>      List&lt;String&gt; list = Arrays.asList("Cat","Hat");</code>\n<code>      String x = c.concat1(list);</code>\n<code>      String y = c.concat2(list);</code>\n<code>      System.out.print(x+" "+y);</code>\n<code>   }</code>\n<code>}</code>',answers:["aCataHat HatCat","CatHat CatHat","The code does not compile because concat1() returns an Optional.","The code does not compile for a different reason."]},{title:"What is the output of the following application?",code:'<code>package taxes;</code>\n<code>import java.util.concurrent.*;</code>\n<code>public class Accountant {</code>\n<code>   public static void completePaperwork() {</code>\n<code>      System.out.print("[Filing]");</code>\n<code>   }</code>\n<code>   public static double getPi() {</code>\n<code>      return 3.14159;</code>\n<code>   }</code>\n<code>   public static void main(String[] args) throws Exception {</code>\n<code>      ExecutorService x = Executors.newSingleThreadExecutor();</code>\n<code>      Future&lt;?&gt; f1 = x.submit(() \u2010&gt; completePaperwork());</code>\n<code>      Future&lt;Object&gt; f2 = x.submit(() \u2010&gt; getPi());</code>\n<code>      System.out.print(f1.get()+" "+f2.get());</code>\n<code>      x.shutdown();</code>\n<code>   }</code>\n<code>}</code>',answers:["[Filing]null 3.14159","The declaration of f1 does not compile.","The declaration of f2 does not compile.","An exception is thrown at runtime."]},{title:"Which statement about the following class is correct?",code:"<code>package my;</code>\n<code>import java.util.*;</code>\n<code>public class ThreadSafeList {</code>\n<code>   private List&lt;Integer&gt; data = new ArrayList&lt;&gt;();</code>\n<code>   public synchronized void addValue(int value) {</code>\n<code>      data.add(value);</code>\n<code>   }</code>\n<code>   public int getValue(int index) {</code>\n<code>      return data.get(index);</code>\n<code>   }</code>\n<code>   public int size() {</code>\n<code>      synchronized(ThreadSafeList.class) {</code>\n<code>         return data.size();</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>",answers:["The code does not compile because of the size() method.","The code compiles and is thread-safe.","The code compiles and is not thread-safe.","The code does not compile for another reason."]},{title:"Which two method names, when filled into the print2() method, produce the same output as the print1() method? Assume the input arguments for each represent the same non-null numeric value, only accessible by a single thread at a time.",code:"<code>public static void print1(int value) {</code>\n<code>   System.out.println(value--);</code>\n<code>   System.out.println(++value);</code>\n<code>}</code>\n<code>public static void print2(AtomicInteger value) {</code>\n<code>   System.out.println(value.__________);</code>\n<code>   System.out.println(value.__________);</code>\n<code>}</code>",answers:["decrementAndGet() and getAndIncrement()","decrementAndGet() and incrementAndGet()","getAndDecrement() and getAndIncrement()","getAndDecrement() and incrementAndGet()"]},{title:"How many times does the following application print 1 at runtime?",code:'<code>package crew;</code>\n<code>import java.util.concurrent.*;</code>\n<code>import java.util.stream.*;</code>\n<code>public class Boat {</code>\n<code>   private void waitTillFinished(CyclicBarrier c) {</code>\n<code>      try {</code>\n<code>         c.await();</code>\n<code>         System.out.print("1");</code>\n<code>      } catch (Exception e) {}</code>\n<code>   }</code>\n<code>   public void row(ExecutorService service) {</code>\n<code>      final CyclicBarrier cb = new CyclicBarrier(5);</code>\n<code>      IntStream.iterate(1, i-&gt; i+1)</code>\n<code>         .limit(12)</code>\n<code>         .forEach(i -&gt; service.submit(() \u2010&gt; waitTillFinished(cb)));</code>\n<code>   }</code>\n<code>   public static void main(String[] oars) {</code>\n<code>      ExecutorService service = null;</code>\n<code><span epub:type="pagebreak" id="Page_351"></span>      try {</code>\n<code>         service = Executors.newCachedThreadPool();</code>\n<code>         new Boat().row(service);</code>\n<code>      } finally {</code>\n<code>         service.isShutdown();</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["0","10","12","None of the above"]},{title:"Using the Boat class from the previous question, what is the final state of the application?",code:null,answers:["The application produces an exception at runtime.","The application terminates successfully.","The application hangs indefinitely because the ExecutorService is never shut down.","The application produces a deadlock at runtime."]},{title:"What is the expected output of the following application?",code:"<code>package store;</code>\n<code>import java.util.concurrent.*;</code>\n<code>import java.util.stream.*;</code>\n<code>public class Line {</code>\n<code>   static BlockingDeque&lt;Integer&gt; queue = new LinkedBlockingDeque&lt;&gt;();</code>\n<code>   public static void main(String[] participants) throws Exception {</code>\n<code>      IntStream.iterate(1, i -&gt; i+1).limit(5)</code>\n<code>         .parallel()</code>\n<code>         .forEach(s -&gt; queue.offerLast(s,10000,TimeUnit.MILLISECONDS));</code>\n<code>      IntStream.iterate(1, i -&gt; 5).limit(10)</code>\n<code>         .parallel()</code>\n<code>         .forEach(s -&gt; queue.pollFirst(10,TimeUnit.SECONDS));</code>\n<code>      System.out.print(queue.size());</code>\n<code>   }</code>\n<code>}</code>",answers:["0","A number from 0 to 5","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Given the original array, how many of the following for statements result in an infinite loop at runtime, assuming each is executed independently?",code:"<code>List&lt;Integer&gt; original = new ArrayList&lt;&gt;(Arrays.asList(1,2,3));</code>\n<code>&nbsp;</code>\n<code>List&lt;Integer&gt; copy1 = new ArrayList&lt;&gt;(original);</code>\n<code>for(Integer q : copy1)</code>\n<code>   copy1.add(1);</code>\n<code>&nbsp;</code>\n<code>List&lt;Integer&gt; copy2 = new CopyOnWriteArrayList&lt;&gt;(original);</code>\n<code>for(Integer q : copy2)</code>\n<code>   copy2.add(2);</code>\n<code>&nbsp;</code>\n<code>Deque&lt;Integer&gt; copy3 = new ConcurrentLinkedDeque&lt;&gt;(original);</code>\n<code>for(Integer q : copy3)</code>\n<code>   copy3.push(3);</code>\n<code>List&lt;Integer&gt; copy4 = Collections.synchronizedList(original);</code>\n<code>for(Integer q : copy4)</code>\n<code>   copy4.add(4);</code>",answers:["Zero","One","Two","Three"]},{title:"Three of the four following options make up the requirements for performing a parallel reduction with the collect() method, which takes a Collector argument. Choose the one that is not a requirement.",code:null,answers:["The Collector argument is marked concurrent.","The elements of the stream implement the Comparable interface.","The stream is parallel.","The stream or Collector is marked unordered."]},{title:"Which statement about the following application is true?",code:'<code>package math;</code>\n<code>import java.util.concurrent.*;</code>\n<code>public class Fun extends RecursiveTask&lt;Integer&gt; {</code>\n<code>   final int value;</code>\n<code>   public Fun(int value) {</code>\n<code>      this.value = value;</code>\n<code>   }</code>\n<code>   @Override protected Integer compute() {  // w1</code>\n<code>      if(value&lt;1) {</code>\n<code>         return 1;</code>\n<code>      }</code>\n<code><span epub:type="pagebreak" id="Page_353"></span>      final Fun f1 = new Fun(value-1);</code>\n<code>      final Fun f2 = new Fun(value-2);</code>\n<code>      return f1.compute() * f2.compute();</code>\n<code>   }</code>\n<code>   public static void main(String... data) {</code>\n<code>      ForkJoinPool pool = new ForkJoinPool();</code>\n<code>      try {</code>\n<code>         System.out.print(pool.invoke(new Fun(10)));</code>\n<code>      } finally {</code>\n<code>         pool.shutdown();</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["The class does not compile due to line w1.","The class does not compile for another reason.","The application compiles and uses the fork/join framework correctly.","The application compiles but does not use the fork/join framework correctly."]},{title:"Which ExecutorService method guarantees all running tasks are stopped in an orderly fashion?",code:null,answers:["shutdown()","shutdownNow()","halt()","None of the above"]},{title:"Given the following code snippet, what statement about the values printed on lines p1 and p2 is correct?",code:"<code>List&lt;Integer&gt; db = Collections.synchronizedList(new ArrayList&lt;&gt;());</code>\n<code>IntStream.iterate(1, i -&gt; i+1).limit(5)</code>\n<code>   .parallel()</code>\n<code>   .map(i -&gt; {db.add(i); return i;})</code>\n<code>   .forEachOrdered(System.out::print);  // p1</code>\n<code>System.out.println();</code>\n<code>db.forEach(System.out::print);  // p2</code>",answers:["They are always the same.","They are sometimes the same.","They are never the same.","The code will produce a ConcurrentModificationException at runtime."]},{title:"Assuming 10 seconds is enough time for all of the tasks to finish, what is the output of the following application?",code:"<code>package finance;</code>\n<code>import java.util.concurrent.*;</code>\n<code>public class Bank {</code>\n<code>   static int cookies = 0;</code>\n<code>   public synchronized void deposit(int amount) {</code>\n<code>      cookies += amount;</code>\n<code>   }</code>\n<code>   public static synchronized void withdrawal(int amount) {</code>\n<code>      cookies -= amount;</code>\n<code>   }</code>\n<code>   public static void main(String[] amount) throws Exception {</code>\n<code>      ExecutorService teller = Executors.newScheduledThreadPool(50);</code>\n<code>      Bank bank = new Bank();</code>\n<code>      for(int i=0; i&lt;25; i++) {</code>\n<code>         teller.submit(() -&gt; bank.deposit(5));</code>\n<code>         teller.submit(() -&gt; bank.withdrawal(5));</code>\n<code>      }</code>\n<code>      teller.shutdown();</code>\n<code>      teller.awaitTermination(10, TimeUnit.SECONDS);</code>\n<code>      System.out.print(bank.cookies);</code>\n<code>   }</code>\n<code>}</code>",answers:["0","The code does not compile.","The result is unknown until runtime.","An exception is thrown at runtime."]},{title:"What is the output of the following application?",code:'<code>package util;</code>\n<code>import java.util.*;</code>\n<code>public class SearchList&lt;T&gt; {</code>\n<code>   private List&lt;T&gt; data;</code>\n<code>   private boolean foundMatch = false;</code>\n<code>   public SearchList(List&lt;T&gt; list) {</code>\n<code>      this.data = list;</code>\n<code>   }</code>\n<code>   public void exists(T value,int start, int end) {</code>\n<code>      if(end-start&lt;=1) {</code>\n<code><span epub:type="pagebreak" id="Page_355"></span>         foundMatch = foundMatch || value.equals(data.get(start));</code>\n<code>      } else {</code>\n<code>         final int middle = start + (end-start)/2;</code>\n<code>         new Thread(() -&gt; exists(value,start,middle)).run();</code>\n<code>         new Thread(() -&gt; exists(value,middle,end)).run();</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] a) throws Exception {</code>\n<code>      List&lt;Integer&gt; data = Arrays.asList(1,2,3,4,5,6);</code>\n<code>      SearchList&lt;Integer&gt; t = new SearchList&lt;Integer&gt;(data);</code>\n<code>      t.exists(5, 0, data.size());</code>\n<code>      System.out.print(t.foundMatch);</code>\n<code>   }</code>\n<code>}</code>',answers:["true","false","The code does not compile.","The result is unknown until runtime."]},{title:"How many lines of the following code snippet contain compilation errors?",code:"<code>11: ScheduledExecutorService t = Executors</code>\n<code>12:    .newSingleThreadScheduledExecutor();</code>\n<code>13: Future result = t.execute(System.out::println);</code>\n<code>14: t.invokeAll(null);</code>\n<code>15: t.scheduleAtFixedRate(() -&gt; {return;}, 5, TimeUnit.MINUTES);</code>",answers:["None. The code compiles as is.","One","Two","Three"]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t],ol:e.ol}});i[15].imageUrl="./images/image-ocp-ch20-16.png",t.default=i},176:function(e,t,o){"use strict";o.r(t);var n=["C. Connection is an interface for communicating with the database. Driver is tricky because you don\u2019t write code that references it directly. However, you are still required to know it is a JDBC interface. DriverManager is used in JDBC code to get a Connection. However, it is a concrete class rather than an interface. Since Connection and Driver are JDBC interfaces, Option C is correct.","D. Database-specific implementation classes are not in the java.sql package. The implementation classes are in database drivers and have package names that are specific to the database. Therefore, Option D is correct. The Driver interface is in the java.sql package. Note that these classes may or may not exist. You are not required to know the names of any database-specific classes, so the creators of the exam iare free to make up names.","D. All JDBC URLs begin with the protocol jdbc followed by a colon as a delimiter. Option D is the only one that does both of these, making it the answer.","A. The Driver interface is responsible for getting a connection to the database, making Option A the answer. The Connection interface is responsible for communication with the database but not making the initial connection. The Statement interface knows how to run the SQL query, and the ResultSet interface knows what was returned by a SELECT query.","B. The requirement to include a java.sql.Driver file in the driver jar file was introduced in JDBC 4.0. A 3.0 driver is allowed, but not required, to include this file. JDBC 3.0 also requires a call to Class.forName(). As a result, Option B best fills in the blanks.","C. Connection is an interface. Since interfaces do not have constructors, Option D is incorrect. The Connection class doesn\u2019t have a static method to get a Connection either, making Option A incorrect. The Driver class is also an interface without static methods, making Option B incorrect. Option C is the answer because DriverManager is the class used in JDBC to get a Connection.","B. The DriverManager.getConnection() method can be called with just a URL. It is also overloaded to take the URL, username, and password, making Option B correct.","D. CallableStatement and PreparedStatement are interfaces that extend the Statement interface. You don\u2019t need to know that for the exam. You do need to know that a database driver is required to provide the concrete implementation class of Statement rather than the JDK. This makes Option D correct. Note that while Derby is provided with Java, it is in a separate jar from the \u201cmain\u201d JDK.","C. A JDBC URL has three components separated by colons. All three of these URLs meet those criteria. For the data after the component, the database driver specifies the format. Depending on the driver, this might include an IP address and port. Regardless, it needs to include the database name or alias. I and II could both be valid formats because they mention the database box. However, III only has an IP address and port. It does not have a database name or alias. Therefore III is incorrect and Option C correct.","C. The requirement to include a java.sql.Driver file in the driver jar was introduced in JDBC 4.0. A call to Class.forName() was made optional with JDBC 4.0. As a result, Option C best fills in the blanks.","A. Scroll sensitive is a result set type parameter, and updatable is a concurrency mode. The result set type parameter is passed to createStatement() before the concurrency mode. If you request options that the database driver does not support, it downgrades to an option it does support rather than throwing an exception. Statements I and III are correct, making Option A the answer.","B. JDBC 4.0 allows, but does not require, a call to the Class.forName() method. However, since it is in the code, it needs to be correct. This method is expecting a fully qualified class name of a database driver, not the JDBC URL. As a result, the Class.forName() method throws a ClassNotFoundException, and Option B is the answer.","B. There are two ResultSet concurrency modes: CONCUR_READ_ONLY and CONCUR_UPDATABLE. All database drivers support read-only result sets, but not all support updatable ones. Therefore, Option B is correct.","D. This code is missing a call to rs.next(). As a result, rs.getInt(1) throws a SQLException with the message Invalid cursor state \u2013 no current row. Therefore, Option D is the answer.","D. The execute() method is allowed to run any type of SQL statements. The executeUpdate() method is allowed to run any type of the SQL statement that returns a row count rather than a ResultSet. Both DELETE AND UPDATE SQL statements are allowed to be run with either execute() or executeUpdate(). They are not allowed to be run with executeQuery() because they do not return a ResultSet. Therefore, Option D is the answer.","C. Connection is an interface rather than a concrete class. Therefore, it does not have a constructor and line s2 does not compile. As a result, Option C is the answer. Option A would be the answer if the code new Connection() was changed to DriverManager.getConnection().","A. There are three ResultSet type options: TYPE_FORWARD_ONLY, TYPE_SCROLL_INSENSITIVE, and TYPE_SCROLL_SENSITIVE. Only one of these is in the list, making Option A correct.","B. Unlike arrays, JDBC uses one-based indexes. Since num_pages is in the second column, the parameter needs to be 2, ruling out Options A and C. Further, there is not a method named getInteger() on the ResultSet interface, ruling out Option D. Since the proper method is getInt(), Option B is the answer.","D. Option A does not compile because you have to pass a column index or column name to the method. Options B and C compile. However, there are not columns named 0 or 1. Since these column names don\u2019t exist, the code would throw a SQLException at runtime. Option D is correct as it uses the proper column name.","B. The parameters to createStatement() are backward. However, they still compile because both are of type int. This means the code to create the Statement does compile, and Option A is incorrect. Next comes the code to create the ResultSet. While both execute() and executeQuery() can run a SELECT SQL statement, they have different return types. Only executeQuery() can be used in this example. The code does not compile because the execute() method returns a boolean, and Option B is correct. If this was fixed, Option D would be the answer because rs.next() is never called.","D. Since this code opens Statement using a try-with-resources, Statement gets closed automatically at the end of the block. Further, closing a Statement automatically closes a ResultSet created by it, making Option D the answer. Remember that you should close any resources you open in code you write.","C. Option A is incorrect because Driver is an interface while DriverManager is a concrete class. The inverse isn\u2019t true either; DriverManager doesn\u2019t implement Driver. Option B is incorrect because the Connection implementation comes from the database driver jar. Option C is correct. You can turn off auto-commit mode, but it defaults to on. Option D is incorrect because you need to call rs.next() or an equivalent method to point to the first row.","C. The requirement to include a java.sql.Driver file in the META-INF directory was introduced in JDBC 4.0. Older drivers are not required to provide it, making Option B incorrect. A file named jdbc.driver has never been a requirement. Option A is incorrect and is simply here to trick you. All drivers are required to implement the Connection interface, making Option C the answer.","D. First, rs.next() moves the cursor to point to the first row, which contains the number 10. Line q1 moves the cursor to immediately before the first row. This is the same as the position it was in before callingrs.next() in the first place. It is a valid position but isn\u2019t a row of data. Line q2 tries to retrieve the data at this position and throws a SQLException because there isn\u2019t any data, making Option D the answer.","B. This code shows how to properly update a ResultSet. Note that it calls updateRow() so the changes get applied in the database. This allows the SELECT query to see the changes and output 10. Option B is correct. Remember that unlike this code, you should always close a ResultSet when you open it in real code.","C. There is no ResultSet method named prev(). Therefore, the code doesn\u2019t compile, and Option C is correct. If prev() was changed to previous(), the answer would be Option B because updateRow() is never called. Remember that unlike this code, you should always close a ResultSet when you open it in real code.","D. While the code turns off automatic committing, there is a commit() statement after the first two inserts that explicitly commits those to the database. Then automatic commit is turned back on and the third commit is made, making Option D the answer.","A. The count(*) function in SQL always returns a number. In this case, it is the number zero. This means line r1 executes successfully because it positions the cursor at that row. Line r2 also executes successfully and prints 0, which is the value in the row. Since the code runs successfully, Option A is the answer.","B. The cursor starts out at position zero, right before the first row. Line 6 moves the cursor to position five. Line 7 tries to move the cursor ten rows before that position which is row negative five. Since you can\u2019t move back before row zero, the cursor is at row zero instead. Then line 8 moves the cursor forward five positions from row zero, leaving it at row five and making Option B the answer.","C. JDBC 4.0 allows, but does not require, a call to the Class.forName() method. Since the database does not exist, DriverManager.getConnection() throws a SQLException, and Option C is the answer.","D. When running a query on a Statement, Java closes any already open ResultSet objects. This means that rs1 is closed on line 8. Therefore, it throws a SQLException on line 9 because we are trying to call next() on a closed ResultSet, and Option D is correct.","B. The code turns off automatic committing, so the inserts for red and blue are not immediately made. The rollback() statement actually prevents them from being committed. Then automatic commit is turned back on and one insert is made, making Option B the answer.","A. This code correctly obtains a Connection and Statement. It then runs a query, getting back a ResultSet without any rows. The rs.next() call returns false, so nothing is printed, making Option A correct.","B. Since the ResultSet type allows scrolling, the code does not throw a SQLException at runtime. Immediately after getting the ResultSet, the cursor is positioned at the end immediately after Scott\u2019s row. The next two lines try to move forward one row. This has no effect since the cursor is already at the end. Then previous() moves the cursor to point to the last row, which is Scott\u2019s row. The second previous() call moves the cursor up one more row to point to Elena\u2019s row, making Option B the answer.","B. When passing a negative number to absolute(), Java counts from the end instead of the beginning. The last row is Scott\u2019s row, so the first print statement outputs Scott. When passing a positive number to absolute(), Java counts from the beginning, so Jeanne is output. Therefore, Option B is correct.","D. When creating the Statement, the code doesn\u2019t specify a result set type. This means it defaults to TYPE_FORWARD_ONLY. The absolute() method can only be called on scrollable result sets. The code throws a SQLException, making Option D the answer.","B. This code does not compile because the ResultSet options need to be supplied when creating the Statement object rather than when executing the query. Since the code does not compile, Option B is correct.","B. The code turns off automatic committing, so the inserts for red and blue are not immediately made. The rollback() statement says to prevent any changes made from occurring. This gets rid of red and blue. Then automatic commit is turned back on and the one insert for green is made. The final rollback has no effect since the commit was automatically made. Since there was one row added, Option B is the answer.","D. Line 18 doesn\u2019t compile because beforeFirst() has a void return type. Since the code doesn\u2019t compile, it doesn\u2019t print true at all, and Option D is correct. If line 18 called rs.beforeFirst() without trying to print the result, Option B would be the answer. All the other statements are valid and return true.","B. When manually closing database resources, they should be closed in the reverse order from which they were opened. This means that the ResultSet object is closed before the Statement object and the Statement object is closed before the Connection object. This makes Option B the answer."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"How many of Connection, Driver, and DriverManager are JDBC interfaces included with the JDK?",code:null,answers:["None","One","Two","Three"]},{title:"Which is found in the java.sql package?",code:null,answers:["DerbyDriver","MySqlDriver","OracleDriver","None of the above"]},{title:"What must be the first characters of a database URL?",code:null,answers:["db,","db:","jdbc,","jdbc:"]},{title:"Which is responsible for getting a connection to the database?",code:null,answers:["Driver","Connection","Statement","ResultSet"]},{title:"Which most accurately fills in the blanks in this sentence? With JDBC 3.0, the driver is__________ to contain a java.sql.Driver file, and the code getting a Connection is\xa0__________ to call Class.forName().",code:null,answers:["allowed, allowed","allowed, required","required, allowed","required, required"]},{title:"Which of these obtains a Connection?",code:null,answers:["Connection.getConnection(url)","Driver.getConnection(url)","DriverManager.getConnection(url)","new Connection(url)"]},{title:"Which method is overloaded to allow passing a username and password?",code:null,answers:["forName()","getConnection()","getStatement()","None of the above"]},{title:"What is the name of a concrete class that implements Statement and is included in the core\xa0JDK?",code:null,answers:["CallableStatement","PreparedStatement","StatementImpl","None of the above"]},{title:"How many of the following could be valid JDBC URL formats for an imaginary driver named magic and a database named box?",code:null,answers:["None","One","Two","Three"],ol:["jdbc:magic:127.0.0.1:1234/box","jdbc:magic:box","jdbc:magic:@127.0.0.1:1234"]},{title:"Which most accurately fills in the blanks in this sentence? With JDBC 4.0, the driver is__________ to contain a java.sql.Driver file, and the code getting a Connection is\xa0__________ to call Class.forName().",code:null,answers:["allowed, allowed","allowed, required","required, allowed","required, required"]},{title:"Which pair of statements is true when requesting a ResultSet to be both scroll sensitive and updatable?",code:null,answers:["I, III","I, IV","II, III","II, IV"],ol:["The scroll sensitive option is passed as a parameter before the updatable parameter.","The updatable option is passed as a parameter before the scroll sensitive parameter.","If these options are not available, the database driver returns a ResultSet with different options.","If these options are not available, the database driver throws a SQLException."]},{title:"Suppose the blue database exists and we are using a JDBC 4.0 driver. Which is the outcome of this code?",code:'<code>String url = "jdbc:derby:blue";</code>\n<code>Class.forName(url);</code>\n<code>try (Connection conn = DriverManager.getConnection(url);</code>\n<code>   Statement stmt = conn.createStatement();</code>\n<code>   ResultSet rs = stmt.executeQuery("select count(*) from sky")) {</code>\n<code>   System.out.println(rs.getInt(1));</code>\n<code>}</code>',answers:["It runs successfully and prints the number of rows in the sky table.","It throws a ClassNotFoundException.","It throws a SQLException.","It does not compile."]},{title:"Fill in the blanks: There are __________ ResultSet concurrency modes, and drivers are required to support __________.",code:null,answers:["two, both","two, one of them","three, two of them","three, all of them"]},{title:"What is the output when run with a JDBC 4.0 driver if the clowns database exists and contains an empty clowns table?",code:'<code>String url = "jdbc:derby:clowns";</code>\n<code>try (Connection conn = DriverManager.getConnection(url);</code>\n<code>    Statement stmt = conn.createStatement();</code>\n<code>    ResultSet rs = stmt.executeQuery("select count(*) from clowns")) {</code>\n<code>&nbsp;</code>\n<code>    System.out.println(rs.getInt(1));</code>\n<code>}</code>',answers:["0","1","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Consider the three methods execute(), executeQuery(), and executeUpdate(). Fill in the blanks: __________ of these methods is/are allowed to run a DELETE SQL statement while __________ of these methods is/are allowed to run an UPDATE SQL statement.",code:null,answers:["One, one","One, two","Two, one","Two, two"]},{title:"Assuming the clowns database exists and contains one empty table named clowns, what is the output of the following when run using a JDBC 4.0 driver?",code:'<code>import java.sql.*;</code>\n<code>&nbsp;</code>\n<code>public class EmptyTable {</code>\n<code>   public static void main(String[] args) throws SQLException {  // s1</code>\n<code>      String url = "jdbc:derby:clowns";</code>\n<code>      try (Connection conn = new Connection(url);   // s2</code>\n<code>         Statement stmt = conn.createStatement();</code>\n<code>         ResultSet rs = stmt.executeQuery("select * from clowns")) {</code>\n<code>&nbsp;</code>\n<code>         if (rs.next())</code>\n<code>            System.out.println(rs.getString(1));</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["The code terminates successfully without any output.","The code does not compile due to line s1.","The code does not compile due to line s2.","None of the above"]},{title:"Which are valid ResultSet types?",code:null,answers:["II","I and II","II and III","None of the above"],ol:["TYPE_BACKWARD_ONLY","TYPE_FORWARD_ONLY","TYPE_REVERSE_ONLY"]},{title:"Given the table books in the figure and a ResultSet created by running the following SQL statement, which option prints the value 379?",code:"<code>select * from cert where title = 'OCA'</code>",answers:["System.out.println(rs.getInt(1));","System.out.println(rs.getInt(2));","System.out.println(rs.getInteger(1));","System.out.println(rs.getInteger(2));"]},{title:"Given the table books in the previous question and a ResultSet created by running this SQL statement, which option prints OCP?",code:"<code>select title from cert where num_pages &gt; 500</code>",answers:["System.out.println(rs.getString());",'System.out.println(rs.getString("0"));','System.out.println(rs.getString("1"));','System.out.println(rs.getString("title"));']},{title:"Assume the database exists with all referenced table and column names. Which is a true statement when a JDBC 4.0 driver is used?",code:'<code>String url = "jdbc:derby:precipitation";</code>\n<code>try (Connection conn = DriverManager.getConnection(url);</code>\n<code>   Statement stmt = conn.createStatement(</code>\n<code>       ResultSet.CONCUR_READ_ONLY,</code>\n<code>       ResultSet.TYPE_SCROLL_INSENSITIVE);</code>\n<code>   ResultSet rs = stmt.execute(       "select total from precip where type = \'rain\'")) {</code>\n<code>   System.out.println(rs.getString("total"));</code>\n<code>}</code>',answers:["There is a compiler error on the line of code that creates the Statement.","There is a compiler error on the line of code that creates the ResultSet.","This code compiles and runs without error.","This code throws a SQLException at runtime."]},{title:"Which resources have their close() method called when this code runs?",code:'<code>public static void runQuery(Connection conn) throws SQLException{</code>\n<code>   try (Statement stmt = conn.createStatement()) {</code>\n<code>      ResultSet rs = stmt.executeQuery("select * from clowns");</code>\n<code>      rs.next();</code>\n<code>   }</code>\n<code>}</code>',answers:["No close() methods are called.","Only  Statement","Only Statement and Connection","Only Statement and ResultSet"]},{title:"Which statement is true about the JDBC core classes?",code:null,answers:["Driver is an implementation of DriverManager.","A general Connection implementation is included in the JDK.","A Statement automatically starts in auto-commit mode.","A ResultSet automatically starts pointing to the first row of data."]},{title:"Which of the following is required in a database driver implementation?",code:null,answers:["A file named jdbc.driver","A file named java.sql.Driver","At least one implementation of the Connection interface","None of the above"]},{title:"Given that the people table has 10 rows, what is the result of the following when using a driver that supports a scroll sensitive ResultSet?",code:'<code>try (Connection conn = DriverManager.getConnection(url);</code>\n<code>   Statement stmt = conn.createStatement(</code>\n<code>      ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);</code>\n<code>   ResultSet rs = stmt.executeQuery("select count(*) from people")) {</code>\n<code>   rs.next();</code>\n<code>   rs.absolute(0);                    // q1</code>\n<code>   System.out.print(rs.getInt(1));    // q2</code>\n<code>}</code>',answers:["10","The code does not compile.","Line q1 throws a SQLException.","Line q2 throws a SQLException."]},{title:"Given a scrollable updatable ResultSet that contains the following, what does the code snippet output?",code:'<code>rs = stmt.executeQuery("select * from pens");</code>\n<code>rs.afterLast();</code>\n<code>rs.previous();</code>\n<code>rs.updateInt(2, 10);</code>\n<code>rs.updateRow();</code>\n<code>rs = stmt.executeQuery("select * from pens where color = \'red\'");</code>\n<code>while (rs.next())</code>\n<code>   System.out.println(rs.getInt(2));</code>',answers:["0","10","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Given a scrollable updatable ResultSet represented by the image in the previous question, what does the code snippet output?",code:'<code>rs = stmt.executeQuery("select * from pens");</code>\n<code>rs.afterLast();</code>\n<code>while(rs.prev())</code>\n<code>   rs.updateInt(2,0);</code>\n<code>rs = stmt.executeQuery("select * from pens where color = \'black\'");</code>\n<code>while (rs.next())</code>\n<code>   System.out.println(rs.getInt(2));</code>\n<code>&nbsp;</code>',answers:["0","20","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"How many rows are added to the colors table from running the following?",code:"<code>try (Connection conn = DriverManager.getConnection(url);</code>\n<code>   Statement stmt = conn.createStatement()) {</code>\n<code>&nbsp;</code>\n<code>   conn.setAutoCommit(false);</code>\n<code>   stmt.executeUpdate(\"insert into colors values ('red')\");</code>\n<code>   stmt.executeUpdate(\"insert into colors values ('blue')\");</code>\n<code>   conn.commit();</code>\n<code>   conn.setAutoCommit(true);</code>\n<code>   stmt.executeUpdate(\"insert into colors values ('green')\");</code>\n<code>}</code>",answers:["None","One","Two","Three"]},{title:"Which is true if the clowns database exists and contains an empty clowns table?",code:'<code>String url = "jdbc:derby:clowns";</code>\n<code>try (Connection conn = DriverManager.getConnection(url);</code>\n<code>    Statement stmt = conn.createStatement();</code>\n<code>    ResultSet rs = stmt.executeQuery("select count(*) from clowns")) {</code>\n<code>&nbsp;</code>\n<code><span epub:type="pagebreak" id="Page_365"></span>    rs.next();   // r1</code>\n<code>    System.out.println(rs.getInt(1));   // r2</code>\n<code>}</code>',answers:["The code compiles and runs without error.","The code does not compile.","The code compiles but throws an exception at runtime on line r1.","The code compiles but throws an exception at runtime on line r2."]},{title:"Suppose the ResultSet is scrollable and contains 10 rows with the values 1\u201310 respectively. What is the output of the following?",code:"<code>5:  rs.absolute(0);</code>\n<code>6:  rs.relative(5);</code>\n<code>7:  rs.relative(-10);</code>\n<code>8:  rs.relative(5);</code>\n<code>9:  System.out.print(rs.getInt(1));</code>",answers:["4","5","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Suppose the blue database does not exist and we are using a JDBC 4.0 driver. Which is the outcome of this code?",code:'<code>String url = "jdbc:derby:blue";</code>\n<code>try (Connection conn = DriverManager.getConnection(url);</code>\n<code>   Statement stmt = conn.createStatement();</code>\n<code>   ResultSet rs = stmt.executeQuery("select count(*) from sky")) {</code>\n<code>   System.out.println(rs.getInt(1));</code>\n<code>}</code>',answers:["It runs successfully and prints the number of rows in the sky table.","It throws a ClassNotFoundException.","It throws a SQLException.","It does not compile."]},{title:"What is the most likely outcome of this code if the people table is empty?",code:'<code>6:  Statement stmt = conn.createStatement();</code>\n<code>7:  ResultSet rs1 = stmt.executeQuery("select * from people");</code>\n<code>8:  ResultSet rs2 = stmt.executeQuery("select * from people");</code>\n<code>9:  System.out.println(rs1.next() + " " + rs2.next());</code>',answers:["It prints false false.","It prints true false.","It does not terminate.","It throws a SQLException."]},{title:"How many rows are added to the colors table from running the following?",code:"<code>try (Connection conn = DriverManager.getConnection(url);</code>\n<code>   Statement stmt = conn.createStatement()) {</code>\n<code>&nbsp;</code>\n<code>   conn.setAutoCommit(false);</code>\n<code>   stmt.executeUpdate(\"insert into colors values ('red')\");</code>\n<code>   stmt.executeUpdate(\"insert into colors values ('blue')\");</code>\n<code>   conn.rollback();</code>\n<code>   conn.setAutoCommit(true);</code>\n<code>   stmt.executeUpdate(\"insert into colors values ('green')\");</code>\n<code>}</code>",answers:["None","One","Two","Three"]},{title:"Assuming the clowns database exists and contains one empty table named clowns, what is the output of the following when run using a JDBC 4.0 driver?",code:'<code>import java.sql.*;</code>\n<code>&nbsp;</code>\n<code>public class EmptyTable {</code>\n<code>   public static void main (String[] args) throws SQLException {  // s1</code>\n<code>      String url = "jdbc:derby:clowns";</code>\n<code>      try (Connection conn = DriverManager.getConnection(url);   // s2</code>\n<code>         Statement stmt = conn.createStatement();</code>\n<code>         ResultSet rs = stmt.executeQuery("select * from clowns")) {</code>\n<code>&nbsp;</code>\n<code>         if (rs.next())</code>\n<code>            System.out.println(rs.getString(1));</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["The code terminates successfully without any output.","The code does not compile due to line s1.","The code does not compile due to line s2.","None of the above"]},{title:"Given the following code snippet and the table below, what is the output of the following when using a driver that supports a scroll sensitive ResultSet?",code:'<code>try (Connection conn = DriverManager.getConnection(url);</code>\n<code>   Statement stmt = conn.createStatement(</code>\n<code>      ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);</code>\n<code>   ResultSet rs = stmt.executeQuery(       "select * from people order by last_name asc")) {</code>\n<code>&nbsp;</code>\n<code>   rs.afterLast();</code>\n<code>   rs.next();</code>\n<code>   rs.next();</code>\n<code>   rs.previous();</code>\n<code>   rs.previous();</code>\n<code>   System.out.println(rs.getString(1));</code>\n<code>}</code>',answers:["Janeice","Elena","Scott","The code throws a SQLException at runtime."]},{title:"Given the following code snippet and the table in question 34, what is the output of the following when using a driver that supports a scroll sensitive ResultSet?",code:'<code>try (Connection conn = DriverManager.getConnection(url);</code>\n<code>   Statement stmt = conn.createStatement(</code>\n<code>      ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);</code>\n<code><span epub:type="pagebreak" id="Page_367"></span>   ResultSet rs = stmt.executeQuery(      "select * from people order by last_name asc")) {</code>\n<code>&nbsp;</code>\n<code>   rs.absolute(-1);</code>\n<code>   System.out.print(rs.getString(1));</code>\n<code>   System.out.print(" ");</code>\n<code>   rs.absolute(1);</code>\n<code>   System.out.print(rs.getString(1));</code>\n<code>}</code>',answers:["Jeanne Scott","Scott Jeanne","The code compiles, but the output is neither of these.","The code throws a SQLException at runtime."]},{title:"Given the following code snippet and the table in question 34, what is the output of the following?",code:'<code>try (Connection conn = DriverManager.getConnection(url);</code>\n<code>   Statement stmt = conn.createStatement();</code>\n<code>   ResultSet rs = stmt.executeQuery(       "select * from people order by last_name asc")) {</code>\n<code>   rs.next();</code>\n<code>   rs.next();</code>\n<code>   System.out.print(rs.getString(1));</code>\n<code>   System.out.print(" ");</code>\n<code>   rs.absolute(1);</code>\n<code>   System.out.print(rs.getString(1));</code>\n<code>}</code>',answers:["Jeanne Scott","Scott Jeanne","The code compiles, but the output is neither of these.","The code throws a SQLException at runtime."]},{title:"Given that the people table has 10 rows, what is the result of the following when using a driver that supports a scroll sensitive Resultset?",code:'<code>String sql = "select count(*) from people";</code>\n<code>try (Connection conn = DriverManager.getConnection(url);</code>\n<code>   Statement stmt = conn.createStatement();</code>\n<code>   ResultSet rs = stmt.executeQuery(sql,</code>\n<code>      ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY)) {</code>\n<code>   rs.next();</code>\n<code>   rs.absolute(0);                    // q1</code>\n<code>   System.out.print(rs.getInt(1));    // q2</code>\n<code>}</code>',answers:["10","The code does not compile.","Line q1 throws a SQLException.","Line q2 throws a SQLException."]},{title:"How many rows are added to the colors table from running the following?",code:'<code>try (Connection conn = DriverManager.getConnection(url);</code>\n<code>   Statement stmt = conn.createStatement()) {</code>\n<code>   conn.setAutoCommit(false);</code>\n<code>   stmt.executeUpdate("insert into colors values (\'red\')");</code>\n<code>   stmt.executeUpdate("insert into colors values (\'blue\')");</code>\n<code><span epub:type="pagebreak" id="Page_369"></span>   conn.rollback();</code>\n<code>   conn.setAutoCommit(true);</code>\n<code>   stmt.executeUpdate("insert into colors values (\'green\')");</code>\n<code>   conn.rollback();</code>\n<code>}</code>',answers:["None","One","Two","Three"]},{title:"Suppose the ResultSet is scrollable and contains 10 rows. How many times does the following print true?",code:"<code>16:  System.out.println(rs.absolute(-2));</code>\n<code>17:  System.out.println(rs.relative(-1));</code>\n<code>18:  System.out.println(rs.beforeFirst());</code>\n<code>19:  System.out.println(rs.relative(5));</code>",answers:["Two","Three","Four","None of the above"]},{title:"What is the correct order to close database resources?",code:null,answers:["Connection then Statement then ResultSet","ResultSet then Statement then Connection","Statement then Connection then ResultSet","Statement then ResultSet then Connection"]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t],ol:e.ol}});i[17].imageUrl="./images/image-ocp-ch21-18.png",i[24].imageUrl="./images/image-ocp-ch21-25.png",i[33].imageUrl="./images/image-ocp-ch21-34.png",t.default=i},177:function(e,t,o){"use strict";o.r(t);var n=["D. Oracle defines a locale as a geographical, political, or cultural region. Time zones often span multiple locales, so Option D is correct.","C. Currencies vary in presentation by locale. For example, 9,000 and 9.000 both represent nine thousand, depending on the locale. Similarly, for dates, 01-02-1991 and 02-01-1991 represent January 2, 1991, depending on the locale. This makes Option C the answer.","C. The Locale object provides getDefault() and setDefault() methods for working with the default locale, so Option C is correct. There is no get() method declared on Locale.","A. Internationalization means the program is designed so it can be adapted for multiple languages. By extracting the town names, this is exactly what has happened here, making Option A correct. Localization means the program actually supports multiple locales. There\u2019s no mention of multiple locales here, so Option B is incorrect. Similarly, there is no mention of multiple languages, making Option D incorrect. Finally, specialization is not a term relevant to properties, making Option C incorrect.","A. The Properties class is a Map, making III correct. Hashtable and HashMap are concrete classes rather than interfaces, so I and II are incorrect. While a Properties object is a Hashtable, this is not an interface. Since only III is correct, Option A is the answer.","C. Java supports properties file resource bundles and Java class resource bundles. Properties file resource bundles contain String keys and String values. Java class resource bundles contain String keys and any type of classes as values. Since both are valid, Option C is correct.","B. Calling Locale.setDefault() changes the default locale within the program. It does not change any settings on the computer. The next time you run a Java program, it will have the original default locale rather than the one you changed it to.","B. Line 18 prints the value for the property with the key mystery, which is bag. Line 19 prints a space. Line 20 doesn\u2019t find the key more so it prints null. Therefore, it prints bag null, and Option B is correct.","C. There is not a built-in class called JavaResourceBundle, making Options A and B incorrect. The ListResourceBundle class is used to programmatically create a resource bundle. It requires one method to be implemented named getContents(), making Option D incorrect and Option C correct. This method returns a 2D array of key/value pairs.","A. When both a language and country code are present, the language code comes first. The language code is in all lowercase letters and the country code is in all uppercase.","C. Java starts out by looking for a Java file with the most specific match, which is language and country code. Since this is happening at runtime, it is looking for the corresponding file with a .class extension. This matches Option C, making it the answer. If this file was not found, Java would then look for a .properties file with the name, which is Option D. If neither was found, it would continue dropping components of the name, eventually getting to Options A and B in that order.","A. This class correctly creates a Java class resource bundle. It extends ListResourceBundle and creates a 2D array as the property contents. Since count is an int, it is autoboxed into an Integer. In the main() method, it gets the resource bundle without a locale and requests the count key. Since Integer is a Java Object, it calls getObject() to get the value. The value is not incremented each time because the getContents() method is only called once. Therefore, Option A is correct.","A. A Locale can consist of a language only, making Option A correct. It cannot consist of a country code without a language, so Option B is incorrect. Finally, if both a language and country code are present, the language code is first, making Option C incorrect.","A. Java supports properties file resource bundles and Java class resource bundles. Properties file resource bundles require String values, making Option B incorrect. Java class resource bundles allow any type of classes as values. Since the question asks about defining values, it is the .java source code rather than the .class bytecode file, making Option A the answer.","C. At least one matching resource bundle must be available at the time of the call to getBundle(). While the requested key determines which of the resource bundles is used, at least one must exist simply to get the ResourceBundle reference, so Option C is the answer.","D. The Properties class implements Map. While the get() method, inherited from the superclass, is available, it returns an Object. Since Object cannot be cast to String, it does not compile, and Option D is the answer.","D. Java supports properties file resource bundles and Java class resource bundles. Both require String as the key format, so Option D is the answer.","A. Java starts out by looking for a Java file with the most specific match, which is language and country code. Since there is no such matching file, it drops the country code and looks for a match by language code. Java looks for bytecode files before properties files. Therefore, Option A is the answer. If it wasn\u2019t present, Option B would be the next choice. Options C and D would never be considered, as a locale doesn\u2019t just have a country code.","D. There is no get() method on Locale. You need to use a constructor or a predefined Locale constant to obtain a Locale object. Therefore, Option D is the correct answer. Option B is close in that Locale.ITALIAN does reference a Locale object. However, it should not be passed to the nonexistent get() method.","A. This code creates a Map with two elements. Then it copies both key/value pairs to a Properties object. This works because a Properties object is also a Map and therefore has a put() method that takes Object parameters. Finally, the code gets the String property values of both keys and prints hammer nail. Therefore, Option A is correct.","D. The code attempts to create a Java class resource bundle. However, the Type class does not extend ListResourceBundle. It compiles, but throws an exception on line 9 because no resource bundle is actually defined. Therefore, Option D is correct.","D. This code compiles and runs without exception, making Option D the answer. Line 3 uses a predefined Locale constant. Line 5 passes a language and country code for English in Australia. Line 7 incorrectly passes capital letters as a language code. However, Java automatically converts it to lowercase without throwing an exception. The three lines printed by the code are ko, en_US and en.","C. Line 18 prints the value for the property with key mystery, which is bag. Line 19 prints a space. Line 20 doesn\u2019t find the key more so it uses the second parameter ? as the default value. The code prints bag ?, so Option C is correct.","B. The getBundle() method matches Cars_fr_FR.properties since that is the requested locale. The country key is in that properties file directly, so France is used as the value. The engine key is not, so Java looks higher up in the hierarchy and finds it in the language-specific Cars_fr.properties file and uses moteur as the value. Therefore, Option B is correct. Note that the default locale isn\u2019t used.","D. The getBundle() method matches Cars_fr.properties. Since the requested locale of French Canada is not available, it uses the language-specific locale of French. The engine key is in that properties file directly, so moteur is retrieved as the value. However, we have a problem getting the horses key. It is not in the hierarchy of Cars_fr.properties. It is in the English properties file, but Java cannot look at the default locale if it found a match with the requested locale. As a result, the code throws a MissingResourceException, making Option D the answer.","A. The getBundle() method matches Cars_en.properties. Since the requested locale of English Canada is not available, it uses the language-specific locale of English. The engine key is in that properties file directly, so engine is retrieved as the value. The horses key is also in that properties file, so 241 is used as the value, and Option A is the answer.","B. A ListResourceBundle is a Java class that provides key/value pairs. The values can be any Java class type and can be created at runtime, making Options A and C false statements. When you want to provide a language-specific resource bundle, an underscore and the language code are added after the class name. Since Option B does not have an underscore, it is a false statement. Since all three statements are false, Option D is the answer.","D. Since a Locale is passed when requesting the ResourceBundle, that Locale is used first when looking for bundles. Since there isn\u2019t a bundle called Colors_zh_CN.properties, Java goes on to check for the language. Option D provides a match on language. If this was not found, Java would go on to the default locale, eventually matching Option B. Since country is not used without language, Options A and C would not be considered as options.","B. This class correctly creates a Java class resource bundle. It extends ListResourceBundle and creates a 2D array as the property contents. In the main() method, it gets the resource bundle without a locale and requests the count key. Since this is a Java Object, it calls getObject() to get the value and casts it to the correct type. Then the getCount() method is called twice, incrementing each time, making Option B the correct answer. Note that having a mutable object as a property is a bad practice.","D. Line 10 is incorrect. It tries to get a bundle named Type. However, this code is in a package and named keyboard.Type. Therefore, a MissingResourceException is thrown, and Option D is correct.","B. Since no locale is specified, the code tries to find a bundle matching the default locale. While none of the resource bundles match English United States, two do match the language English. The Java class one is used since it is present. Since the Java resource bundle for English doesn\u2019t have a key wheels, we go up to the parent resource bundle. The default Java resource bundle does have the key wheels with the value 4, so Option B is correct.","D. Since no locale is specified, the code tries to find a bundle matching the default locale. Two resource bundles match the language English. The Java class one is used since it is present. However, it does not contain a key color, nor does its parent. Java does not allow looking in a properties file resource bundle once it has matched a Java class resource bundle. Therefore, it throws a MissingResourceBundleException, and Option D is the answer.","B. Since no locale is specified, the code tries to find a bundle matching the default locale. None of the resource bundles match the language, so the default resource bundle is used. The default Java resource bundle is used since it is present and has the key wheels with the value 4. Therefore, Option B is correct.","A. Since a locale is passed when requesting the ResourceBundle, that locale is used first when looking for bundles. Since there isn\u2019t a bundle for that locale, Java checks for the language zh. There still isn\u2019t a match, so Java goes on to check for the default locale. Still no match. Next Java checks the language of the default locale and finally finds a match in Option A. If that match wasn\u2019t found, Java would match on Option B, which is the default bundle. Option C would never be checked since the base name is Red rather than the requested Color.","C. A Properties object implements Map. This makes the get() method available. Properties also defined a getProperty() method. Therefore, both methods can fill in the blank, and Option C is correct.","B. This code compiles and runs without issue. It creates a default Java class resource bundle. Lines 5 through 7 show it has one key and one ArrayList value. Line 9 gets a reference to the resource bundle. Lines 10 through 16 retrieve the ArrayList and add six values to it. Since this is a reference, line 17 gets the same object and prints the size of 6. Therefore, Option B is correct.","B. The class on line p1 should be Properties rather than Property. As written it is incorrect and does not compile, making Option B the answer.","C. ResourceBundle is an abstract class and uses a factory to obtain the right subclass. Since a call to the constructor new ResourceBundle() does not compile, Option C is the answer. If this was fixed, Option A would be the answer because getContents() is only called once.","A. This code sets the default locale to English and then tries to get a resource bundle for container in the pod package. It finds the resource bundle pod.container_en.properties as the most specific match. Both keys are found in this file, so Option A is the answer.","D. Option C is not a valid match for this resource bundle because the base name is Red rather than the requested Colors. Options A and B are not valid matches because they contain uppercase letters for the language code while Java requires lowercase. Since none match, Option D is correct, and the code throws an exception at runtime."],a=function(e,t){var o=function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:t===o}});console.log(e)},i=[{title:"Which is not a locale?",code:null,answers:["Cultural region","Geographical region","Political region","Time zone region"]},{title:"When localizing an application, which type of data varies in presentation depending on locale?",code:null,answers:["Currencies","Dates","Both","Neither"]},{title:"How do you find out the locale of the running program?",code:null,answers:['Locale.get("default")',"Locale.get(Locale.DEFAULT)","Locale.getDefault()","None of the above"]},{title:"If your application has all town names in a single file named strings.properties, what is the most specific process that has been implemented?",code:null,answers:["Internationalization","Localization","Specialization","Translation"]},{title:"Which interfaces does Properties implement?",code:null,answers:["III","I and II","I and III","II and III"],ol:["Hashtable","HashMap","Map"]},{title:"Which filename extension can hold a String property value in a resource bundle?",code:null,answers:[".java",".properties","Both of the above","Neither of the above"]},{title:"How long will the effects of calling Locale.setDefault() be active assuming no other calls to that method are made?",code:null,answers:["Until the end of the method","Until the program exits","Until the next reboot of the computer","None of the above. It persists even past a reboot."]},{title:"Given this properties file used to load the Properties object props and this code snippet, what is the output?",code:'<code>mystery=bag</code>\n<code>type=paper</code>\n<code>18:  System.out.print(props.getProperty("mystery"));</code>\n<code>19:  System.out.print(" ");</code>\n<code>20:  System.out.print(props.getProperty("more"));</code>',answers:["bag","bag null","bag ?","This code throws a runtime exception on line 20."]},{title:"Fill in the blanks to complete the following code for a Java resource bundle.",code:"<code>public class Flights_en extends __________ {</code>\n<code>   protected Object[][] __________() {</code>\n<code>      return new Object[0][0];</code>\n<code>   }</code>\n<code>}</code>",answers:["JavaResourceBundle, getContents","JavaResourceBundle, getProperties","ListResourceBundle, getContents","ListResourceBundle, getProperties"]},{title:"Which of the following shows a valid Locale format for the language Hindi and the country India?",code:null,answers:["hi_IN","HI_in","in_HI","IN_hi"]},{title:"If the key purple is in all four of these files, which file will the following code use for the resource bundle?",code:'<code>Locale.setDefault(new Locale("en", "US"));</code>\n<code>ResourceBundle rb = ResourceBundle.getBundle("Colors");</code>\n<code>rb.getString("purple");</code>',answers:["Colors.class","Colors.properties","Colors_en_US.class","Colors_en_US.properties"]},{title:"What is the output of the following?",code:'<code>package counter;</code>\n<code>import java.util.*;</code>\n<code>&nbsp;</code>\n<code>public class CountResource extends ListResourceBundle {</code>\n<code>   private int count = 0;</code>\n<code>&nbsp;</code>\n<code>   @Override</code>\n<code>   protected Object[][] getContents() {</code>\n<code>      return new Object[][] { { "count", count++ } };</code>\n<code>   }</code>\n<code>   public static void main(String[] args) {</code>\n<code>      ResourceBundle rb = ResourceBundle.getBundle("counter.CountResource");</code>\n<code>      System.out.println(rb.getObject("count") + " " + rb.getObject("count"));</code>\n<code>   }</code>\n<code>}</code>',answers:["0 0","0 1","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which of the following shows a valid Locale format?",code:null,answers:["en","US","US_en","None of the above"]},{title:"Which filename extension can define a LocalDateTime property value in a resource bundle?",code:null,answers:[".java",".properties","Both of the above","Neither of the above"]},{title:"What happens if you run this code with no resource bundles available?",code:'<code>ResourceBundle rb = ResourceBundle.getBundle("ghost.None");</code>',answers:["It creates a resource bundle with no key/value pairs.","It runs without issue because the resource bundle is only searched for when getting the first key.","It throws a MissingResourceException.","None of the above"]},{title:"What is the result of the following?",code:'<code>Map&lt;String, String&gt; map = new TreeMap&lt;&gt;();</code>\n<code>map.put("tool", "hammer");</code>\n<code>map.put("problem", "nail");</code>\n<code>&nbsp;</code>\n<code>Properties props = new Properties();      // p1</code>\n<code>map.forEach((k,v) -&gt; props.put(k,  v));   // p2</code>\n<code>&nbsp;</code>\n<code>String t = props.get("tool");             // p3</code>\n<code>String n = props.get("nail");</code>\n<code>System.out.println(t + " " + n);</code>',answers:["hammer nail","The code does not compile due to line p1.","The code does not compile due to line p2.","The code does not compile due to line p3."]},{title:"Which filename extension can hold a LocalDateTime property key in a resource bundle?",code:null,answers:[".java",".properties","Both of the above","Neither of the above"]},{title:"If the key purple is in all four of these files, which file will the following code use for the resource bundle?",code:'<code>Locale.setDefault(new Locale("en", "US"));</code>\n<code>ResourceBundle rb = ResourceBundle.getBundle("Colors");</code>\n<code>rb.getString("purple");</code>',answers:["Colors_en.class","Colors_en.properties","Colors_US.class","Colors_US.properties"]},{title:"Fill in the blank so the code correctly compiles and creates a Locale.",code:"<code>Locale loc = Locale.____________________;</code>",answers:['get("Italian")',"get(Locale.ITALIAN)",'getLocale("Italian")',"None of the above"]},{title:"What is the result of the following?",code:'<code>Map&lt;Object, Object&gt; map = new TreeMap&lt;&gt;();</code>\n<code>map.put("tool", "hammer");</code>\n<code>map.put("problem", "nail");</code>\n<code>&nbsp;</code>\n<code>Properties props = new Properties();      // p1</code>\n<code>map.forEach((k,v) -&gt; props.put(k,  v));   // p2</code>\n<code>&nbsp;</code>\n<code>String t = props.getProperty("tool");     // p3</code>\n<code>String n = props.getProperty("problem");</code>\n<code>System.out.println(t + " " + n);</code>',answers:["hammer nail","The code does not compile due to line p1.","The code does not compile due to line p2.","The code does not compile due to line p3."]},{title:"What is the output of the following?",code:'<code>1:   package keyboard;</code>\n<code>2:   import java.util.*;</code>\n<code>3:</code>\n<code>4:   public class Type {</code>\n<code>5:      protected Object[][] getContents() {</code>\n<code>6:         return new Object[][] { { "keys", new ArrayList&lt;String&gt;() }};</code>\n<code>7:      }</code>\n<code><span epub:type="pagebreak" id="Page_377"></span>8:      public static void main(String[] args) {</code>\n<code>9:         ResourceBundle rb = ResourceBundle.getBundle("keyboard.Type");</code>\n<code>10:        List&lt;String&gt; keys = (List) rb.getObject("keys");</code>\n<code>11:        keys.add("q");</code>\n<code>12:        keys.add("w");</code>\n<code>13:        keys.add("e");</code>\n<code>14:        keys.add("r");</code>\n<code>15:        keys.add("t");</code>\n<code>16:        keys.add("y");</code>\n<code>17:        System.out.println(((List) rb.getObject("keys")).size());</code>\n<code>18:     }</code>\n<code>19:  }</code>',answers:["0","6","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"How many lines does the following print out?",code:'<code>3:   Locale.setDefault(Locale.KOREAN);</code>\n<code>4:   System.out.println(Locale.getDefault());</code>\n<code>5:   Locale.setDefault(new Locale("en", "AU"));</code>\n<code>6:   System.out.println(Locale.getDefault());</code>\n<code>7:   Locale.setDefault(new Locale("EN"));</code>\n<code>8:   System.out.println(Locale.getDefault());</code>',answers:["None; it does not compile.","One followed by an exception","Two followed by an exception","All three"]},{title:"Given this properties file used to load the Properties object props and this code snippet, what is the output?",code:'<code>mystery=bag</code>\n<code>type=paper</code>\n<code>&nbsp;</code>\n<code>18:  System.out.print(props.getProperty("mystery", "?"));</code>\n<code>19:  System.out.print(" ");</code>\n<code>20:  System.out.print(props.getProperty("more", "?"));</code>',answers:["bag","bag null","bag ?","This code throws a runtime exception on line 20."]},{title:"Given the following four properties files, what does this code print?",code:'<code>Locale.setDefault(new Locale("en", "US"));</code>\n<code>ResourceBundle rb = ResourceBundle.getBundle(</code>\n<code>   "Cars", new Locale("fr", "FR"));</code>\n<code><span epub:type="pagebreak" id="Page_379"></span>System.out.println(rb.getString("country") + " "</code>\n<code>   + rb.getString("engine"));</code>',answers:["France engine","France moteur","France null","The code throws an exception at runtime."]},{title:"Given the four properties files in question 24, what does this code print?",code:'<code>Locale.setDefault(new Locale("en", "US"));</code>\n<code>ResourceBundle rb = ResourceBundle.getBundle(</code>\n<code>    "Cars", new Locale("fr", "CA"));</code>\n<code>System.out.println(rb.getString("engine") + " "</code>\n<code>    + rb.getString("horses"));</code>',answers:["engine 241","moteur 241","moteur null","The code throws an exception at runtime."]},{title:"Given the four properties files in question 24, what does this code print?",code:'<code>Locale.setDefault(new Locale("fr", "CA"));</code>\n<code>ResourceBundle rb = ResourceBundle.getBundle(</code>\n<code>    "Cars", new Locale("en", "CA"));</code>\n<code>System.out.println(rb.getString("engine") + " "</code>\n<code>    + rb.getString("horses"));</code>',answers:["engine 241","moteur 241","moteur null","The code throws an exception at runtime."]},{title:"Which statement about ListResourceBundle is true?",code:null,answers:["A disadvantage over properties files is that you cannot create the value at runtime.","Names-fr.java is a bad implementation class name.","Values of type Integer are not allowed.","None of the above"]},{title:"If the key red is in all four of these files, which file will the following code use for the resource bundle?",code:'<code>Locale loc = new Locale("zh", "CN");</code>\n<code>Locale.setDefault(new Locale("en", "US"));</code>\n<code>ResourceBundle rb = ResourceBundle.getBundle("Colors", loc);</code>\n<code>rb.getString("red");</code>',answers:["Colors_CN.properties","Colors_en.properties","Colors_US.properties","Colors_zh.properties"]},{title:"What is the output of the following?",code:'<code>package counter;</code>\n<code>import java.util.*;</code>\n<code>&nbsp;</code>\n<code>public class PropertyCounter extends ListResourceBundle {</code>\n<code>   private int count = 0;</code>\n<code>   @Override</code>\n<code>   protected Object[][] getContents() {</code>\n<code>      return new Object[][] {{ "count", new PropertyCounter() }};</code>\n<code>   }</code>\n<code>   public int getCount() {</code>\n<code>      return count++;</code>\n<code>   }</code>\n<code><span epub:type="pagebreak" id="Page_380"></span>   public static void main(String[] args) {</code>\n<code>      ResourceBundle rb = ResourceBundle.getBundle("counter.PropertyCounter");</code>\n<code>      PropertyCounter obj = (PropertyCounter) rb.getObject("count");</code>\n<code>      System.out.println(obj.getCount() + " " + obj.getCount());</code>\n<code>   }</code>\n<code>}</code>',answers:["0 0","0 1","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What is the output of the following?",code:'<code>1:   package keyboard;</code>\n<code>2:   import java.util.*;</code>\n<code>3:</code>\n<code>4:   public class Type extends ListResourceBundle {</code>\n<code>5:      protected Object[][] getContents() {</code>\n<code>6:         return new Object[][] { { "keys", new ArrayList&lt;String&gt;() }};</code>\n<code>7:      }</code>\n<code>8:      public static void main(String[] args) {</code>\n<code>9:         ResourceBundle rb = ResourceBundle.getBundle("Type");</code>\n<code>10:        List&lt;String&gt; keys = (List) rb.getObject("keys");</code>\n<code>11:        keys.add("q");</code>\n<code>12:        keys.add("w");</code>\n<code>13:        keys.add("e");</code>\n<code>14:        keys.add("r");</code>\n<code>15:        keys.add("t");</code>\n<code>16:        keys.add("y");</code>\n<code>17:        System.out.println(((List) rb.getObject("keys")).size());</code>\n<code>18:     }</code>\n<code>19:  }</code>',answers:["0","6","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Given the following snippets of resource bundles from when we compiled the application, what is the result of the following?",code:'<code>Locale.setDefault(new Locale("en", "US"));</code>\n<code>ResourceBundle rb = ResourceBundle.getBundle("Buggy");</code>\n<code>System.out.println(rb.getString("wheels"));</code>',answers:["null","4","6","The code throws an exception at runtime."]},{title:"Given the snippets of resource bundles in question 31 from when we compiled the application, what is the result of the following?",code:'<code>Locale.setDefault(new Locale("en"));</code>\n<code>ResourceBundle rb = ResourceBundle.getBundle("Buggy");</code>\n<code>System.out.println(rb.getString("color"));</code>',answers:["null","black","white","The code throws an exception at runtime."]},{title:"Given the snippets of resource bundles in question 31 from when we compiled the application, what is the result of the following?",code:'<code>Locale.setDefault(new Locale("zh"));</code>\n<code>ResourceBundle rb = ResourceBundle.getBundle("Buggy");</code>\n<code>System.out.println(rb.getString("wheels"));</code>',answers:["null","4","6","The code throws an exception at runtime."]},{title:"If the key red is in all three of these files, which file will the following code use for the resource bundle?",code:'<code>Locale loc = new Locale("zh", "CN");</code>\n<code>Locale.setDefault(new Locale("en", "US"));</code>\n<code>ResourceBundle rb = ResourceBundle.getBundle("Colors", loc);</code>\n<code>rb.getString("red");</code>',answers:["Colors_en.properties","Colors.properties","Red_en.properties","None of the above. It will throw a MissingResourceException."]},{title:"Which can fill in the blank in this code?",code:'<code>Properties props = new Properties();</code>\n<code>props.__________("x");</code>',answers:["get","getProperty","Both of the above","Neither of the above"]},{title:"What is the output of the following?",code:'<code>1:   package keyboard;</code>\n<code>2:   import java.util.*;</code>\n<code>3:</code>\n<code>4:   public class Type extends ListResourceBundle {</code>\n<code>5:      protected Object[][] getContents() {</code>\n<code>6:         return new Object[][] { { "keys", new ArrayList&lt;String&gt;() }};</code>\n<code>7:      }</code>\n<code>8:      public static void main(String[] args) {</code>\n<code>9:         ResourceBundle rb = ResourceBundle.getBundle("keyboard.Type");</code>\n<code>10:        List&lt;String&gt; keys = (List) rb.getObject("keys");</code>\n<code>11:        keys.add("q");</code>\n<code>12:        keys.add("w");</code>\n<code>13:        keys.add("e");</code>\n<code>14:        keys.add("r");</code>\n<code>15:        keys.add("t");</code>\n<code>16:        keys.add("y");</code>\n<code>17:        System.out.println(((List) rb.getObject("keys")).size());</code>\n<code>18:     }</code>\n<code>19:  }</code>',answers:["0","6","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What is the result of the following?",code:'<code>Map&lt;String, String&gt; map = new TreeMap&lt;&gt;();</code>\n<code>map.put("tool", "hammer");</code>\n<code>map.put("problem", "nail");</code>\n<code>&nbsp;</code>\n<code>Property props = new Property();          // p1</code>\n<code>map.forEach((k,v) -&gt; props.put(k, v));    // p2</code>\n<code>&nbsp;</code>\n<code>String t = props.getProperty("tool");     // p3</code>\n<code>String n = props.getProperty("nail");</code>\n<code>System.out.println(t + " " + n);</code>',answers:["hammer nail","The code does not compile due to line p1.","The code does not compile due to line p2.","The code does not compile due to line p3."]},{title:"What is the output of the following?",code:'<code>package counter;</code>\n<code>import java.util.*;</code>\n<code>&nbsp;</code>\n<code>public class CountResource extends ListResourceBundle {</code>\n<code>   private int count = 0;</code>\n<code>&nbsp;</code>\n<code>   @Override</code>\n<code>   protected Object[][] getContents() {</code>\n<code>      return new Object[][] { { "count", count++ } };</code>\n<code>   }</code>\n<code>   public static void main(String[] args) {</code>\n<code>      ResourceBundle rb = new ResourceBundle("counter.CountResource");</code>\n<code>      System.out.println(rb.getObject("count") + " " + rb.getObject("count"));</code>\n<code>   }</code>\n<code>}</code>',answers:["0 0","0 1","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Given the following two properties files in the pod package, what does the following class output?",code:'<code>pod.container.properties</code>\n<code>name=generic</code>\n<code>number=2</code>\n<code>&nbsp;</code>\n<code>pod.container_en.properties</code>\n<code>name=Docker</code>\n<code>type=container</code>\n<code>&nbsp;</code>\n<code>package pod;</code>\n<code>import java.util.*;</code>\n<code>public class WhatKind {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Locale.setDefault(new Locale("en"));</code>\n<code>      ResourceBundle rb = ResourceBundle.getBundle("pod.container");</code>\n<code>      String name = rb.getString("name");</code>\n<code>      String type = rb.getString("type");</code>\n<code>      System.out.println(name + " " + type);   }</code>\n<code>}</code>',answers:["Docker container","generic container","generic null","None of the above"]},{title:"If the key red is in all three of these files, which file will the following code use for the resource bundle?",code:'<code>Locale loc = new Locale("zh", "CN");</code>\n<code>Locale.setDefault(new Locale("en", "US"));</code>\n<code>ResourceBundle rb = ResourceBundle.getBundle("Colors", loc);</code>\n<code>rb.getString("red");</code>',answers:["Colors_EN.properties","Colors_ZH.properties","Red_EN.properties","None of the above. It will throw a MissingResourceException."]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:a(e.answers,n[t]),explain:n[t],ol:e.ol}});i[23].imageUrl="./images/image-ocp-ch22-24.png",i[30].imageUrl="./images/image-ocp-ch22-31.png",t.default=i},178:function(e,t,o){"use strict";o.r(t);var n=["E. The first time through the loop, we are calling indexOf on an empty StringBuilder. This returns -1. Since we cannot insert at index -1, the code throws a StringIndexOutOfBoundsException.","C, E. In Option A, the assignment operator = incorrectly comes after the addition + operator. In Option B, the addition operator + incorrectly comes after the division / operator. In Option D, the subtraction operator - incorrectly comes after the multiplication * operator. This leaves Options C and E as the correct answers. For these answers, it may help to remember that the modulus operator %, multiplication operator *, and division operator / have the same operator precedence.","B, C, F. Option A is incorrect because a getter should not take a value. Option D is incorrect because the prefix is should only be with boolean values. Option E is incorrect because gimme is not a valid JavaBean prefix. Options B, C, and F are each proper JavaBean method signatures.","A, E. Line 24 does not compile because arrays use length. It is ArrayList that uses size(). All of the other lines compile, making Option A correct. It is allowed to split up the braces in the 2D array declaration on line 20. The code is also allowed to use crossword.length as the loop condition on line 22, although this is not a good idea. The array starts out with all 200 of the cells initialized to the default value for an int of 0. Both loops iterate starting at 0 and stopping before 10, which causes only half of the array to be set to 'x'. The other half still has the initial default value of 0, making Option E correct.","B, D. Options A and E are incorrect because they indicate states that the application can possibly recover from. An Error generally indicates an unrecoverable problem. While it is possible to catch an Error, it is strongly recommended that an application never do so, making Options B and D correct. Finally, Option C is incorrect because Error extends from Throwable, not Exception, and is unchecked.","A, C, D. The first import statement allows only the class forest.Bird to be available, making Option A correct and Options E and F incorrect. Option B is incorrect since the third import statement only allows access to classes within the savana package, not any sub-packages. Option C is correct because the second import statement allows any class in the jungle.tree package to be accessible. Finally, Option D is correct because java.lang.* is implicitly included in all Java classes.","C. Mutable means the object can change state. Immutable means the object cannot change state. An ArrayList stores a collection of objects. It mutates as the elements change. A StringBuilder is also mutable as it improves performance by not creating a new object each time it changes. A String is immutable. Methods that look like they change the value simply return a different String object. The date/time objects added in Java 8, such as LocalDateTime, are also immutable. Therefore, Option C is correct with String and LocalDateTime as the immutable object types.","C. On the first iteration through the loop, the first five characters are removed and builder becomes s growing. Since there are more than five characters left, the loop iterates again. This time, five more characters are removed and builder becomes wing. This matches Option C.","D. The code compiles without issue, so Option E is incorrect. The key here is that none of the variables are assigned the same object due to the use of the new keyword. Comparing any two variables with == will always result in an evaluation of false, making the first two values of the print statement be false and false. On the other hand, they all have an underlying String value equivalent to up, so calling equals() on any two variables will return true. Option D is the correct answer that matches what the application will print.","C. Lines 4 and 5 both print false since a String should be compared with a method rather than ==, especially when not comparing two values from the string pool. Line 6 also prints false because one value is uppercase and the other is lowercase. Line 7 prints true because both values are uppercase. Lines 8 and 9 print true because they don\u2019t look at the case. This makes Option C the answer.","A, B, C. Let\u2019s look at each one in turn. Option A is correct because the labels are not referenced. Option B is correct because the outer while is broader than the inner while. Since there is no other code in the loop, it is not needed. Option C is also correct because a label is not used. Option D is incorrect because the inner loop is more specific than the outer loop. While the code still compiles, it prints one less chapter. Options E and F are incorrect because you cannot remove one half of a loop construct and have it compile.","B, C. A long cannot contain a number with decimal points, preventing Options B and C from compiling. Options D and E show you can force a number to be a long by ending it with an upper- or lowercase L. This does not work if the number has a decimal point. Option F shows how to use underscores to break up a number.","A. A while loop checks the condition before executing. Since the hour is not less than one, the loop never enters, and Option A is correct. This is good, because we\u2019d have an infinite loop if the loop was entered since the result of plusHours is ignored.","D. This question appears to ask you about involved array logic. Instead, it is checking to see if you remember that instance and class variables are initialized to null. Line 6 throws a NullPointerException. If the array was declared, the answer would be E because the code would throw an ArrayStoreException on line 8.","C, E. The diamond operator is only allowed to be used when instantiating rather than declaring. In other words, it can\u2019t go on the left side of the equal sign. Therefore, Options B, D, and F are incorrect. The remaining three options compile. However, Option A produces a warning because generics are not used on the right side of the assignment operator. Therefore, Options C and E are correct. Option C is better than Option E since it uses the diamond operator rather than specifying a redundant type.",'B, D. At the end of the method, shoe1 and shoe3 both point to "flip flop". shoe2 points to "croc". Since there are no references to "sandal", it is eligible for garbage collection, making Option B correct. However, garage collection is not guaranteed to run, so Option D is also correct.',"C. The code does not compile, so Options A and B are incorrect. The getFish() method is declared properly in the Fish class and successfully overridden in the Clownfish class. An overridden method must not declare any new or broader checked exceptions, but it is allowed to declare narrower exceptions or drop checked exceptions. The overridden method also uses a covariant return type. The use of final on the method and class declarations has no meaningful impact, since the methods and classes are not extended in this application. So where does the compilation error occur? In the main() method! Even though the Clownfish version of getFish() does not declare a checked exception, the call f.getFish() uses a Fish reference variable. Since the Fish reference variable is used and that version of the method declares a checked Exception, the compiler enforces that the checked exception must be handled by the main() method. Since this checked exception is not handled with a try-catch block nor by the main() method declaration, the code does not compile, and Option C is the correct answer.","A. This is a correct example of using lambdas. The code creates an ArrayList with three elements. The print() method loops through and checks for negative numbers. Option A is correct.","F. A try statement requires a catch or a finally block. It can also have both a catch and a finally block. Since no option matches these rules, Option F is the correct answer. Note that finalize is not a keyword but a method inherited from java.lang.Object. Lastly, the throws keyword can be applied to method declarations and is not used as part of a try statement.","A. On line 12, result is first set to 8. On line 13, the boolean condition is true because 8 > 7. On line 13, result is incremented to 9. Then the inner loop runs, decrementing result until it is no longer greater than 5. On line 18, loop execution is completed because result is equal to 5. The break statement says to skip to after the labeled loop, which is line 20. Then result is printed as 5, making Option A correct.","C. The code compiles and runs without exception, making Options E and F incorrect. The question is testing your knowledge of variable scope. The teeth variable is static in the Alligator class, meaning the same value is accessible from all instances of the class, including the static main() method. The static variable teeth is incremented each time the constructor is called. Since teeth is a local variable within the snap() method, the argument value is used, but changes to the local variable do not affect the static variable teeth. Since the local variable teeth is not used after it is decremented, the decrement operation has no meaningful effect on the program flow or the static variable teeth. Since the constructor is called twice, with snap() executed after each constructor call, the output printed is 1 2, making Option C the correct answer.","A. A String is immutable. Since the result of the concat() method call is ignored, the value of witch never changes. It stays as a single letter, and Option A is correct.","A, C, F. An interface method is exactly one of three types: default, static, or abstract. For this reason, Options A, C, and F are correct. An interface method cannot be protected nor private because the access modifier is always public, even when not specified, making Options B and D incorrect. Option E is also incorrect because final cannot be applied to static methods, since they cannot be overridden. It can also not be applied to default and abstract methods because they are always able to be overridden.","D. Look at the loop condition carefully. It tries to assign null to a String variable. This is not an expression that returns a boolean. Therefore, the code does not compile, and Option D is correct. If this was fixed by making the loop condition tie == null, then Option B would be correct.","B, F. A class may be defined without a package statement, making the class part of the default package. For this reason, Options A and D are incorrect. Every Java class implicitly imports exactly one package, java.lang.*, making Option B correct and Option C incorrect. Option E is incorrect because an import statement is not required. Finally, Option F is correct; any class that does not extend another class implicitly extends java.lang.Object.","D. A class cannot inherit two interfaces that declare the same default method, unless the class overrides them. In this case, the version of grow() in the Tree class is an overloaded method, not an overridden one. Therefore, the code does not compile due to the declaration of Tree on line m1, and Option D is the correct answer.","D. Variables are allowed to start with an underscore and are allowed to contain a $. Therefore, all the variable declarations compile, making Options A, B, and C incorrect. However, the println() refers to the uninitialized local boolean. Since local variables are not automatically initialized, the code does not compile, and Option D is correct.","A. Prefix operators, such as \u2013\u2013x and ++x, modify the variable and evaluate to the new value, while postfix operators, such as x\u2013\u2013 and x++, modify the variable but return the original value. Therefore, Option A is the correct answer.","B, C, E. The constructors declared by Options A, D, and F compile without issue. Option B does not compile. Since there is no call to a parent constructor or constructor in the same class, the compiler inserts a no-argument super() call as the first line of the constructor. Because Big does not have a no-argument constructor, the no-argument constructor Trouble()does not compile. Option C also does not compile because super() and this() cannot be called in the same constructor. Note that if the super() statement was removed, it would still not compile since this would be a recursive constructor call. Finally, Option E does not compile. There is no matching constructor that can take a String followed by a long value. If the input argument deep was an int in this constructor, then it would match the constructor used in Option D and compile without issue.","E, F. A static method is not allowed to access instance variables without an instance of the class, making Options E and F correct. Notice that only max is initialized to 100 in Option E. Since min doesn\u2019t have a value specified, it gets the default value, which is 0.","B, E. The ternary ? : operator only evaluates one of the two right-hand expressions at runtime, so Option A is incorrect. A switch statement may contain at most one optional default statement, making Option B correct. A single if-then statement can have at most one else statement, so Option C is incorrect. Note that you can join if-then-else statements together, but each else requires an additional if-then statement. The disjunctive | operator will always evaluate both operands, while the disjunctive short-circuit || operator will only evaluate the right-hand side of the expression if the left-hand side evaluates to false. Therefore, they are not interchangeable, especially if the right-hand side of the expression modifies a variable. For this reason, Option D is incorrect. Finally, Option E is correct. The logical complement ! operator may only be applied to boolean expressions, not numeric ones.","C. Line 3 creates an empty StringBuilder. Line 4 adds three characters to it. Line 5 removes the first character resulting in ed. Line 6 deletes the characters starting at position 1 and ending right before position 1. Since there are no indexes that meet that description, the line has no effect. Therefore, Option C is correct.","A, D. Java methods must start with a letter, the dollar $ symbol, or the underscore _ character. For this reason, Option B is incorrect, and Options A and D are correct. Despite how Option A looks, it is a valid method signature in Java. Options C, E, and F do not compile because the symbols -, \\, and # are not allowed in method names, respectively.","B, C. First off, Option A is incorrect, since whether or not static or inherited methods are chosen is a matter of design and individual preference. Options B and C are true statements about inheritance and two of the most important reasons Java supports inheritance. Option D is incorrect because all Java classes extend java.lang.Object. Option E is incorrect. Whether or not inheritance simplifies or complicates a design is based on the skills of the developer creating the application.","E. All of the statements are true statements about Java, making Option E the correct answer. Java was built with object-oriented programming and polymorphism in mind. Also, Java supports functional programming using lambda expressions.","C. This array has three elements, making listing.length output 3. It so happens that each element references an array of the same size. But the code checks the first element and sees it is an array of size two, making the answer Option C.","A, B, E. A switch statement supports the primitive types byte, short, char, and int and their associated wrapper classes Character, Byte, Short, and Integer. It also supports the String class and enumerated types. Floating-point types like float and double are not supported, nor is the Object class. For these reasons, Options A, B, and E are correct.","D. The lambda syntax is incorrect. It should be ->, not =>. Therefore, Option D is correct. If this was fixed, Option A would be correct.","B, C, E. The /* */ syntax can have additional (and uneven) * characters in Java, making Options B and E correct. Option C is the standard way to comment a single line with two slashes //. Option A contains a */ in the middle of the expected comment, making the part after the comment Insert **/ invalid. Option D is incorrect because a single slash / is not valid comment in Java. Finally, the # is not a comment character in Java, so Option F is incorrect.","A, F. A static import is used to import static members of another class. Option A is correct because the method getGrass and variable seeds are imported. Option F is also correct because a wildcard on the Grass class for all visible static members is allowed. Option B is incorrect because the wildcard must be on a class, not a package. Options C and E are incorrect since the keywords import and static are reversed. Option D is incorrect because the static keyword is missing.","D. When converting an array to a List, Java uses a fixed-sized backed list. This means that the list uses an array in the implementation. While changing elements to new values is allowed, adding and removing elements is not.","A, D. Variable names can begin with an underscore, making Option A correct. To use an underscore in a numeric literal, it must be between two digits, making Option D correct.","B. While no arguments are passed from the command line, this doesn\u2019t matter because the main() method redefines the args array. Remember that String values sort alphabetically rather than by number. Therefore, 01 sorts before 1, and Option B is correct.","D. The public modifier allows access members in the same class, package, subclass, or even classes in other packages, while the static modifier allows access without an instance of the class. For these reasons, Option D is the correct answer. Option A is incorrect because final is not related to access, and package-private prevents access from classes outside the package. Option B is incorrect because class is not a modifier; it is a keyword. Option C is incorrect because instance is not a Java keyword or modifier, and protected prevents classes that are not subclasses and are outside the package from accessing the variable. Finally, Option E is incorrect. The default keyword is for interface methods and switch statements, not class variables.","A. Looping through the same list multiple times is allowed. Notice how there are not braces around the loops. This means that only the print statement is inside the loop. It executes four times. However, the println() only executes once at the end, making Option A the answer.","C, D. The javac command compiles a .java file into a .class bytecode file, making Option C a correct answer, while also making Options B, E, and F incorrect. The javac command compiles to a set of java instructions, or bytecode, not machine instructions, making Option A incorrect and Option D correct.","C. The parseInt() method returns an int primitive. Thanks to autoboxing, we can also assign it to an Integer wrapper class object reference. The char and short types are smaller than int so they cannot store the result. Therefore, lines 3 and 4 compile, and Option C is correct.","B, D, F. The compiler will broaden the data type on a numeric value until it finds a compatible signature. There are two versions of the drive() methods that return a value of 3, one that takes a short and one that takes a double. Option A is incorrect because boolean cannot be converted to either of these types and trying to do so triggers a compiler error. Option B is correct because the data type short matches our message signature. Options C and E are incorrect. Remember that int and long are larger than short and will trigger different overloaded versions of drive() to be called, one that returns 5 and one that returns 2, respectively. Option D is correct. The byte value can be implicitly converted to short, and there are no other matching method signatures that take a byte value. Finally, Option F is correct because float can be implicitly converted to double, and there is no other version of drive() that takes a float value.","A. Trick question. This appears to be about equality, but it is really about you recognizing that the main() method is missing the static keyword. Running this problem gives a runtime exception because the main() method is not properly declared. Therefore, Option A is the answer. If this was fixed, the answer would be Option C because the int and String comparisons return true.","D. The code compiles without issue, so Options E and F are incorrect. Note that line p2 accesses a static method using an instance reference, which is discouraged but permitted in Java. First, a varargs int array of [0,0] is passed to the swing() method. The try block throws ArrayIndexOutOfBoundsException, since the third element is requested and the size of the array is two. For this reason, the print() statement in the try block is not executed. Next, since ArrayIndexOutOfBoundsException is a subclass of RuntimeException, the RuntimeException catch block is executed and 2 is printed. The rest of the catch blocks are skipped, since the first one was selected. The finally block then executes and prints 4. Lastly, control is returned to the main() method without an exception being thrown, and 5 is printed. Since 245 is printed, Option D is the correct answer.","E. In the first iteration through the loop, container is 2 and cup is printed. Notice how the loop body subtracts 1 to account for indexes being zero based in Java. Then the update statement runs, setting container to 3. The condition is run and sees that 3 is in fact greater than 0. The loop body subtracts 1 and tries to get the element at index 2. There isn\u2019t one and the code throws an exception. This makes Option E correct. You might be tempted to think this is an infinite loop. If the body did not throw an exception, it would be!","A, E, F. An entry point in a Java application consists of a main() method with a single String[] or vararg String... argument, return type of void, and modifiers public and static. Note that the name of the variable in the input argument does not matter and the final modifier is optional. Options A, E, and F match this description and are correct. Option B is incorrect because the argument is a single String. Option C is incorrect, since the access modifier is incorrectly marked protected. Finally, Option D is incorrect because it has two return types, int and void.","C, D, E. For this question, it helps to remember that the value of a case statement must be a literal expression or a final constant variable, and have a compatible data type. For these reasons, Lines 10 and 12 do not compile, making Options C and E correct answers. Line 10 uses a constant value, but long is not compatible with switch statements, while Line 12 uses a variable that is not marked final. Next, a switch statement may only have one default block. Therefore, Line 11 or 14 must be removed. Since Line 14 is not in the list of options, Option D becomes the last correct answer. The rest of the lines are fine since removing Lines 10, 11, and 12 allows the code to compile.","A, B, C. All of the compilation issues with this code involve access modifiers. First, all interface methods are implicitly public, and explicitly setting an interface method to protected causes a compilation error on line h1, making Option A correct. Next, lines h2 and h3 both override the interface method with the package-private access modifier. Since this reduces the implied visibility of public, the overrides are invalid and neither line compiles. Therefore, Options B and C are also correct. Note that the RuntimeException is allowed in an overridden method even though it is not in the parent method signature because only new checked exceptions in overridden methods cause compilation errors. Line h4 is valid. An object can be implicitly cast to a superclass or inherited interface. Finally, lines h5 and h6 will compile without issue but independently throw a ClassCastException and a NullPointerException at runtime, respectively. Since the question only asks about compilation problems, neither of these are correct answers.","B, E, F. Unchecked exceptions inherit the RuntimeException class and are not required to be caught in the methods where they are declared. Since ArithmeticException and IllegalArgumentException extend RuntimeException, they are included as unchecked exceptions, making Options B, E, and F correct. The rest are checked exceptions, which inherit Exception but not RuntimeException.","F. The code compiles without issue, making Options D and E incorrect. Applying the ternary ? : operator, the variable ship is assigned a value of 10.0. The expression in the first if-then statement evaluates to true, so Goodbye is printed. Note that there is no else statement between the first and second if-then statements, therefore the second if-then statement is also executed. The expression in the second if-then statement evaluates to false, so the else statement is called and See you again is also printed. Therefore, Option F is the correct answer, with two statements being printed.","B, C, D. The clock variable is accessed by a class in the same package; therefore, it requires package-private or less restrictive access (protected and public). The getTime() method is accessed by a subclass in a different package; therefore, it requires protected or less restrictive access (public). Options B, C, and D conform to these rules, making them the correct answer. Options A and F cause the Snooze class to fail to compile because the getTime() method is not accessible outside the package, even though Snooze is a subclass of Alarm. Option E causes the Coffee class to fail to compile because the clock variable is only visible within the Alarm class.","B. This problem appears to be to be about overriding a method, but in fact, it is much simpler. The class CarbonStructure is not declared abstract, yet it includes an abstract method. To fix it, the definition of CarbonStructure would have to be changed to be an abstract class, or the abstract modifier would need to be removed from getCount() in CarbonStructure and a method body added. Since the only answer choice available is to change the getCount() method on line q1, Option B is the correct answer. Note that the rest of the application, including the override on line q2, is correct and compiles without issue. The return types Long and Number are covariant since Number is a superclass of Long. Likewise, the exception thrown in the subclass method is narrower, so no compilation error occurs on q2.","C. Line 5 does not declare a main() method that can be the entry point to the program. It does correctly declare a regular instance method and does compile. Line 6 does not compile because LocalDate needs to use a static method rather than a constructor. Line 7 is incorrect because Period methods should not be chained. However, it does compile, returning a period of 1 day. Line 8 does not compile because the correct class name is DateTimeFormatter. Line 9 is correct. Option C is correct because lines 6 and 8 do not compile.","A, E. A try block can have zero or more catch blocks, and zero or one finally blocks, but must be accompanied by at least one of these blocks. For these reasons, Options B, D, and F are incorrect, and Option E is correct. A finally block must appear after the last catch block, if there are any, making Option C incorrect, and Option A correct.","B. The code compiles without issue, so Option E is incorrect. For this problem, it helps to remember that + and * have a higher precedence than the ternary ? : operator. In the first expression, 1 + 2 * 5 is evaluated first, resulting in a reduction to 11>=2 ? 4 : 2, and then fish being assigned a value of 4. In the second expression, the first ternary expression evaluates to false resulting in a reduction to the second right-hand expression 5>=5 ? 9 : 7, which then assigns a value of 9 to mammals. In the print() statement, the first + operator is an addition operator, since the operands are numbers, resulting in the value of 4 + 9, 13. The second + operator is a concatenation since one of the two operands is a String. The result 13 is printed, making Option B the correct answer.","A, C, E. An object can be cast to a superclass or inherited interface type without an explicit cast. Furthermore, casting an object to a reference variable does not modify the object in any way; it just may change what methods and variables are immediately accessible. For these reasons, Options A, C, and E are correct. Option B is incorrect; since the compiler can try to block or warn about invalid casts, it cannot prevent them. For example, any object can be implicitly cast to java.lang.Object, then explicitly cast to any other object, leading to a ClassCastException at runtime. Option D is also incorrect because assigning an object to a subclass reference variable requires an explicit cast. Finally, Option F is incorrect. An object can always be cast to one of its inherited types, superclass or interface, without a ClassCastException being thrown.","F. The array is not sorted. It does not meet the pre-condition for a binary search. Therefore, the output is not guaranteed and the answer is Option F.","B. While shoe3 goes out of scope after the shopping() method, the croc object is referenced by shoe1 and therefore cannot be garbage collected. Similarly, the sandal object is now referenced by shoe2. No variables reference the flip flop object, so it is eligible to be garbage collected, and Option B is correct.","E. The throws keyword is used in method declarations, while the throw keyword is used to throw an exception to the surrounding process, and the finally keyword is used to add a statement that is guaranteed to execute even if an exception is thrown. For these reasons, Option E is the correct answer. ","B, E. The first two iterations through the loop complete successfully, making Option B correct. However, the two arrays are not the same size and the for loop only checks the size of the first one. The third iteration throws an ArrayIndexOutOfBoundsException, making Option E correct.","E. For this question, it helps to try all answers out. Most of them do not make any sense. For example, overloading a method is not a facet of inheritance. Likewise, concrete and abstract methods can both be overridden, not just one. The only answer that is valid is Option E. Without virtual methods, overriding a method would not be possible, and Java would not truly support polymorphism.","E. The code does compile. Line s1 is a bit tricky because length is used for an array and length() is used for a String. Line s1 stores the length of the Fall in a variable, which is 4. Line s2 throws an ArrayIndexOutOfBoundsException because 4 is not a valid index for an array with four elements. Remember that indices start counting with zero. Therefore, Option E is correct.","D. The code definitely does not compile, so Option A is incorrect. The first problem with this code is that the Drum class is missing a constructor causing the class declaration on line 8 to fail to compile. The default no-argument constructor cannot be inserted if the superclass, Instrument, does not define a no-argument constructor. The second problem with the code is that line 11 does not compile, since it calls super.play(5), but the version of play() in the parent class does not take any arguments. Finally, line 15 does not compile. While mn may be a reference variable that points to a Drum() object, the concert() method cannot be called unless it is explicitly cast back to a Drum reference. For these three reasons, the code does not compile, and Option D is the correct answer.","B. The application compiles and runs without issue, so Options E and F are incorrect. Java uses pass-by-value, so even though the change to length in the first line of the adjustPropellers() method does not change the value in the main() method, the value is later returned by the method and used to reassign the length value. The result is that length is assigned a value of 6, due to it being returned by the method. For the second parameter, while the String[] reference cannot be modified to impact the reference in the calling method, the data in it can be. Therefore, the value of the first element is set to LONG, resulting in an output of 6,LONG, making Option B the correct answer.","D. The first compilation problem with the code is that the second catch block in openDrawbridge() is unreachable since CableSnapException is a subclass of OpenDoorException. The catch blocks should be ordered with the more narrow exception classes before the broader ones. Next, the variable ex is declared twice within the same scope since it appears in the second catch block as well as the embedded try-catch block. Finally, the openDrawbridge() method declares the checked Exception class, but it is not handled in the main() method with a try-catch block, nor in the main() method declaration. For these three reasons, Option D is correct.","D. Object orientation is the property of structuring an object with its related data and methods. Encapsulation is the property of removing direct access to the underlying data from processes outside the class. The two go hand and hand to improve class design, making Option D the correct choice.","E. In Java, String is a class and not a primitive. This means it needs to begin with an uppercase letter in the declaration. The code does not compile, making Option E correct. If this was fixed, the answer would be Option B.","A. This class is called with three command-line arguments. First the array is sorted, which meets the pre-condition for binary search. At this point, the array contains [flower, plant, seed]. The key is to notice the value of args[0] is now flower rather than seed. Calling binary search to find the position of flower returns 0, which is the index matching that value. Therefore, the answer is Option A.","B, C, D. A for-each loop is a specialized loop that just iterates through an array or list. It can be rewritten using explicit indexing code in any of the other three loop types. Therefore, Options B, C, and D are correct. Option A is incorrect because a do-while loop is guaranteed to execute at least once. Option E is incorrect because the traditional for loop can loop backwards or by skipping indexes. Option F is incorrect because non-index-related boolean conditions are allowed to be used in a while loop.","E. The LocalDate class is only for day/month/year values. It does not support time, so getHour() and plusHours() do not compile, making Option E the answer.","C. All arrays are objects regardless of whether they point to primitives or classes. That means both balls and scores are objects. Both are set to null so they are eligible for garbage collection. The balls array is initialized to all null references. There are no objects inside. The scores array is initialized to all 0 values. Therefore, only two objects exist to be eligible for garbage collection, and Option C is correct.","B. Since there are not brackets around the while loop, only line 17 is in the loop body. Line 18 gets executed once after the loop completes. This means that count will be 1 assuming the loop completes. Subtracting a month from JANUARY results in DECEMBER. Since the loop completes E is incorrect and Option B is the answer. Note that if the brackets were added as the indentation suggests, Option D would be the answer since we are counting months backwards.","D. Line 10 does not compile because the override reduces the visibility of an inherited method, with the package-private modifier being more restrictive than the protected modifier. Line 11 does also not compile, since the left-hand side of a compound assignment operator must be used with a variable, not a method. Finally, Line 12 does not compile because super.grunt() is inherited as an abstract method in the PolarBear class, meaning the parent class has no implementation. For these three reasons, Option D is the correct answer.","B, E. Package-private, or default, access is denoted by the absence of an access modifier, making Option A incorrect. Option B is correct, since a switch statement can contain a default execution path. Options C and F are incorrect because keywords in Java cannot be used as method or variable names. Finally, interfaces can contain default interface methods but they must be concrete with a method body. For this reason, Option E is correct and Option D is incorrect."],a=function(e){return e.split(".")[0].split(", ").map(function(e){return function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(e)})},i=function(e,t){var o=a(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:o.includes(t)}})},c=[{title:"What is the output if this class is run with java Indexing cars carts?",code:'<code>public class Indexing {</code>\n<code>   public static void main(String... books) {</code>\n<code>      StringBuilder sb = new StringBuilder();</code>\n<code>      for (String book : books)</code>\n<code>         sb.insert(sb.indexOf("c"), book);</code>\n<code>      System.out.println(sb);</code>\n<code>   }</code>\n<code>}</code>',answers:["cars","cars carts","ccars arts","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Fill in the blanks: The operators +=,__________ ,__________ ,__________ ,__________ , and ++ are listed in increasing or the same level of operator precedence. (Choose two.)",code:null,answers:["\u2013, +, =, --","%, *, /, +","=, +, /, *","^, *, -, ==","*, /, %, --"]},{title:"Which of the following are valid JavaBean signatures? (Choose three.)",code:null,answers:["public byte getNose(String nose)","public void setHead(int head)","public String getShoulders()","public long isMouth()","public void gimmeEars()","public boolean isToes()"]},{title:"Which of the following are true? (Choose two.)",code:"<code>20:  int[] crossword [] = new int[10][20];</code>\n<code>21:  for (int i = 0; i &lt; crossword.length; i++)</code>\n<code>22:     for (int j = 0; j &lt; crossword.length; j++)</code>\n<code>23:        crossword[i][j] = 'x';\t</code>\n<code>24:  System.out.println(crossword.size());</code>",answers:["One line needs to be changed for this code to compile.","Two lines need to be changed for this code to compile.","Three lines need to be changed for this code to compile.","If the code is fixed to compile, none of the cells in the 2D array have a value of 0.","If the code is fixed to compile, half of the cells in the 2D array have a value of 0.","If the code is fixed to compile, all of the cells in the 2D array have a value of 0."]},{title:"Which of the following statements about java.lang.Error are most accurate?  (Choose two.)",code:null,answers:["An Error should be thrown if a file system resource becomes temporarily unavailable.","An application should never catch an Error.","Error is a subclass of Exception, making it a checked exception.","It is possible to catch and handle an Error thrown in an application.","An Error should be thrown if a user enters invalid input."]},{title:"Given a class that uses the following import statements, which class would be automatically accessible without using its full package name? (Choose three.)",code:"<code>import forest.Bird;</code>\n<code>import jungle.tree.*;</code>\n<code>import savana.*;</code>",answers:["forest.Bird","savana.sand.Wave","jungle.tree.Huicungo","java.lang.Object","forest.Sloth","forest.ape.bonobo"]},{title:"How many of the following variables represent immutable objects?",code:"<code>ArrayList l = new ArrayList();</code>\n<code>String s = new String();</code>\n<code>StringBuilder sb = new StringBuilder();</code>\n<code>LocalDateTime t = LocalDateTime.now();</code>\n<code>&nbsp;</code>",answers:["None","One","Two","Three","Four","None of the above\u2014this code doesn\u2019t compile."]},{title:"What is the output of the following?",code:'<code>StringBuilder builder = new StringBuilder("Leaves growing");</code>\n<code>do {</code>\n<code>   builder.delete(0, 5);</code>\n<code>} while (builder.length() &gt; 5);</code>\n<code>System.out.println(builder);</code>',answers:["Leaves growing","ing","wing","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What is the output of the following application?",code:'<code>package reality;</code>\n<code>public class Equivalency {</code>\n<code>   public static void main(String[] edges) {</code>\n<code>      final String ceiling = "up";</code>\n<code>      String floor = new String("up");</code>\n<code>      final String wall = new String(floor);</code>\n<code>      System.out.print((ceiling==wall)          +" "+(floor==wall)          +" "+ceiling.equals(wall));</code>\n<code>   }</code>\n<code>}</code>',answers:["false false false","true true true","false true true","false false true","It does not compile."]},{title:"How many times does the following code print true?",code:'<code>1:   public class Giggles {</code>\n<code>2:      public static void main(String[] args) {</code>\n<code>3:         String lol = "lol";</code>\n<code>4:         System.out.println(lol.toUpperCase() == lol);</code>\n<code>5:         System.out.println(lol.toUpperCase() == lol.toUpperCase());</code>\n<code>6:         System.out.println(lol.toUpperCase().equals(lol));</code>\n<code>7:         System.out.println(lol.toUpperCase().equals(lol.toUpperCase()));</code>\n<code>8:         System.out.println(lol.toUpperCase().equalsIgnoreCase(lol));</code>\n<code><span epub:type="pagebreak" id="Page_155"></span>9:         System.out.println(lol.toUpperCase()</code>\n<code>10:           .equalsIgnoreCase(lol.toUpperCase()));</code>\n<code>11:  } }</code>\n<code>&nbsp;</code>',answers:["One","Two","Three","Four","Five","None. The code does not compile."]},{title:"Which lines can be removed together without stopping the code from compiling and while printing the same output? (Choose three.)",code:'<code>14:  String race = "";</code>\n<code>15:  outer:</code>\n<code>16:  do {</code>\n<code>17:  inner:</code>\n<code>18:     do {</code>\n<code>19:        race += "x";</code>\n<code>20:     } while (race.length() &lt;= 4);</code>\n<code>21:  } while (race.length() &lt; 4);</code>\n<code>22: System.out.println(race);</code>',answers:["Lines 15 and 17","Lines 15, 16, and 21","Line 17","Lines 17, 18, and 20","Line 20","Line 21"]},{title:"Which of the following do not compile when filling in the blank? (Choose two.)",code:"<code>long bigNum = ____________;</code>",answers:["1234","1234.0","1234.0L","1234l","1234L","1_234"]},{title:"How many lines does this program print?",code:'<code>import java.time.*;</code>\n<code>public class OnePlusOne {</code>\n<code>   public static void main(String... nums) {</code>\n<code>      LocalTime time = LocalTime.of(1, 11);</code>\n<code>      while (time.getHour() &lt; 1) {</code>\n<code>         time.plusHours(1);</code>\n<code>         System.out.println("in loop");</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>\n<code>&nbsp;</code>',answers:["None","One","Two","This is an infinite loop.","The code does not compile."]},{title:"What is the result of running the following program?",code:"<code>1:   package fun;</code>\n<code>2:   public class Sudoku {</code>\n<code>3:      static int[][] game;</code>\n<code>4:</code>\n<code>5:      public static void main(String args[]) {</code>\n<code>6:         game[3][3] = 6;</code>\n<code>7:         Object[] obj = game;</code>\n<code>8:         obj[3] = 'X';</code>\n<code>9:         System.out.println(game[3][3]);</code>\n<code>10:     }</code>\n<code>11:  }</code>",answers:["6","X","The code does not compile.","The code compiles but throws a NullPointerException at runtime.","The code compiles but throws a different exception at runtime.","The output is not guaranteed."]},{title:"Which of the following use generics and compile without warnings? (Choose two.)",code:null,answers:["List<String> a = new ArrayList();","List<> b = new ArrayList();","List<String> c = new ArrayList<>();","List<> d = new ArrayList<>();","List<String> e = new ArrayList<String>();","List<> f = new ArrayList<String>();"]},{title:"Which of the following are true right before the main() method ends? (Choose two.)",code:'<code>public static void main(String[] args) {</code>\n<code>   String shoe1 = new String("sandal");</code>\n<code>   String shoe2 = new String("flip flop");</code>\n<code>   String shoe3 = new String("croc");</code>\n<code>&nbsp;</code>\n<code>   shoe1 = shoe2;</code>\n<code>   shoe2 = shoe3;</code>\n<code>   shoe3 = shoe1;</code>\n<code>}</code>',answers:["No objects are eligible for garbage collection.","One object is eligible for garbage collection.","Two objects are eligible for garbage collection.","No objects are guaranteed to be garbage collected.","One object is guaranteed to be garbage collected.","Two objects are guaranteed to be garbage collected."]},{title:"How many lines of the following application do not compile?",code:'<code>package ocean;</code>\n<code>class BubbleException extends Exception {}</code>\n<code>class Fish {</code>\n<code>   Fish getFish() throws BubbleException {</code>\n<code>      throw new RuntimeException("fish!");</code>\n<code>   }</code>\n<code>}</code>\n<code>public final class Clownfish extends Fish {</code>\n<code>   public final Clownfish getFish() {</code>\n<code>      throw new RuntimeException("clown!");</code>\n<code>   }</code>\n<code>   public static void main(String[] bubbles) {</code>\n<code>      final Fish f = new Clownfish();</code>\n<code><span epub:type="pagebreak" id="Page_158"></span>      f.getFish();</code>\n<code>      System.out.println("swim!");</code>\n<code>   }</code>\n<code>}</code>',answers:["None. The code compiles and prints swim!.","None. The code compiles and prints a stack trace.","One","Two","Three"]},{title:"How many lines does this code output?",code:"<code>import java.util.*;</code>\n<code>import java.util.function.*;</code>\n<code>&nbsp;</code>\n<code>public class PrintNegative {</code>\n<code>&nbsp;</code>\n<code>  public static void main(String[] args) {</code>\n<code>     List&lt;Integer&gt; list= new ArrayList&lt;&gt;();</code>\n<code>     list.add(-5);</code>\n<code>     list.add(0);</code>\n<code>     list.add(5);</code>\n<code>     print(list, e -&gt; e &lt; 0);</code>\n<code>  }</code>\n<code>&nbsp;</code>\n<code>  public static void print(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; p) {</code>\n<code>      for (Integer num : list)</code>\n<code>         if (p.test(num))</code>\n<code>            System.out.println(num);</code>\n<code>  }</code>\n<code>}</code>",answers:["One","Two","Three","None. It doesn\u2019t compile.","None. It throws an exception at runtime."]},{title:"Which keywords are required with a try statement?",code:null,answers:["I only","II only","III only","IV only","I or II, or both","None of the above"],ol:["finalize","catch","throws","finally"]},{title:"What is the output of the following?",code:"<code>12:  int result = 8;</code>\n<code>13:  loop: while (result &gt; 7) {</code>\n<code>14:     result++;</code>\n<code>15:     do {</code>\n<code>16:        result--;</code>\n<code>17:     } while (result &gt; 5);</code>\n<code>18:     break loop;</code>\n<code>19:  }</code>\n<code>20:  System.out.println(result);</code>",answers:["5","7","8","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What is the result of compiling and executing the following application?",code:'<code>package reptile;</code>\n<code>public class Alligator {</code>\n<code>   static int teeth;</code>\n<code>   double scaleToughness;</code>\n<code>   public Alligator() {</code>\n<code>      teeth++;</code>\n<code>   }</code>\n<code>   public void snap(int teeth) {</code>\n<code>      System.out.print(teeth+" ");</code>\n<code>      teeth--;</code>\n<code>   }</code>\n<code>   public static void main(String[] unused) {</code>\n<code>      new Alligator().snap(teeth);</code>\n<code>      new Alligator().snap(teeth);</code>\n<code>   }</code>\n<code>}</code>',answers:["0 1","1 1","1 2","2 2","The code does not compile.","The code compiles but produces an exception at runtime."]},{title:"What is the output of the following?",code:'<code>public class Costume {</code>\n<code>   public static void main(String[] black) {</code>\n<code>      String witch = "b";</code>\n<code>      String tail = "lack";</code>\n<code>      witch.concat(tail);</code>\n<code>      System.out.println(witch);</code>\n<code>   }</code>\n<code>}</code>',answers:["b","black","lack","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which modifiers can be independently applied to an interface method? (Choose three.)",code:null,answers:["default","protected","static","private","final","abstract"]},{title:"What is the output of the following?",code:'<code>public class Shoelaces {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      String tie = null;</code>\n<code>      while (tie = null)</code>\n<code>         tie = "shoelace";</code>\n<code>         System.out.print(tie);</code>\n<code>   }</code>\n<code>}</code>',answers:["null","shoelace","shoelaceshoelace","The code does not compile.","This is an infinite loop.","The code compiles but throws an exception at runtime."]},{title:"What statements are true about compiling a Java class file? (Choose two.)",code:null,answers:["If the file does not contain a package statement, then the compiler considers the class part of the java.lang package.","The compiler assumes every class implicitly imports the java.lang.* package.","The compiler assumes every class implicitly imports the java.util.* package.","Java requires every file to declare a package statement.","Java requires every file to declare at least one import statement.","If the class declaration does not extend another class, then it implicitly extends the java.lang.Object class."]},{title:"What is the output of the following application?",code:'<code>package woods;</code>\n<code>interface Plant {</code>\n<code>   default String grow() { return "Grow!"; }</code>\n<code>}</code>\n<code>interface Living {</code>\n<code>   public default String grow() { return "Growing!"; }</code>\n<code>}</code>\n<code>public class Tree implements Plant, Living {  // m1</code>\n<code>   public String grow(int height) { return "Super Growing!"; }</code>\n<code>   public static void main(String[] leaves) {</code>\n<code>      Plant p = new Tree();  // m2</code>\n<code>      System.out.print(((Living)p).grow());  // m3</code>\n<code>   }</code>\n<code>}</code>',answers:["Grow!","Growing!","Super Growing!","It does not compile because of line m1.","It does not compile because of line m2.","It does not compile because of line m3."]},{title:"What is the result of the following?",code:'<code>public static void main(String... args) {</code>\n<code>   String name = "Desiree";</code>\n<code>   int _number = 694;</code>\n<code>   boolean profit$$$;</code>\n<code>   System.out.println(name + " won. "</code>\n<code>       + _number + " profit? " + profit$$$);</code>\n<code>}</code>',answers:["The declaration of name does not compile.","The declaration of _number does not compile.","The declaration of profit$$$ does not compile.","The println statement does not compile.","The code compiles and runs successfully.","The code compiles and throws an exception at runtime."]},{title:"Fill in the blanks: Given a variable x, __________ decreases the value of x by 1 and returns the original value, while __________ increases the value of x by 1 and returns the new value.",code:null,answers:["x--, ++x","x--, x++","--x, x++","--x, ++x"]},{title:"Given the following two classes in the same package, which constructors contain compiler errors? (Choose three.)",code:'<code>public class Big {</code>\n<code>   public Big(boolean stillIn) {</code>\n<code>      super();</code>\n<code>   }</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>public class Trouble extends Big {</code>\n<code>   public Trouble()  {}</code>\n<code>   public Trouble(int deep) {</code>\n<code>      super(false);</code>\n<code>      this();</code>\n<code>   }</code>\n<code>   public Trouble(String now, int... deep) {</code>\n<code>      this(3);</code>\n<code><span epub:type="pagebreak" id="Page_163"></span>   }</code>\n<code>   public Trouble(long deep) {</code>\n<code>      this("check",deep);</code>\n<code>   }</code>\n<code>   public Trouble(double test) {</code>\n<code>      super(test&gt;5 ? true : false);</code>\n<code>   }</code>\n<code>}</code>',answers:["public Big(boolean stillIn)","public Trouble()","public Trouble(int deep)","public Trouble(String now, int... deep)","public Trouble(long deep)","public Trouble(double test)"]},{title:"Which of the following can replace the comment so this code outputs 100? (Choose two.)",code:"<code>public class Stats {</code>\n<code>   // INSERT CODE</code>\n<code>   public static void main(String[] math) {</code>\n<code>     System.out.println(max - min);</code>\n<code>   }</code>\n<code>}</code>",answers:["final int min, max = 100;","final int min = 0, max = 100;","int min, max = 100;","int min = 0, max = 100;","static int min, max = 100;","static int min = 0, max = 100;"]},{title:"Which of the following statements are true about Java operators and statements? (Choose two.)",code:null,answers:["Both right-hand sides of the ternary expression will be evaluated at runtime.","A switch statement may contain at most one default statement.","A single if-then statement can have multiple else statements.","The | and || operator are interchangeable, always producing the same results at runtime.","The ! operator may not be applied to numeric expressions."]},{title:"What is the output of the following?",code:'<code>1:   public class Legos {</code>\n<code>2:      public static void main(String[] args) {</code>\n<code>3:         StringBuilder sb = new StringBuilder();</code>\n<code>4:         sb.append("red");</code>\n<code>5:         sb.deleteCharAt(0);</code>\n<code>6:         sb.delete(1, 1);</code>\n<code>7:         System.out.println(sb);</code>\n<code>8:      }</code>\n<code>9:   }</code>',answers:["r","e","ed","red","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which of the following is a valid method name in Java? (Choose two.)",code:null,answers:["_____()","%run()","check-Activity()","$Hum2()","sing\\\\3()","po#ut ()"]},{title:"Which of the following statements about inheritance are true? (Choose two.)",code:null,answers:["Inheritance is better than using static methods for accessing data in other classes.","Inheritance allows a method to be overridden in a subclass, possibly changing the expected behavior of other methods in a superclass.","Inheritance allows objects to inherit commonly used attributes and methods.","It is possible to create a Java class that does not inherit from any other.","Inheritance tends to make applications more complicated."]},{title:"Which of the following statements about Java are true?",code:null,answers:["I only","II only","II and III","I, III, and IV","I, II, III, and IV","None are true."],ol:["The java command uses . to separate packages.","Java supports functional programming.","Java is object oriented.","Java supports polymorphism."]},{title:"What is the output of the following?",code:'<code>String[][] listing = new String[][] { { "Book", "34.99" },</code>\n<code>   { "Game", "29.99" }, { "Pen", ".99" } };</code>\n<code>System.out.println(listing.length + " " + listing[0].length);</code>',answers:["2 2","2 3","3 2","3 3","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which of the following variable types is permitted in a switch statement? (Choose three.)",code:null,answers:["Character","Byte","Double","long","String","Object"]},{title:"What does the following do?",code:"<code>public class Shoot {</code>\n<code>   interface Target {</code>\n<code>      boolean needToAim(double angle);</code>\n<code>   }</code>\n<code>   static void prepare(double angle, Target t) {</code>\n<code>      boolean ready = t.needToAim(angle);  // k1</code>\n<code>      System.out.println(ready);</code>\n<code>   }</code>\n<code>   public static void main(String[] args) {</code>\n<code>      prepare(45, d =&gt; d &gt; 5 || d &lt; -5);   // k2</code>\n<code>   }</code>\n<code>}</code>",answers:["It prints true.","It prints false.","It doesn\u2019t compile due to line k1.","It doesn\u2019t compile due to line k2.","It doesn\u2019t compile due to another line."]},{title:"Which of the following is a valid code comment in Java? (Choose three.)",code:null,answers:["/** Insert */ in next method **/","/****** Find the kitty cat */","// Is this a bug?","/ Begin method - performStart() /","/*** TODO: Call grandma ***/","# Updated code by Patti"]},{title:"Given the following two classes, each in a different package, which lines allow the second class to compile when inserted independently? (Choose two.)",code:"<code>package food;</code>\n<code>public class Grass {</code>\n<code>   public static int seeds = 10;</code>\n<code>   public static Grass getGrass() {return new Grass();}</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>package woods;</code>\n<code>// INSERT CODE HERE</code>\n<code>public class Deer {</code>\n<code>   public void eat() {</code>\n<code>      getGrass();</code>\n<code>      System.out.print(seeds);</code>\n<code>   }</code>\n<code>}</code>",answers:["import static food.Grass.getGrass;\n\nimport static food.Grass.seeds;\n","import static food.*;","static import food.Grass.*;","import food.Grass.*;","static import food.Grass.getGrass;\n\nstatic import food.Grass.seeds;\n","import static food.Grass.*;"]},{title:"What is the result of the following?",code:'<code>import java.util.*;</code>\n<code>public class Museums {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      String[] array = {"Natural History", "Science", "Art"};</code>\n<code>      List&lt;String&gt; museums = Arrays.asList(array);</code>\n<code>      museums.remove(2);</code>\n<code>      System.out.println(museums);</code>\n<code>   }</code>\n<code>}</code>\n<code>&nbsp;</code>',answers:["[Natural History, Science]","[Natural History, Science, Art]","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which of the following substitutions will compile? (Choose two.)",code:'<code>public class Underscores {</code>\n<code>   public String name = "Sherrin";</code>\n<code>   public void massage() {</code>\n<code>      int zip = 10017;</code>\n<code>   }</code>\n<code>}</code>',answers:["Change name to _name","Change 10017 to _10017","Change 10017 to 10017_","Change 10017 to 10_0_17","Change int to _int"]},{title:"What is the result of the following when called as java counting.Binary?",code:'<code>package counting;</code>\n<code>import java.util.*;</code>\n<code>public class Binary {</code>\n<code>&nbsp;</code>\n<code>   public static void main(String[] args) {</code>\n<code>      args = new String[] {"0", "1", "01", "10" };</code>\n<code>&nbsp;</code>\n<code>      Arrays.sort(args);</code>\n<code>      System.out.println(Arrays.toString(args));</code>\n<code>   }</code>\n<code>}</code>',answers:["[]","[0, 01, 1, 10]","[0, 01, 10, 1]","[0, 1, 01, 10]","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Fill in the blanks: Using the _____________ and _____________ modifiers together allows a variable to be accessed from any class, without requiring an instance variable.",code:null,answers:["final, package-private","class, static","protected, instance","public, static","default, public"]},{title:"How many lines does the following code output?",code:'<code>import java.util.*;</code>\n<code>public class Exams {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      List&lt;String&gt; exams = Arrays.asList("OCA", "OCP");</code>\n<code>      for (String e1 : exams)</code>\n<code>         for (String e2 : exams)</code>\n<code>            System.out.print(e1 + " " + e2);</code>\n<code>            System.out.println();</code>\n<code>   }</code>\n<code>}</code>',answers:["One","Four","Five","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which of the following are true statements? (Choose two.)",code:null,answers:["The javac command compiles a source text file into a set of machine instructions.","The java command compiles a .class file into a .java file.","The javac command compiles a .java file into a .class file.","The javac command compiles a source text file into a bytecode file.","The java command compiles a .java file into a .class file.","The javac command compiles a .class file into a .java file."]},{title:"How many of the following lines of code compile?",code:'<code>char one = Integer.parseInt("1");</code>\n<code>Character two = Integer.parseInt("2");</code>\n<code>int three = Integer.parseInt("3");</code>\n<code>Integer four = Integer.parseInt("4");</code>\n<code>short five = Integer.parseInt("5");</code>\n<code>Short six = Integer.parseInt("6");</code>',answers:["None","One","Two","Three","Four","Five"]},{title:"Given the application below, what data types can be inserted into the blank that would allow the code to print 3? (Choose three.)",code:"<code>public class Highway {</code>\n<code>   public int drive(long car) { return 2; }</code>\n<code>   public int drive(double car) { return 3; }</code>\n<code>   public int drive(int car) { return 5; }</code>\n<code>   public int drive(short car) { return 3; }</code>\n<code>   public static void main(String[] gears) {</code>\n<code>      ____________ value = 5;</code>\n<code>      System.out.print(new Highway().drive(value));</code>\n<code>   }</code>\n<code>}</code>",answers:["boolean","short","int","byte","long","float"]},{title:"How many times does this code print true?",code:'<code>import java.time.*;</code>\n<code>public class Equality {</code>\n<code>   public void main(String[] args) {</code>\n<code>      System.out.println(new StringBuilder("zelda")</code>\n<code>          == new StringBuilder("zelda"));</code>\n<code><span epub:type="pagebreak" id="Page_170"></span>      System.out.println(3 == 3);</code>\n<code>      System.out.println("bart" == "bart");</code>\n<code>      System.out.println(new int[0] == new int[0]);</code>\n<code>      System.out.println(LocalTime.now() == LocalTime.now());</code>\n<code>   }</code>\n<code>}</code>',answers:["None","One","Two","Three","The code does not compile."]},{title:"What is the output of the following application?",code:'<code>package ballroom;</code>\n<code>public class Dance {</code>\n<code>   public static void swing(int... beats) throws ClassCastException {</code>\n<code>      try {</code>\n<code>         System.out.print("1"+beats[2]);  // p1</code>\n<code>      } catch (RuntimeException e) {</code>\n<code>         System.out.print("2");</code>\n<code>      } catch (Exception e) {</code>\n<code>         System.out.print("3");</code>\n<code>      } finally {</code>\n<code>         System.out.print("4");</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String... music) {</code>\n<code>      new Dance().swing(0,0);  // p2</code>\n<code>      System.out.print("5");</code>\n<code>   }</code>\n<code>}</code>',answers:["145","1045","24, followed by a stack trace","245","The code does not compile because of line p1.","The code does not compile because of line p2."]},{title:"What is the output of the following?",code:'<code>List&lt;String&gt; drinks = Arrays.asList("can", "cup");</code>\n<code>for (int container = drinks.size(); container &gt; 0; container++) {</code>\n<code>   System.out.print(drinks.get(container-1) + ",");</code>\n<code>}</code>',answers:["can,cup,","cup,can,","The code does not compile.","This is an infinite loop.","The code compiles but throws an exception at runtime."]},{title:"Which of the following method signatures are valid declarations of an entry point in a Java application? (Choose three.)",code:null,answers:["public static void main(String... widgets)","public static void main(String sprockets)","protected static void main(String[] args)","public static int void main(String[] arg)","public static final void main(String []a)","public static void main(String[] data)"]},{title:"Given the application below and the choices available, which lines must all be removed to allow the code to compile? (Choose three.)",code:'<code>1:  package year;</code>\n<code>2:  public class Seasons {</code>\n<code>3:     public static void main(String[] time) {</code>\n<code>4:        final long winter = 10;</code>\n<code>5:        final byte season = 2;</code>\n<code>6:        int fall = 4;</code>\n<code>7:        final short summer = 3;</code>\n<code>8:        switch(season) {</code>\n<code>9:           case 1:</code>\n<code>10:          case winter: System.out.print("winter");</code>\n<code>11:          default:</code>\n<code>12:          case fall: System.out.print("fall");</code>\n<code>13:          case summer: System.out.print("summer");</code>\n<code>14:          default:</code>\n<code>15:       }</code>\n<code>16:    }</code>\n<code>17: }</code>',answers:["Line 8","Line 9","Line 10","Line 11","Line 12","Line 13"]},{title:"Given the application below, which lines do not compile? (Choose three.)",code:'<code>package furryfriends;</code>\n<code>interface Friend {</code>\n<code>   protected String getName();  // h1</code>\n<code>}</code>\n<code>class Cat implements Friend {</code>\n<code>   String getName() {  // h2</code>\n<code>      return "Kitty";</code>\n<code>   }</code>\n<code>}</code>\n<code>public class Dog implements Friend {</code>\n<code>   String getName() throws RuntimeException {  // h3</code>\n<code>      return "Doggy";</code>\n<code>   }</code>\n<code>   public static void main(String[] adoption) {</code>\n<code>      Friend friend = new Dog();  // h4</code>\n<code>      System.out.print(((Cat)friend).getName());  // h5</code>\n<code>      System.out.print(((Dog)null).getName());  // h6</code>\n<code>   }</code>\n<code>}</code>',answers:["Line h1","Line h2","Line h3","Line h4","Line h5","Line h6"]},{title:"Which of the following are unchecked exceptions? (Choose three.)",code:null,answers:["FileNotFoundException","ArithmeticException","IOException","Exception","IllegalArgumentException","RuntimeException"]},{title:"What is the result of compiling and executing the following application?",code:'<code>package ranch;</code>\n<code>public class Cowboy {</code>\n<code>   private int space = 5;</code>\n<code>   private double ship = space &lt; 2 ? 1 : 10;  // g1</code>\n<code>   public void printMessage() {</code>\n<code>      if(ship&gt;1) {</code>\n<code>         System.out.println("Goodbye");</code>\n<code>      } if(ship&lt;10 &amp;&amp; space&gt;=2) System.out.println("Hello");  // g2</code>\n<code>      else System.out.println("See you again");</code>\n<code>   }</code>\n<code>   public static final void main(String... stars) {</code>\n<code>      new Cowboy().printMessage();</code>\n<code>   }</code>\n<code>}</code>',answers:["It only prints Hello.","It only prints Goodbye.","It only prints See you again.","It does not compile because of line g1.","It does not compile because of line g2.","None of the above"]},{title:"Given the following three class declarations, which sets of access modifiers can be inserted, in order, into the blank lines below that would allow all of the classes to compile? (Choose three.)",code:"<code>package wake;</code>\n<code>public class Alarm {</code>\n<code>    ____________static int clock;</code>\n<code>    ____________long getTime() {return clock;}</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>package wake;</code>\n<code>public class Coffee {</code>\n<code>   private boolean bringCoffee() { return new Alarm().clock&lt;10;}</code>\n<code>}</code>\n<code>&nbsp;</code>\n<code>package sleep;</code>\n<code>public class Snooze extends wake.Alarm {</code>\n<code>   private boolean checkTime() { return getTime()&gt;10;}</code>\n<code>}</code>",answers:["protected and package-private (blank)","public and public","package-private (blank) and protected","protected and protected","private and public","package-private (blank) and package-private (blank)"]},{title:"Given that FileNotFoundException is a subclass of IOException and Long is a subclass of Number, what is the output of the following application?",code:"<code>package materials;</code>\n<code>&nbsp;</code>\n<code>import java.io.*;</code>\n<code>&nbsp;</code>\n<code>class CarbonStructure {</code>\n<code>    protected long count;</code>\n<code>    public abstract Number getCount() throws IOException;  // q1</code>\n<code>    public CarbonStructure(int count) { this.count = count; }</code>\n<code>}</code>\n<code>public class Diamond extends CarbonStructure {</code>\n<code>   public Diamond() { super(15); }</code>\n<code>   public Long getCount() throws FileNotFoundException {  // q2</code>\n<code>      return count;</code>\n<code>   }</code>\n<code>   public static void main(String[] cost) {</code>\n<code>      try {</code>\n<code>         final CarbonStructure ring = new Diamond();  // q3</code>\n<code>         System.out.print(ring.getCount());  // q4</code>\n<code>      } catch (IOException e) {</code>\n<code>         e.printStackTrace();</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>",answers:["15","It does not compile because of line q1.","It does not compile because of line q2.","It does not compile because of line q3.","It does not compile because of line q4.","It compiles but throws an exception at runtime."]},{title:"How many lines contain a compile error?",code:'<code>1:   import java.time.*;</code>\n<code>2:   import java.time.format.*;</code>\n<code>3:</code>\n<code>4:   public class HowLong {</code>\n<code>5:      public void main(String h) {</code>\n<code>6:         LocalDate newYears = new LocalDate(2017, 1, 1);</code>\n<code>7:         Period period = Period.ofYears(1).ofDays(1);</code>\n<code>8:         DateTimeFormat format = DateTimeFormat.ofPattern("MM-dd-yyyy");</code>\n<code>9:         System.out.print(format.format(newYears.minus(period)));</code>\n<code>10:    }</code>\n<code>11:  }</code>',answers:["None","One","Two","Three","Four","Five"]},{title:"Which of the following statements about try-catch blocks are correct? (Choose two.)",code:null,answers:["A catch block can never appear after a finally block.","A try block must be followed by a catch block.","A finally block can never appear after a catch block.","A try block must be followed by a finally block.","A try block can have zero or more catch blocks.","A try block can have zero or more finally blocks."]},{title:"What is printed by the following code snippet?",code:'<code>int fish = 1 + 2 * 5&gt;=2 ? 4 : 2;</code>\n<code>int mammals = 3 &lt; 3 ? 1 : 5&gt;=5 ? 9 : 7;</code>\n<code>System.out.print(fish+mammals+"");</code>',answers:["49","13","18","99","It does not compile."]},{title:"Which of the following statements about objects, reference types, and casting are correct? (Choose three.)",code:null,answers:["An object can be assigned to an inherited interface reference variable without an explicit cast.","The compiler can prevent all explicit casts that lead to an exception at runtime.","Casting an object to a reference variable does not modify the object in memory.","An object can be assigned to a subclass reference variable without an explicit cast.","An object can be assigned to a superclass reference variable without an explicit cast.","An implicit cast of an object to one of its inherited types can sometimes lead to a ClassCastException at runtime."]},{title:"What is the output of the following when run as java EchoFirst seed flower plant?",code:"<code>package unix;</code>\n<code>&nbsp;</code>\n<code>import java.util.*;</code>\n<code>&nbsp;</code>\n<code>public class EchoFirst {</code>\n<code>&nbsp;</code>\n<code>   public static void main(String[] args) {</code>\n<code>      int result = Arrays.binarySearch(args, args[0]);</code>\n<code>      System.out.println(result);</code>\n<code>  }</code>\n<code>}</code>\n<code>&nbsp;</code>",answers:["0","1","2","The code does not compile.","The code compiles but throws an exception at runtime.","The output is not guaranteed."]},{title:"How many objects are eligible for garbage collection at the end of the main() method?",code:'<code>package store;</code>\n<code>public class Shoes {</code>\n<code>&nbsp;</code>\n<code>   static String shoe1 = new String("sandal");</code>\n<code>   static String shoe2 = new String("flip flop");</code>\n<code>&nbsp;</code>\n<code>   public static void shopping() {</code>\n<code>      String shoe3 = new String("croc");</code>\n<code><span epub:type="pagebreak" id="Page_177"></span>      shoe2 = shoe1;</code>\n<code>      shoe1 = shoe3;</code>\n<code>   }</code>\n<code>&nbsp;</code>\n<code>   public static void main(String... args) {</code>\n<code>      shopping();</code>\n<code>   }</code>\n<code>}</code>\n<code>&nbsp;</code>',answers:["None","One","Two","Three","The code does not compile."]},{title:"Fill in the blanks: The  ____________keyword is used in method declarations, the  ____________keyword is used to guarantee a statement will execute even if an exception is thrown, and the  ____________keyword is used to throw an exception to the surrounding process.",code:null,answers:["throw, finally, throws","throws, catch, throw","catch, finally, throw","finally, catch, throw","throws, finally, throw"]},{title:"Which statements best describe the result of this code? (Choose two.)",code:'<code>package nyc;</code>\n<code>public class TouristBus {</code>\n<code>  public static void main(String... args) {</code>\n<code>     String[] nycTourLoops = new String[] { "Downtown", "Uptown", "Brooklyn" };</code>\n<code>     String[] times = new String[] { "Day", "Night" };</code>\n<code>        for (int i = 0, j = 0; i &lt; nycTourLoops.length; i++, j++)</code>\n<code>           System.out.println(nycTourLoops[i] + " " + times[j]);</code>\n<code>  }</code>\n<code>}</code>',answers:["The println causes one line of output.","The println causes two lines of output.","The println causes three lines of output.","The code terminates successfully.","The code throws an exception at runtime."]},{title:"Fill in the blanks: Because of____________ , it is possible to  ____________a method, which allows Java to support____________ .",code:null,answers:["abstract methods, override, inheritance","concrete methods, overload, inheritance","virtual methods, overload, interfaces","inheritance, abstract, polymorphism","virtual methods, override, polymorphism."]},{title:"What is the result of the following?",code:'<code>package calendar;</code>\n<code>public class Seasons {</code>\n<code>&nbsp;</code>\n<code>   public static void seasons(String... names) {</code>\n<code>      int l = names[1].length();       // s1</code>\n<code>      System.out.println(names[l]);    // s2</code>\n<code>   }</code>\n<code>&nbsp;</code>\n<code>   public static void main(String[] args) {</code>\n<code>      seasons("Summer", "Fall", "Winter", "Spring");</code>\n<code>   }</code>\n<code>}</code>\n<code>&nbsp;</code>',answers:["Fall","Spring","The code does not compile.","The code throws an exception on line s1.","The code throws an exception on line s2."]},{title:"How many lines of the following application contain compilation errors?",code:'<code>1:  package percussion;</code>\n<code>2:  </code>\n<code>3:  interface MakesNoise {}</code>\n<code>4:  abstract class Instrument implements MakesNoise {</code>\n<code>5:     public Instrument(int beats) {}</code>\n<code>6:     public void play() {}</code>\n<code>7:  }</code>\n<code>8:  public class Drum extends Instrument {</code>\n<code>9:     public void play(int count) {}</code>\n<code>10:    public void concert() {</code>\n<code>11:       super.play(5);</code>\n<code><span epub:type="pagebreak" id="Page_179"></span>12:    }</code>\n<code>13:    public static void main(String[] beats) {</code>\n<code>14:       MakesNoise mn = new Drum();</code>\n<code>15:       mn.concert();</code>\n<code>16:    }</code>\n<code>17: }</code>',answers:["None. The code compiles and runs without issue.","One","Two","Three","Four"]},{title:"What is the output of the following application?",code:'<code>package fly;</code>\n<code>public class Helicopter {</code>\n<code>   public int adjustPropellers(int length, String[] type) {</code>\n<code>      length++;</code>\n<code>      type[0] = "LONG";</code>\n<code>      return length;</code>\n<code>   }</code>\n<code>   public static void main(String[] climb) {</code>\n<code>      final Helicopter h = new Helicopter();</code>\n<code>      int length = 5;</code>\n<code>      String[] type = new String[1];</code>\n<code>      length = h.adjustPropellers(length, type);</code>\n<code>      System.out.print(length+","+type[0]);</code>\n<code>   }</code>\n<code>}</code>',answers:["5,LONG","6,LONG","5,null","6,null","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"How many lines of the following application do not compile?",code:'<code>package castles;</code>\n<code>class OpenDoorException extends Exception {}</code>\n<code>class CableSnapException extends OpenDoorException {}</code>\n<code><span epub:type="pagebreak" id="Page_180"></span>public class Palace {</code>\n<code>   public void openDrawbridge() throws Exception {</code>\n<code>      try {</code>\n<code>         throw new Exception("Problem");</code>\n<code>      } catch (OpenDoorException e) {</code>\n<code>         throw new OpenDoorException();</code>\n<code>      } catch (CableSnapException ex) {</code>\n<code>         try {</code>\n<code>            throw new OpenDoorException();</code>\n<code>         } catch (Exception ex) {</code>\n<code>         } finally {</code>\n<code>            System.out.println("Almost done");</code>\n<code>         }</code>\n<code>      } finally {</code>\n<code>         throw new RuntimeException("Unending problem");</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] moat) throws IllegalArgumentException {</code>\n<code>      new Palace().openDrawbridge();</code>\n<code>   }</code>\n<code>}</code>',answers:["None. The code compiles and produces a stack trace at runtime.","One","Two","Three","Four","Five"]},{title:"Choose the best answer:  ____________and  ____________are two properties that go hand in hand to improve class design by structuring a class with related attributes and actions while protecting the underlying data from access by other classes.",code:null,answers:["Optimization and platform independence","Platform independence and encapsulation","Platform independence and inheritance","Object orientation and encapsulation","Inheritance and polymorphism"]},{title:"What is the output of the following?",code:'<code>string bike1 = "speedy";</code>\n<code>string bike2 = new String("speedy");</code>\n<code><span epub:type="pagebreak" id="Page_181"></span>boolean test1 = bike1 == bike2;</code>\n<code>boolean test2 = bike1.equals(bike2);</code>\n<code>System.out.println(test1 + " " + test2);</code>',answers:["false false","false true","true false","true true","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What is the output of the following when run as java EchoFirst seed flower plant?",code:"<code>package unix;</code>\n<code>&nbsp;</code>\n<code>import java.util.*;</code>\n<code>&nbsp;</code>\n<code>public class EchoFirst {</code>\n<code>&nbsp;</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Arrays.sort(args);</code>\n<code>      int result = Arrays.binarySearch(args, args[0]);</code>\n<code>      System.out.println(result);</code>\n<code>  }</code>\n<code>}</code>\n<code>&nbsp;</code>",answers:["0","1","2","The code does not compile.","The code compiles but throws an exception at runtime.","The output is not guaranteed."]},{title:"Which are true statements? (Choose three.)",code:null,answers:["Every do-while loop can be rewritten as a for-each loop.","Every for-each loop can be rewritten as a do-while loop.","Every for-each loop can be rewritten as a traditional for loop.","Every for-each loop can be rewritten as a while loop.","Every traditional for loop can be rewritten as a for-each loop.","Every while loop can be rewritten as a for-each loop."]},{title:"How many lines does this program print?",code:'<code>import java.time.*;</code>\n<code>public class OnePlusOne {</code>\n<code>   public static void main(String... nums) {</code>\n<code>     LocalDate time = LocalDate.of(1, 11);</code>\n<code>     while (time.getHour() &lt; 1) {</code>\n<code>        time.plusHours(1);</code>\n<code>        System.out.println("in loop");</code>\n<code>     }</code>\n<code>   }</code>\n<code>}</code>',answers:["None","One","Two","This is an infinite loop.","The code does not compile."]},{title:"How many objects are eligible for garbage collection immediately before the end of the main() method?",code:"<code>public class Tennis {</code>\n<code>   public static void main(String[] game) {</code>\n<code>      String[] balls = new String[1];</code>\n<code>      int[] scores = new int[1];</code>\n<code>      balls = null;</code>\n<code>      scores = null;</code>\n<code>   }</code>\n<code>}</code>",answers:["None","One","Two","Three","Four"]},{title:"What is the output of the following?",code:"<code>14:  int count = 0;</code>\n<code>15:  LocalDate date = LocalDate.of(2017, Month.JANUARY, 1);</code>\n<code>16:  while (date.getMonth() != Month.APRIL)</code>\n<code>17:     date = date.minusMonths(1);</code>\n<code>18:     count++;</code>\n<code>19:  System.out.println(count);</code>",answers:["0","1","3","9","This is an infinite loop.","The code does not compile."]},{title:"How many lines of the following class do not compile?",code:"<code>1:  package arctic;</code>\n<code>2:  abstract class Bear {</code>\n<code>3:     protected int sing;</code>\n<code>4:     protected abstract int grunt();</code>\n<code>5:     int sing() {</code>\n<code>6:        return sing;</code>\n<code>7:     }</code>\n<code>8:  }</code>\n<code>9:  public class PolarBear extends Bear {</code>\n<code>10:    int grunt() {</code>\n<code>11:       sing() += 10;</code>\n<code>12:       return super.grunt()+1;</code>\n<code>13:       return 10;</code>\n<code>14:    }</code>\n<code>15: }</code>",answers:["None, the class compiles without issue.","One","Two","Three","Four","Five"]},{title:"In which places is the default keyword permitted to be used? (Choose two.)",code:null,answers:["Access modifier in a class","Execution path in a switch statement","Method name","Modifier in an abstract interface method","Modifier in an interface method with a body","Variable name"]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:i(e.answers,n[t]),answersIntArray:a(n[t]),explain:n[t],ol:e.ol}});t.default=c},179:function(e,t,o){"use strict";o.r(t);var n=["A, E. Line 12 has no effect. The cursor starts out positioned immediately before the first row and beforeFirst() keeps it there. Line 13 moves the cursor to point to row five and prints true. Line 14 prints the value in that row, which is 5. Line 15 tries to subtract 10 rows from the current position. That would be at row negative five. However, the cursor can\u2019t go back further than the beginning, so it stays at row zero. It also prints false since there isn\u2019t data at row zero. Note this is the same position the cursor was at on line 12. Now we have a problem. Line 16 tries to print a value on row zero, but there is no data. It instead throws a SQLException, making Option E correct. Option A is also correct since true was only output once.","D. While this code misuses formatting characters, it does compile and run successfully, making Options E and F incorrect. A lowercase m represents the minutes, which are 59 in this case, ruling out Options A and B. The rest of the code prints the date, hour, and month. This gives the value 59.140103, making Option D the answer.","A, B, E. First off, Option A is a valid functional interface that matches the Runnable functional interface. Option B is also a valid lambda expression that matches Function<Double,Double>, among other functional interfaces. Option C is incorrect because the local variable w cannot be declared again in the lambda expression body since it is already declared in the lambda expression. Option D is also incorrect. If the data type is specified for one variable in a lambda expression, it must be specified for all variables within the expression. Next, Option E is correct because this lambda expression matches the UnaryOperator functional interface. Lastly, Option F is incorrect. The statement name.toUpperCase() is missing a semicolon (;) that is required to terminate the statement.","D. The code does not compile, so Options A, B, and F are incorrect. The first compilation error is in the declaration of the lambda expression for second. It does not use a generic type, which means t is of type Object. Since Object, unlike String, does not have a method equalsIgnoreCase(), the lambda expression does not compile. The second compilation issue is in the lambda expression in the main() method. Notice that process() takes an ApplyFilter instance, and ApplyFilter is a functional interface that takes a List<String> object. For this reason, q in this lambda expression is treated as an instance of List<String>. The forEach() method defined in Collections requires a Consumer instance, not a Function, so the call q.forEach(first) does not compile. For these two reasons, Option D is the correct answer, since the rest of the code compiles without issue.","B. First, remember that you are supposed to assume missing imports are present so you can act as if java.util and java.util.stream are imported. This code does compile. Line r1 is a valid lambda definition of a Comparator. Line r2 is valid code to sort a stream in a descending order and print the values. Therefore, Option B is correct.","F. The first catch block on line p1 does not compile because AddingException and DividingException are checked exceptions, and the compiler detects these exceptions are not capable of being thrown by the associated try block. The second catch block on line p2 also does not compile, although for a different reason. UnexpectedException is a subclass of RuntimeException, which in turn extends Exception. This makes UnexpectedException a subclass of Exception, causing the compiler to consider UnexpectedException redundant. For these two reasons, the code does not compile, and Option F is the correct answer.","A. The code compiles and runs without issue, making Option A the correct answer. Enums are usually named like classes and have enum values that are all uppercase. While a format like Colors.RED or Colors.GREEN is the common convention, alternate formats like COLORS.blue do compile. Next, note the enum properly implements the HasHue interface even though there\u2019s no enum-level method, with each value having its own implementation. Also, line 10 does not end with a semicolon (;). Because there are no methods or constructors defined outside the value list, a semicolon (;) is not required. The enum class and the rest of the application compile without issue, printing Painting: 00FF00 at runtime.","C. Java 8 date and time classes are immutable. They use a static factory method to get the object reference rather than a constructor. This makes II, IV, and VI incorrect. Further, there is not a ZonedDate class. There is a ZonedDateTime class. This additionally makes V incorrect. Both I and III compile, so Option C is correct.","C, F. The Optional does not contain a value. While there is a get() method on Optional, it doesn\u2019t take any parameters, making Options A and B incorrect. Option C is the simplest way to print the desired result. The orElse() method returns the parameter passed if the Optional is empty. The orElseGet() method runs the Supplier passed as a parameter, making Option F correct as well.","B. This class is never instantiated, so the instance initializer never outputs 1 and the constructor never outputs 3. This rules out Options A, D, and E. A static initializer only runs once for the class, which rules out Option C. Option B is correct because the static initializer runs once printing 2, followed by the static method callMe() printing 4 twice, and ending with the main() method printing 5.","C. The Locale class has a constructor taking a language code and an optional country code. The Properties class is a type of Map so it also has a constructor. By contrast, a ResourceBundle subclass is typically obtained by calling the ResourceBundle.getBundle() method. ResourceBundle is an abstract class, so a subclass will get returned like ListResourceBundle.","E. Option C is clearly incorrect because the class has a public constructor so cannot be a singleton. Options A, B, and D are also incorrect because the height instance variable is not private. This means other classes in the same package can read and change the value. Therefore, Option E is correct.","E. The readObject() method returns an Object instance, which must be explicitly cast to Cruise in the second try-with-resources statement. For this reason, the code does not compile, and Option E is the correct answer. If the explicit cast was added, the code would compile but throw a NotSerializableException at runtime, since Cruise does not implement the Serializable interface. If both of these issues were corrected, the code would run and print 4,null. The schedule variable is marked transient, so it defaults to null when deserialized, while numPassengers is assigned the value it had when it was serialized. Note that on deserialization, the constructors and instance initializers are not executed.","B. Driver, Connection, Statement, and ResultSet are the four key interfaces you need to know for JDBC. DriverManager is a class rather than an interface. Query is not used in JDBC. Since only Driver and ResultSet are interfaces in the list, Option B is the answer.","A, C, F. The IntUnaryOperator takes an int value and returns an int value. Options B and E are incorrect because the parameter types, Integer and long, respectively, are not compatible. Option B is incorrect because while unboxing can be used for expressions, it cannot be used for parameter matching. Option E is incorrect because converting from long to int requires an explicit cast. Option D is incorrect because dividing an int by a double value 3.1 results in q/3.1 being a double value, which cannot be converted to int without an explicit cast. The rest of the lambda expressions are valid since they correctly take an int value and return an int value.","D, F. To begin with, the read() method of both classes returns an int value, making Option A incorrect. As you may recall from your studies, neither use byte or char, so that -1 can be returned when the end of the stream is reached without using an existing byte or char value. Option B is incorrect because neither contain a flush() method, while Option C is incorrect because they both contain a skip() method. Both InputStream and Reader are abstract classes, not interfaces, making Option D correct and Option E incorrect. That leaves Option F as a correct answer. Both can be used to read character or String data, although Reader is strongly recommended, given its built-in support for character encodings.","B. There are not minus() or plus() methods on ChronoUnit making Options C, D, E and F incorrect. Both Options A and B compile; however, they differ in the output. Option A prints 1 because you can add 1 to get from November to December. Option B prints -1 because the first date is larger, and therefore Option B is the correct answer.","D. The code compiles without issue, making the first statement true and eliminating Option B. It is possible that System.console() could return null, leading to a NullPointerException at runtime and making the third statement true. For this reason, Options A and C are also incorrect. That leaves us with two choices. While the process correctly clears the password from the char array in memory, it adds the value to the JVM string pool when it is converted to a String. The whole point of using a char array is to prevent the password from entering the JVM string pool, where it can exist after the method that called it has finished running. For this reason, the second statement is false, making Option D correct and Option E incorrect.","B. Options C and D are incorrect because they print the Runner object rather than the int value it contains since peek() is called before mapping the value. The Runner object is something like Runner@6d03e736. Option A is incorrect because the map() method returns a Stream<Integer>. While Stream<Integer> does have a max() method, it requires a Comparator. By contrast, Option B uses mapToInt(), which returns an IntStream and does have a max() method that does not take any parameters. Option B is the only one that compiles and outputs the int values.","E. The code does not compile, so Options A, B, and F are incorrect. The first compilation error is on line 3, which is missing a required semicolon (;) at the end of the line. A semicolon (;) is required at the end of any enum value list if the enum contains anything after the list, such as a method or constructor. The next compilation error is on line 4 because enum constructors cannot be public. The last compilation error is on line 10. The case statement must use an enum value, such as FALL, not an int value. For these three reasons, Option E is the correct answer.","A, C, E. To start with, bustNow() now takes a Double value, while bustLater() takes a double value. To be compatible, the lambda expression has to be able to handle both data types. Option A is correct, since the method reference System.out::print matches overloaded methods that can take double or a Double (via unboxing). Option B is incorrect, since intValue() works for the Consumer<Double>, which takes Double, but not DoubleConsumer, which takes double. For a similar reason, Option D is also incorrect because only the primitive double is compatible with this expression. Option C is correct and results in just a blank line being printed. Option E is correct since it is just the lambda version of the method reference in Option A. Finally, Option F is incorrect because of incompatible data types. The method reference is being used inside of a lambda expression, which would only be allowed if the functional interface returned another functional interface reference.","F. This class correctly creates and retrieves a Java class resource bundle. Since count is an int, it is autoboxed into an Integer. However, rb.getString() cannot be called for an Integer value. The code throws a ClassCastException, so Option F is the answer. If this was fixed, the answer would be Option C because the pre-increment is used and getContents() is only called once.","C. The Java 8 date/time APIs count months starting with one rather than zero. This means localDate is created as October 5, 2017. This is not the day that daylight savings time ends. The loop increments the hour six times, making the final time 07:00. Therefore Option C is the answer.","A. The code does not compile because BasicFileAttributes is used to read file information, not write it, making Option A the correct answer. If the code was changed to pass BasicFileAttributeView.class to the Files.getFileAttributeView() method, then the code would compile, and Option B would be the correct answer. Finally, remember that by default, symbolic links are not traversed by the Files.walk() method, avoiding a cycle. If FileVisitOption.FOLLOW_LINKS was passed, then the class would throw an exception because Files.walk() does keep track of the files it visits and throws a FileSystemLoopException in the presence of a cycle.","B. The code compiles without issue, making Option E incorrect. Option A is incorrect because it disables all assertions, which is the default JVM behavior. Option B is the correct answer. It disables assertions everywhere but enables them within the Watch class, triggering an AssertionError at runtime within the checkHour() method. Option C is incorrect because it enables assertions everywhere but disables them within the Watch class. Option D is also incorrect because -enableassert is not a valid JVM flag. The only valid flags to enable assertions are -ea and -enableassertions.","F. The code compiles without issue, making Option C incorrect. The main() method creates a thread pool of four threads. It then submits 10 tasks to it. At any given time, the ExecutorService has up to four threads active, which is the same number of threads required to reach the CyclicBarrier limit. Therefore, the barrier limit is reached twice, printing Jump! twice, making Option A incorrect. Unfortunately, the program does not terminate, so Option B is also incorrect. While eight of the tasks have been completed, two are left running. Since no more tasks will call the await() method, the CyclicBarrier limit is never reached, and the two remaining threads\u2019 tasks hang indefinitely. For this reason, Option F is the correct answer. Option E is incorrect because making the IntStream parallel would not change the result. Option D is incorrect because the result is the same no matter how many times the program is executed.","C. The code does not compile because Files.isSameFile() requires Path instances, not String values. For this reason, Option C is the correct answer. If Path values had been used, then the code would compile and print Same!, and Option A would be the correct answer since the isSameFile() method does follow symbolic links.","D, E. Since JavaProgrammerCert is a subclass of Exam, it cannot have a more specific visibility modifier. Exam uses protected, which is broader than package-private in JavaProgrammerCert. This rules out Options A, B, and C. The other three options all compile. However, Option F has a problem. Suppose your JavaProgrammerCert object has an Exam object with pass set to true for both the oca and ocp variables. The implementation in Option F doesn\u2019t look at either of those variables. It looks at the superclass\u2019s pass value. This isn\u2019t logically correct. Therefore, Options D and E are correct.","B, D. First off, Option A is incorrect because a narrower exception can be thrown by an overridden method, just not a broader checked exception. Option B is correct and is the rule for return types of overridden methods. Option C is incorrect because overridden methods must use the same input arguments. If the input arguments are different, the method is overloaded, not overridden. Option D is correct because modifiers that limit the access of the inherited method are not permitted. Option E is incorrect because private and static methods cannot be overridden. Remember that private methods defined in parent classes are not inherited, aka not visible in the child class, while static methods may be visible but cannot be overridden since they do not belong to an instance. Finally, Option F is also incorrect. The @Override annotation is optional and recommended but not required.","D. The most common approach is III, which works for any SELECT statement that has an int in the first column. If the SELECT statement has a function like count(*) or sum(*) in the first column, there will always be a row in the ResultSet, so II works as well. Therefore, Option D is the answer.","E. DoubleBinaryOperator takes two double values and returns a double value. LongToIntFunction takes one long value and returns an int value. ToLongBiFunction takes two generic arguments and returns a long value. IntSupplier does not take any values and returns an int value. ObjLongConsumer takes one generic and one long value and does not return a value. For these reasons, Option E is the correct answer.","F. While an Instant represents a specific moment in time using GMT, Java only allows adding or removing units of DAYS or smaller. This code throws an UnsupportedTemporalTypeException because of the attempt to add YEARS. Therefore, Option F is correct.","B. First we create two Blankie objects. One of them has the color pink and the other leaves it as the default value of null. When the stream intermediate operation runs, it calls the isPink() method twice, returning true and false respectively. Only the first one goes on to the terminal operation and is printed, making Option B correct.","F. This class is not immutable. Most obviously, an immutable class can\u2019t have a setter method. It also can\u2019t have a package-private instance variable. The getter method should be final so the class prevents a subclass from overriding the method. Since all three of these changes are needed to make this class immutable, Option F is the answer.","B, C, E. First of all, BufferedFileOutputStream does not exist in java.io, making Option A incorrect. Also, OutputStream is abstract, not concrete, so Option F can also be eliminated. The data being written is stored in memory as a Student object, so serializing with ObjectOutputStream is appropriate. Since a large set of records are involved, we should use BufferedOutputStream. Since the data is being written to a file, we would use FileOutputStream. For these reasons, Options B, C, and E are correct. Note that FileWriter is not possible since it cannot be chained with the other two java.io classes, making Option D incorrect.","C, D. Option A is incorrect because the peek() method returns the next value or null if there isn\u2019t one without changing the state of the queue. In this example, both peek() calls return 18. Option B is incorrect because the poll() method removes and returns the next value, returning null if there isn\u2019t one. In this case, 18 and null are returned, respectively. Options C and D are correct because both the pop() and remove() methods throw a NoSuchElementException when the queue is empty. This means both return 18 for the first call and throw an exception for the second.","F. Line 11 assigns a relative Path value of ./song/../note to x. The second line assigns an absolute Path value of /dance/move.txt to y. Line 13 does not modify the value of x because Path is immutable and x is not reassigned to the new value. On line 14, the resolve() method is called using y as the input argument. If the parameter passed to the resolve() method is absolute, then that value is returned, leading the first println() method call to output /dance/move.txt. On the other hand, the relativize() method on line 15 requires both Path values to be absolute, or both to be relative. Mixing the two leads to an IllegalArgumentException on line 15 at runtime and makes Option F the correct answer.","B. The code does not compile, so Option E is incorrect. The first compilation error is in the try-with-resources declaration. There are two resources being declared, which is allowed, but they are separated by a comma (,) instead of a semicolon (;). The second compilation problem is that the order of exceptions in the two catch blocks are reversed. Since Exception will catch all StungException instances, the second catch block is unreachable. For these two reasons, Option B is the correct answer.","C. The class compiles and runs without issue, so Options D and E are incorrect. The result of findSlow() is deterministic and always 1. The findFirst() method returns the first element in an ordered stream, whether it be serial or parallel. This makes it a costly operation for a parallel stream since the stream has to be accessed in a serial manner. On the other hand, the result of findFast() is unknown until runtime. The findAny() method may return the first element or any element in the stream, even on serial streams. Since both 1 1 and 3 1 are possible outputs of this program, the answer cannot be determined until runtime, and Option C is the correct answer.","D. There is not a method called getDefaultProperty() on the Properties class. Since the code does not compile, Option D is the answer. The getProperty() method on Properties is overloaded to allow passing a default value as the second parameter. If this code was changed to use getProperty(), the answer would be Option C.","B, D. The try-with-resources statement requires resources that implement AutoCloseable. While Closeable extends AutoCloseable, it is certainly possible to have a class that implements AutoCloseable and works with try-with-resources but does not implement Closeable, making Option A incorrect. Option B is correct and a valid statement about how resources are closed in try-with-resources statements. Option C is incorrect because the exception in the try block is reported to the caller, while the exception in the close() method is suppressed. Option D is the other correct answer because neither catch nor finally are required when try-with-resources is used. Lastly, Option E is incorrect. While the AutoCloseable does define a close() method that throws a checked exception, classes that implement this method are free to drop the checked exception, per the rules of overriding methods.","B. The Roller class uses a formal type parameter named E with a constraint. The key to this question is knowing that with generics, the extends keyword means any subclass or the class can be used as the type parameter. This means both Wheel and CartWheel are OK. The wheel1 declaration is fine because the same type is used on both sides of the declaration. The wheel2 declaration does not compile because generics require the exact same type when not using wildcards. The wheel3 and wheel4 declarations are both fine because this time there is an upper bound to specify that the type can be a subclass. By contrast, the super keyword means it has to be that class or a superclass. The wheel6 declaration is OK, but the wheel5 one is a problem because it uses a subclass. Since wheel2 and wheel5 don\u2019t compile, the answer is Option B.","B. This class is not a singleton because it needs a private constructor. Having a setter method is fine. The state of a singleton\u2019s instance variables is allowed to change. The static initializer is fine as it runs at the same line as the declaration on line 2. Therefore, only the constructor addition is needed, and Option B is correct.","A. This code tries to update a cell in a ResultSet. However, it does not call updateRow() to actually apply the changes in the database. This means the SELECT query does not see the changes and outputs the original value of 0. Option A is correct.","A, B, D. Option A is correct because the java.io stream classes implement Closeable and can be used with try-with-resources statements, while java.util.stream.Stream does not implement Closeable. Option B is correct since the Reader/Writer classes are used for handling character data. There are primitive stream classes in java.util.stream, but none for handling character data, such as CharStream. Option C is incorrect because neither requires all data objects to implement Serializable. Option D is correct since flush() is found in Writer and OutputStream but not in any of the java.util.stream classes. Option E is incorrect since both types of streams contain a skip() method in some of their classes. Lastly, Option F is incorrect. There is no sort method found in any of the java.io classes. While there is a sorted() method in java.util.stream.Stream, the question is asking about what features are available in a java.io stream class and not in a java.util.stream.Stream class.","E. The code does contain compilation errors, so Option A is incorrect. The first is on line 8. The readAllLines() method returns a List<String>, not a Stream. While parallelStream() is allowed on a Collection, parallel() is not. Next, line 14 does not compile because of an invalid method call. The correct NIO.2 method call is Files.isRegularFile(), not File.isRegularFile(), since the legacy File class does not have such a method. Line 18 contains a similar error. Path is an interface, not a class, with the correct call being Paths.get(). Lastly, line 19 does not compile because the read() method throws Exception, which is not caught or handled by the main() method. For these four reasons, Option D is the correct answer.","D. The code compiles, making Option E incorrect. The key here is that the AtomicInteger variable is thread-safe regardless of the synchronization methods used to access it. Therefore, synchronizing on an instance object, as in increment1() or increment3(), or on the class object, as in increment2(), is unnecessary because the AtomicInteger class is already thread-safe. For this reason, Option D is the correct answer.","B, D. The Files.find() method requires a starting Path value, an int maximum depth, and a BiPredicate<Path,BasicFileAttributes> matcher instance. For these reasons, Options A, C, and E are incorrect. A FileVisitOption vararg is allowed but not required, making Option B correct. The other correct answer is Option D because the method does not take a long value.","C, D. Option A is incorrect because Comparable is implemented on the class being compared. To be useful, such a class must have instance variables to compare, ruling out a lambda. By contrast, a Comparator is often implemented with a lambda. Option B is incorrect because compare() is found in a Comparator. Option C is correct because these methods have different parameters but the same return type. Option D is correct because a Comparator doesn\u2019t need to be implemented by the class being compared. Option E is incorrect because multiple comparators can use different orders for comparison, which do not need to match the definition of equality.","C. The code compiles, so Option E is incorrect. The first boolean expression returns false because the two Path expressions have different values and are therefore not equivalent. On the other hand, the second boolean expression returns true. If we normalize t1, it becomes /stars.exe, which is equivalent to the t2 variable in terms of equals(). The third boolean expression also returns true, even though the file does not exist. The isSameFile() method will avoid checking the file system if the two Path expressions are equivalent in terms of equals(), which from the second boolean expression we know that they are. That leaves the fourth boolean expression, which returns true. Passing an absolute Path to resolve() just returns it, so t2 and t3 are equivalent values. For these reasons, Option C is the correct answer. Note that if the Path values had not been equivalent in terms of equals() for either of the last two boolean expressions, then the file system would have been accessed, and since none of the files exist, an exception would have been thrown at runtime.","B, E. The method does not call the markSupported() prior to calling mark() and reset(). This is considered a poor practice. The input variable could be a subclass of Reader that does not support this functionality. In this situation, the method would ignore the mark() call and throw an IOException on the reset() method, making Option A incorrect and Option B correct. On the other hand, if marking the stream is supported, then no exception would be thrown. First, line 24 skips two values, 1 and 2. On line 25, the mark() method is called with a value of 5, which is the number of characters that can be read and stored before the marked point is invalidated. Next, line 26 would skip another value but is undone by the reset() on line 27. The next value to be read would be the third value, 3. The read(char[]) call would then read up to five values, since that is the size of the array. Since only four are left (4, 5, 6, 7) the method would return a value of 4, corresponding to the number of characters read from the stream. For these reasons, the output is 3-4, making Option E the correct answer. Options C and D can be eliminated because read() returns an int value, not a char.","C. The Function interface uses apply(), while the Consumer interface uses accept(), making Option C the correct answer. For reference, get() is the name of the method used by Supplier, while test() is the name of the method used by Predicate.","D. The Teacher class, including all five assert statements, compiles without issue, making Option F incorrect. The first three assert statements on lines 4, 5, and 6 evaluate to true, not triggering any exceptions, with choices updated to 11 after the first assertion is executed. Lines 4 and 7 demonstrate the very bad practice of modifying data in an assertion statement, which can trigger side effects. Regardless of whether an assertion error is thrown, turning on/off assertions potentially changes the value returned by checkClasswork(). At line 7, the assertion statement 12==11 evaluates to false, triggering an AssertionError and making Option D the correct answer. The main() method catches and rethrows the AssertionError. Like writing assertion statements that include side effects, catching Error is also considered a bad practice. Note that line 8 also would trigger an AssertionError, but it is never reached due to the exception on line 7.","A, C, E. BooleanSupplier, DoubleUnaryOperator, and ToLongBiFunction are all valid functional interfaces in java.util.function, making Options A, C, and E correct. Remember that BooleanSupplier is the only primitive functional interface in the API that does not use double, int, or long. For this reason, Option B is incorrect since char is not a supported primitive. Option D is incorrect because the functional interfaces that use Object are abbreviated to Obj. The correct name for this functional interface is ObjIntConsumer. That leaves Option F, which is incorrect. There is no built-in Predicate interface that takes three values.","B, F. The LackOfInformationException class does not compile, making Option A incorrect. The compiler inserts the default no-argument constructor into InformationException since the class does not explicitly define any. Since LackOfInformationException extends InformationException, the only constructor available in the parent class is the no-argument call to super(). For this reason, the constructor defined at line t1 does not compile because it calls a nonexistent parent constructor that takes a String value, and Option B is one of the correct answers. The other two constructors at lines t2 and t3 compile without issue, making Options C and D incorrect. Option E is also incorrect. The getMessage() method is inherited, so applying the @Override annotation is allowed by the compiler. Option F is the other correct answer. The LackOfInformationException is a checked exception because it inherits Exception but not RuntimeException.","C. First, a method reference uses two colons, so it should be Ready::getNumber. Second, you can\u2019t use generics with a primitive, so it should be Supplier<Double>. The rest of the code is correct, so Option C is correct.",'E. The class compiles, so Options A, B, and C are incorrect. It also does not produce an exception at runtime, so Option F is incorrect. The question reduces to whether or not the compute() method properly implements the fork/join framework in a multi-threaded manner. The compute() method returns "1" in the base case. In the recursive case, it creates two PassButter tasks. In order to use multiple concurrent threads, the first task should be started asynchronously with fork(). While that is processing, the second task should be executed synchronously with compute() with the results combined using the join() method. That\u2019s not what happens in this compute() method though. The first task is forked and then joined before the second task has even started. The result is that the current thread waits for the first task to completely finish before starting and completing the second task synchronously. At runtime, this would result in single-threaded-like behavior. Since this is a poor implementation of the fork/join framework, Option E is the correct answer.',"C. The filter() method passes two of the three elements of the stream through to the terminal operation. This is redundant since the terminal operation checks the same Predicate. There are two matches with the same value, so both anyMatch() and allMatch() return true, and Option C is correct.","E. First, Java looks for the requested resource bundle, which is AB_fr.class and then AB_fr.properties. This rules out Options A, B, and C. Next, Java looks for the default locale\u2019s resource bundle, which is AB_en.properties. This rules out Option D. Java looks for the default resource bundle. First, Java checks for a Java class file resource bundle and then moves on to the property file. Therefore, Option F is incorrect, and Option E is the answer.","D. This code attempts to use two terminal operations, forEach() and count(). Only one terminal operation is allowed, so the code does not compile, and Option D is correct. The author of this code probably intended to use peek() instead of forEach(). With this change, the answer would be Option A.","F. This code sets the default locale to Japanese and then tries to get a resource bundle for container in the pod package. Since there is not a Japanese resource bundle available, it uses the default resource bundle pod.container.properties. Line r1 successfully gets the value generic for the key name. Line r2 throws a MissingResourceException because there is not a key type in the default resource bundle. The English resource bundle has this key, but it is not in the resource bundle hierarchy.","D. Line c1 correctly creates a stream containing two streams. Line c2 does not compile since x is a stream, which does not have an isEmpty() method. Therefore, Option D is correct. If the filter() call was removed, flatMap() would correctly turn the stream into one with four Integer elements and max() would correctly find the largest one. The Optional returned would contain 33, so Option B would be the answer in that case.","A, C. A Locale uses lowercase letters for language codes and uppercase letters for country codes. It can consist of only a language, making Option A correct. If both a language and country code are present, the language code is first, making Option C correct.","D, E. While this code does not close the Statement and Connection, it does compile, making Option A incorrect. Java defaults to auto-commit, which means the update happens right away, making Option C incorrect. Option B is incorrect because either execute() or executeUpdate() is allowed for UPDATE SQL. The difference is the return type. The execute() method returns a boolean while the executeUpdate() method returns an int. The code also runs without error, making Options D and E the answer. And remember to always close your resources in real code to avoid a resource leak.","F. This is tricky. The equals() method in the Object class has a parameter of type Object. An overridden version is required to have the same type. The equals() method in Sticker is an overload rather than an override. Since there is an @Override annotation, the code does not compile.","C. The code does not compile, so Options A and B are incorrect. The code does not compile because the Sweater class is an inner class defined on the instance, which means it is only accessible to be extended and used inside an instance method or by a static method that has access to an instance of Wardrobe. Since dress() is a static method, the declaration of local inner class Jacket does not compile on line v1, making Option C the correct answer. The rest of the code, including the abstract class TShirt and anonymous inner class defined inside dress(), compile without issue. If the dress() method was updated to remove the static modifier, then the code would compile and print Starting...Insulation:20 at runtime, making Option A the correct answer.","E. The first statement is not true because Function takes two generic arguments and one input argument. If BiFunction was used instead of Function on line 7, then the code would compile correctly. The second statement is also not true because IntSupplier does not take any generic arguments. The third statement is not true as well, since Armor is an inner instance class. Without an instance of Sword in the static main() method, the call new Armor() on line 11 does not compile. For these reasons, all three statements are not true, making Option E the correct answer.","B, F. A deadlock and livelock both result in threads that cannot complete a task, but only in a livelock do the threads appear active, making Option A incorrect and Option B correct. Options C and D are incorrect because they do not apply to thread liveness. A race condition is an unexpected result when two threads, which should be run sequentially, are run at the same time, leading to an unexpected result, making Option E incorrect. Last but not least, starvation is caused by a single active thread that is perpetually denied access to a shared resource or lock, making Option F the other correct answer.","A, E. The first step is to convert both to GMT. We subtract the time zone offset to do this. In GMT, the Nairobi time is 14:00, which we get by subtracting 3 from 17. The Panama time is 15:00 because subtracting negative five from 10 gives us 15. Remember that subtracting a negative number is like adding a positive number. Since the Nairobi time is an hour before the Panama time, Options A and E are correct.","D. This code actually does compile. Line c1 is fine because the method uses the ? wildcard, which allows any collection. Line c2 is a standard method declaration. Line c3 looks odd, but it does work. The lambda takes one parameter and does nothing with it. Since there is no output, Option D is correct.","A, C. JDBC 3.0 drivers require a Class.forName() call. Since this is missing, Option A is correct, and Option B is incorrect. The Connection and Statement creation are correct, making Options E and F incorrect. Since the call to stmt.close() should be before the call to conn.close(), Option C is correct, and Option D is incorrect.","B. The code does not compile, so Options D and E are incorrect. The first compilation error is in the Finder interface declaration. Since all interfaces are implicitly abstract, they cannot be marked final. The second compilation error is the declaration of the find() method in the Waldo class. Since find() is inherited from the Finder interface, it is implicitly public. This makes the override of the method in Finder invalid because the lack of access modifier indicates package-level access. Since package-level access is more restrictive than the inherited method\u2019s access modifier, the overridden method does not compile in the Waldo class. For these two reasons, Option B is the correct answer.","F. When summing int primitives, the return type is also an int. Since a long is larger, you can assign the result to it, so line 7 is correct. All the primitive stream types use long as the return type for count(). Therefore, the code compiles, and Option E is incorrect. When actually running the code, line 8 throws an IllegalStateException because the stream has already been used. Both sum() and count() are terminal operations and only one terminal operation is allowed on the same stream. Therefore, Option F is the answer.","D. Line 34 does not compile because of an assignment and value mismatch. The r1 variable is a Runnable expression. While there is an ExecutorService.submit() that takes a Runnable expression, it returns Future<?> since the return type is void. This type is incompatible with the Future<Stream> assignment without an explicit cast, leading to a compiler error. Next, line 39 does not compile. The parallelStream() method is found in the Collection interface, not the Stream interface. Due to these two compilation errors, Option D is the correct answer.","F. Internationalization means the program is designed so it can be adapted for multiple languages. Localization means the program actually supports multiple locales. Since a localized application must first be internationalized, Option F is the answer. Extracted is not a word commonly used with respect to handling multiple languages.","C. The class compiles, making Option E incorrect. If /woods/forest exists, then the first branch of the if-then statement executes, printing true at runtime. On the other hand, if /woods/forest does not exist, the program will print true if /woods exists and false if /woods does not exist. Unlike mkdirs(), which if used would always return true in this case, mkdir() will return false if part of the parent path is missing. For this reason, Option C is correct, and Options A and B are incorrect. Finally, Option D is incorrect. This code is not expected to throw an exception at runtime. If the path could not be created, the mkdir() method just returns false.","D. Line 15 calls the method on line 9 since it is a Watch object. Line 16 is a SmartWatch object. However, the getName() method is not overridden in SmartWatch since the method signature is different. Therefore, the method on line 9 gets called again. That method calls getType(). Since this is a private method, it is not overridden and watch is printed twice. Option D is correct.","B. This code runs the loop six times, adding an hour to z each time. However, the first time is the repeated hour from daylight savings time. The time zone offset changes, but not the hour. This means the hour only increments five times. Adding that to 01:00 gives us 06:00 and makes Option B correct.","C. Both schedule method calls do not compile because these methods are only available in the ScheduledExecutorService interface, not the ExecutorService interface. Even if the correct reference type for service was used, along with a compatible Executors factory method, the scheduleWithFixedDelay() call would still not compile because it only contains a single numeric value. This method requires two long values, one for the initial delay and one for the period. The execute() method call compiles without issue because this method is available in the ExecutorService interface. For these reasons, only the third statement is true, making Option C the correct answer.","A, D, E. Any class that inherits from RuntimeException or Error is unchecked, while any class that does not is unchecked and must be declared or handled. AssertionError inherits from Error, while IllegalArgumentException and MissingResourceException inherit from RuntimeException. The remaining classes\u2014NotSerializableException, SQLException, and ParseException\u2014each inherit Exception but not RuntimeException, making Options A, D, and E the correct answers.","C, D. To be a valid functional interface, an interface must declare exactly one abstract method. Option A is incorrect, because CanClimb does not contain any abstract methods. Next, all interface methods not marked default or static are assumed to be abstract, and abstract methods cannot have a body. For this reason, CanDance does not compile, making Option B incorrect. Options C and D are correct answers because each contains exactly one abstract method. Option E is incorrect because it contains two abstract methods, since test() is assumed to be abstract.","A. A JDBC URL has three components separated by colons. None of these options uses the correct colon delimiter, making Option A the correct answer. If all the semicolons were changed to colons, Option D would be correct. I and V would still be incorrect because they don\u2019t begin with the JDBC protocol and magic driver name as the first two components.","F. The collector tries to use the number of characters in each stream element as the key in a map. This works fine for the first two elements, speak and bark, because they are of length 5 and 4, respectively. When it gets to meow, we have a problem because the length 4 is already used. Java requires a merge function be passed to toMap() as a third parameter if there are duplicate keys so it knows what to do. Since this is not supplied, the code throws an IllegalStateException due to the duplicate key, and Option F is correct.","D. The application does not compile, so Options A, B, and C are incorrect. The one and only compilation issue is that the ElectricBass class implements two interfaces that declare default methods with the same getVolume() signature. A class can inherit two default methods with the same signature but only if the class overrides the methods with its own version. Since ElectricBass does not override the method, the ElectricBass class does not compile. Since this is the only compilation issue, Option D is the correct answer. If the ElectricBass class did correctly override the getVolume() method, the rest of the code would compile without issue. In this case, there would be nothing printed at runtime. The main() method just declares a local inner class but does not create an instance of it, nor does it call any method on it, making Option C the correct answer.","A, B, C. Files.find() and Files.list() return a Stream<Path>, while Files.lines() returns a Stream<String>. For these reasons, Options A, B, and C are the correct answers. The NIO.2 Files class does not contain a listFiles() method, making Option D incorrect. There is a method named listFiles() in the java.io.File class, but it returns a File array. Option E is also incorrect because the Files.readAllLines() method returns a List<String>. Lastly, Option F is incorrect because Files.walkFileTree() uses a FileVisitor and returns a Path. If you were not familiar with the walkFileTree() method, then you could have ruled it out by knowing the signatures for Options A, B, and C."],a=function(e){return e.split(".")[0].split(", ").map(function(e){return function(e){switch(e[0]){case"A":return 0;case"B":return 1;case"C":return 2;case"D":return 3;case"E":return 4;case"F":return 5;case"G":return 6;case"H":return 7;case"I":return 8;default:throw new Error("no match character")}}(e)})},i=function(e,t){var o=a(t);if(Array.isArray(e))return e.map(function(e,t){return{answer:e,isCorrect:o.includes(t)}})},c=[{title:"Suppose the ResultSet is scrollable and contains 10 rows with values numbered from 1 to 10 in ascending order. What is true about the following? (Choose two.)",code:"<code>12:  rs.beforeFirst();</code>\n<code>13:  System.out.println(rs.relative(5));</code>\n<code>14:  System.out.println(rs.getInt(1));</code>\n<code>15:  System.out.println(rs.relative(-10));</code>\n<code>16:  System.out.println(rs.getInt(1));</code>\n<code>17:  System.out.println(rs.relative(5));</code>\n<code>18:  System.out.print(rs.getInt(1));</code>",answers:["It outputs true once.","It outputs true twice.","It outputs true three times.","It completes without throwing an exception.","It throws an exception at runtime."]},{title:"What is the result of the following?",code:'<code>public class PiDay {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      LocalDateTime pi = LocalDateTime.of(2017, 3, 14, 1, 59);</code>\n<code>      DateTimeFormatter formatter = DateTimeFormatter</code>\n<code>         .ofPattern("m.ddhhMM");</code>\n<code>      System.out.println(formatter.format(pi));</code>\n<code>   }</code>\n<code>}</code>',answers:["3.011459","3.140159","59.011459","59.140103","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which of the following are valid lambda expressions? (Choose three.)",code:null,answers:["() -> {}","(Double adder) -> {int y; System.out.print(adder); return adder;}","(Long w) -> {Long w=5; return 5;}","(int count, vote) -> count*vote","dog -> dog","name -> {name.toUpperCase()}"]},{title:"What is the result of compiling and running the following application?",code:'<code>package names;</code>\n<code>import java.util.*;</code>\n<code>import java.util.function.*;</code>\n<code>interface ApplyFilter {</code>\n<code>   void filter(List&lt;String&gt; input);</code>\n<code>}</code>\n<code>public class FilterBobs {</code>\n<code>   static Function&lt;String,String&gt; first = s \u2010&gt;        {System.out.println(s); return s;};</code>\n<code>   static Predicate second = t -&gt; "bob".equalsIgnoreCase(t);</code>\n<code>   public void process(ApplyFilter a, List&lt;String&gt; list) {</code>\n<code>      a.filter(list);</code>\n<code>   }</code>\n<code>   public static void main(String[] contestants) {</code>\n<code>      final List&lt;String&gt; people = new ArrayList&lt;&gt;();</code>\n<code>      people.add("Bob");</code>\n<code>      people.add("bob");</code>\n<code>      people.add("Jennifer");</code>\n<code>      people.add("Samantha");</code>\n<code>      final FilterBobs f = new FilterBobs();</code>\n<code>      f.process(q -&gt; {</code>\n<code>         q.removeIf(second);</code>\n<code>         q.forEach(first);</code>\n<code>      }, people);</code>\n<code>   }</code>\n<code>}</code>',answers:["It prints two lines.","It prints three lines.","One line of code does not compile.","Two lines of code do not compile.","Three lines of code do not compile.","The code compiles but prints an exception at runtime."]},{title:"What is the output of the following?",code:"<code>public class Compete {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Stream&lt;Integer&gt; is = Stream.of(8, 6, 9);</code>\n<code>      Comparator&lt;Integer&gt; c = (a, b) \u2010&gt; b \u2010 a;  // r1</code>\n<code>      is.sorted(c).forEach(System.out::print);  // r2</code>\n<code>  }</code>\n<code>}</code>",answers:["689","986","The code does not compile because of line r1.","The code does not compile because of line r2.","The code does not compile due to another line.","The code compiles but throws an exception at runtime."]},{title:"What is the output of the following application?",code:'<code>package tax;</code>\n<code>&nbsp;</code>\n<code>public class Accountant {</code>\n<code>   class AddingException extends Exception {};</code>\n<code>   class DividingException extends Exception {};</code>\n<code>   class UnexpectedException extends RuntimeException {};</code>\n<code>   public void doTaxes() throws Throwable {</code>\n<code>      try {</code>\n<code>         throw new IllegalStateException();</code>\n<code>      } catch (AddingException | DividingException e) {  // p1</code>\n<code>         System.out.println("Math Problem");</code>\n<code>      } catch (UnexpectedException | Exception f) {  // p2</code>\n<code>         System.out.println("Unknown Error");</code>\n<code>         throw f;</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] numbers) throws Throwable {</code>\n<code>      try {</code>\n<code>         new Accountant().doTaxes();</code>\n<code>      } finally {</code>\n<code>         System.out.println("All done!");</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["Math Problem","Unknown Problem","Unknown Problem followed by All done!","The code does not compile solely due to line p1.","The code does not compile solely due to line p2.","The code does not compile due to lines p1 and p2."]},{title:"What is the output of the following application?",code:'<code>1:  package drawing;</code>\n<code>2:  interface HasHue {String getHue();}</code>\n<code>3:  enum COLORS implements HasHue {</code>\n<code>4:     red {</code>\n<code>5:        public String getHue() {return "FF0000";}</code>\n<code>6:     }, green {</code>\n<code>7:        public String getHue() {return "00FF00";}</code>\n<code>8:     }, blue {</code>\n<code>9:        public String getHue() {return "0000FF";}</code>\n<code>10:    }</code>\n<code>11: }</code>\n<code>12: class Book {</code>\n<code>13:    static void main(String[] pencils) {}</code>\n<code>14: }</code>\n<code>15: final public class ColoringBook extends Book {</code>\n<code>16:    final void paint(COLORS c) {</code>\n<code>17:       System.out.print("Painting: "+c.getHue());</code>\n<code>18:    }</code>\n<code>19:    final public static void main(String[] crayons) {</code>\n<code>20:       new ColoringBook().paint(COLORS.green);</code>\n<code>21:    }</code>\n<code>22: }</code>',answers:["Painting: 00FF00","One line of code does not compile.","Two lines of code do not compile.","Three lines of code do not compile.","The code compiles but prints an exception at runtime.","None of the above"]},{title:"\xa0How many of the following can fill in the blank to make this code compile?",code:"<code>public boolean isItMyBirthday(LocalDateTime dateTime) {</code>\n<code>   ________________________________________  </code>\n<code>   return now.getMonth() == dateTime.getMonth()</code>\n<code>      &amp;&amp; now.getDayOfMonth() == dateTime.getDayOfMonth();</code>\n<code>}</code>",answers:["None","One","Two","Three","Four","Five"],ol:["LocalDate now = LocalDate.now();","LocalDate now = new LocalDate();","LocalDateTime now = LocalDateTime.now();","LocalDateTime now = new LocalDateTime();","ZonedDate now = ZonedDate.now();","ZonedDate now = new ZonedDate();"]},{title:"Which two can independently fill in the blank to output No dessert today? (Choose two.)",code:"<code>import java.util.*;</code>\n<code>public class Dessert {</code>\n<code>  public static void main(String[] yum) {</code>\n<code>    eatDessert(Optional.empty());</code>\n<code>  }</code>\n<code>  private static void eatDessert(Optional&lt;String&gt; opt) {</code>\n<code>     System.out.println(opt.__________);</code>\n<code>  }</code>\n<code>}</code>",answers:['get("No dessert today")','get(() -> "No dessert today")','orElse("No dessert today")','orElse(() -> "No dessert today")','orElseGet("No dessert today")','orElseGet(() -> "No dessert today")']},{title:"What is the output of the following?",code:'<code>public class InitOrder {</code>\n<code>   { System.out.print("1"); }</code>\n<code>   static { System.out.print("2"); }</code>\n<code>&nbsp;</code>\n<code>   public InitOrder() {</code>\n<code>      System.out.print("3");</code>\n<code>   }</code>\n<code><span epub:type="pagebreak" id="Page_391"></span>   public static void callMe() {</code>\n<code>      System.out.print("4");</code>\n<code>   }</code>\n<code>   public static void main(String[] args) {</code>\n<code>      callMe();</code>\n<code>      callMe();</code>\n<code>      System.out.print("5");</code>\n<code>   }</code>\n<code>}</code>',answers:["1223445","2445","22445","223445","2233445","None of the above"]},{title:"Which of the following cannot be instantiated directly by the caller using the constructor?",code:null,answers:["I","II","III","I, II","I, III","II, III"],ol:["Locale","Properties","ResourceBundle"]},{title:"What design pattern or principle is used in this class?",code:"<code>public class Daffodil {</code>\n<code>   int height;</code>\n<code>   public Daffodil(int height) {</code>\n<code>      this.height = height;</code>\n<code>   }</code>\n<code>   public int getHeight() {</code>\n<code>      return height;</code>\n<code>   }</code>\n<code>}</code>",answers:["Encapsulation","Immutability","Singleton","Both A and B","None of the above"]},{title:"What is the output of the following application? Assume the file system is available and able to be written to and read from.",code:'<code>package boat;</code>\n<code>import java.io.*;</code>\n<code>public class Cruise {</code>\n<code>   private int numPassengers = 1;</code>\n<code>   private transient String schedule = "NONE";</code>\n<code>   {numPassengers = 2;}</code>\n<code>   public Cruise() {</code>\n<code>      this.numPassengers = 3;</code>\n<code>      this.schedule = "Tropical Island";</code>\n<code>   }</code>\n<code>   public static void main(String... passengers) throws Exception {</code>\n<code>      try (ObjectOutputStream o = new ObjectOutputStream(</code>\n<code>            new FileOutputStream("ship.txt"))) {</code>\n<code>         Cruise c = new Cruise();</code>\n<code>         c.numPassengers = 4;</code>\n<code>         c.schedule = "Casino";</code>\n<code>         o.writeObject(c);</code>\n<code>      }</code>\n<code>      try (ObjectInputStream i = new ObjectInputStream(</code>\n<code>            new FileInputStream("ship.txt"))) {</code>\n<code>         Cruise c = i.readObject();</code>\n<code>         System.out.print(c.numPassengers+","+c.schedule);</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["2,NONE","3,null","4,Casino","4,null","The class does not compile.","The class compiles but throws an exception at runtime."]},{title:"Which of the following are JDBC interfaces in the java.sql package?",code:null,answers:["I, III","I, IV","II, III","II, IV","I, II, III","I, II, IV"],ol:["Driver","DriverManager","Query","ResultSet"]},{title:"Which of the following lambda expressions can be passed to a method that takes  IntUnaryOperator as an argument? (Choose three.)",code:null,answers:['v -> {System.out.print("Hello!"); return 2%1;}',"(Integer w) -> w.intValue()","(int j) -> (int)30L","(int q) -> q/3.1","(long x) -> (int)x","z -> z"]},{title:"Which of the following statements about InputStream and Reader are correct? (Choose two.)",code:null,answers:["One contains a read() method that returns a byte value, while the other contains a read() method that returns an int value.","Only one of them contains a flush() method.","Only one of them contains a skip() method.","They are both abstract classes.","They are both interfaces.","They can both be used to read character data."]},{title:"Fill in the blank so this code prints -1.",code:"<code>LocalDate xmas = LocalDate.of(2017,  12, 25);</code>\n<code>LocalDate blackFriday = LocalDate.of(2017, 11, 24);</code>\n<code>long monthsLeft = ChronoUnit.MONTHS.____________________;</code>\n<code>System.out.println(monthsLeft);</code>",answers:["between(blackFriday, xmas)","between(xmas, blackFriday)","minus(blackFriday, xmas)","minus(xmas, blackFriday)","plus(blackFriday, xmas)","plus(xmas, blackFriday)"]},{title:"Which statements about the following class are true?",code:'<code>package secure;</code>\n<code>import java.io.*;</code>\n<code>public class Login {</code>\n<code>   public void clearPassword(char[] password) {</code>\n<code>      for(int i=0; i&lt;password.length; i++) {</code>\n<code>         password[i] = 0;</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public String getPassword() {</code>\n<code>      Console c = System.console();</code>\n<code>      final char[] pass = c.readPassword("Enter your password: ");</code>\n<code>      StringBuilder sb = new StringBuilder();</code>\n<code>      for(char p : pass) {</code>\n<code>         sb.append(p);</code>\n<code>      }</code>\n<code>      clearPassword(pass);</code>\n<code>      return sb.toString();</code>\n<code>   }</code>\n<code>   public static void main(String[] webLogin) {</code>\n<code>      String pass = new Login().getPassword();</code>\n<code>   }</code>\n<code>}</code>',answers:["I only","II only","I and II only","I and III only","I, II, and III"],ol:["The class compiles.","The design protects the password by clearing it from memory after it is entered.","The class may throw an exception at runtime."]},{title:"Which of the following can fill in the blank to print out the numbers 161, 183, and 201 in any order?",code:'<code>class Runner {</code>\n<code>   private int numberMinutes;</code>\n<code>   public Runner(int n) {</code>\n<code>      numberMinutes = n;</code>\n<code>   }</code>\n<code><span epub:type="pagebreak" id="Page_395"></span>   public int getNumberMinutes() {</code>\n<code>      return numberMinutes;</code>\n<code>   }</code>\n<code>}</code>\n<code>public class Marathon {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Stream&lt;Runner&gt; runners = Stream.of(new Runner(183),</code>\n<code>         new Runner(161), new Runner(201));</code>\n<code>      OptionalInt opt = runners.____________________;</code>\n<code>   }</code>\n<code>}</code>',answers:["map (Runner::getNumberMinutes) .peek (System.out::println) .max()","mapToInt (Runner::getNumberMinutes) .peek (System.out::println) .max()","peek (System.out::println) .mapToInt (Runner::getNumberMinutes) .max()","peek (System.out::println) .mapToInt (Runner::getNumberMinutes) .max()","None of the above"]},{title:"What is the output of the following application?",code:'<code>1:  package fruit;</code>\n<code>2:  enum Season {</code>\n<code>3:     SPRING(1), SUMMER(2), FALL(3), WINTER(4)</code>\n<code>4:     public Season(int orderId) {}</code>\n<code>5:  }</code>\n<code>6:  public class PickApples {</code>\n<code>7:     public static void main(String... orchard) {</code>\n<code>8:        final Season s = Season.FALL;</code>\n<code>9:        switch(s) {</code>\n<code>10:          case 3:</code>\n<code>11:             System.out.println("Time to pick!");</code>\n<code>12:          default:</code>\n<code>13:             System.out.println("Not yet!");</code>\n<code>14:       }</code>\n<code>15:    }</code>\n<code>16: }</code>',answers:["Time to pick!","Time to pick! followed by Not yet!","One line of code does not compile.","Two lines of code do not compile.","Three lines of code do not compile.","The code compiles but prints an exception at runtime."]},{title:"Which of the following expressions, inserted simultaneously into both blanks, allow the application to compile? (Choose three.)",code:"<code>package spooky;</code>\n<code>import java.util.function.*;</code>\n<code>abstract class Phantom {</code>\n<code>   public void bustLater(DoubleConsumer buster, double value) {</code>\n<code>      buster.accept(value);</code>\n<code>   }</code>\n<code>}</code>\n<code>public class Ghost extends Phantom {</code>\n<code>   public void bustNow(Consumer&lt;Double&gt; buster, double value) {</code>\n<code>      buster.accept(value);</code>\n<code>   }</code>\n<code>   void call() {</code>\n<code>      double value = 10;</code>\n<code>      bustNow(__________,value);</code>\n<code>      bustLater(__________,value);</code>\n<code>   }</code>\n<code>}</code>",answers:["System.out::print","a -> {System.out.println(a.intValue());}","g -> {System.out.println();}","u -> System.out.println((long)u)","v -> System.out.print(v)","w -> System.out::println"]},{title:"What is the output of the following?",code:'<code>package counter;</code>\n<code>import java.util.*;</code>\n<code>&nbsp;</code>\n<code>public class CountResource extends ListResourceBundle {</code>\n<code><span epub:type="pagebreak" id="Page_397"></span>   private int count = 0;</code>\n<code>&nbsp;</code>\n<code>   @Override</code>\n<code>   protected Object[][] getContents() {</code>\n<code>      return new Object[][] { { "count", ++count } };</code>\n<code>   }</code>\n<code>   public static void main(String[] args) {</code>\n<code>      ResourceBundle rb = ResourceBundle.getBundle("counter.CountResource");</code>\n<code>      System.out.println(rb.getString("count") + " " + rb.getString("count"));</code>\n<code>   }</code>\n<code>}</code>',answers:["0 0","0 1","1 1","1 2","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"In most of the United States, daylight savings time ends on November 5, 2017 at 02:00 a.m., and we repeat that hour. What is the output of the following?",code:'<code>import java.time.*;</code>\n<code>&nbsp;</code>\n<code>public class FallBack {</code>\n<code>&nbsp;</code>\n<code>   public static void main(String[] args) {</code>\n<code>      LocalDate localDate = LocalDate.of(2017, 10, 5);</code>\n<code>      LocalTime localTime = LocalTime.of(1, 0);</code>\n<code>      ZoneId zone = ZoneId.of("America/New_York");</code>\n<code>      ZonedDateTime z = ZonedDateTime.of(localDate, localTime, zone);</code>\n<code>&nbsp;</code>\n<code>      for (int i = 0; i &lt; 6; i++)</code>\n<code>         z = z.plusHours(1);</code>\n<code>&nbsp;</code>\n<code>      System.out.println(z.getHour());</code>\n<code>   }</code>\n<code>}</code>',answers:["5","6","7","The code does not compile.","The code compiles, but throws an exception at runtime."]},{title:"Assume the /environment directory exists and contains a file with a symbolic link to the /environment directory. In addition, assume all files within the directory are fully accessible. What is the result of executing the following program?",code:'<code>import java.nio.file.*;</code>\n<code>import java.nio.file.attribute.*;</code>\n<code>public class SearchEnvironment {</code>\n<code>   public static void accessFile(Path p, long timeEpoch) {</code>\n<code>      try {</code>\n<code>         Files.readAttributes(p, BasicFileAttributes.class)</code>\n<code>            .setTimes(null, null, FileTime.fromMillis(timeEpoch));</code>\n<code>      } catch (Throwable e) {</code>\n<code>      } finally {}</code>\n<code>   }</code>\n<code>   public static final void main(String[] unused) throws Exception {</code>\n<code>      Path w = Paths.get("/environment");</code>\n<code>      Files.walk(w)</code>\n<code>         .forEach(q -&gt; accessFile(q,System.currentTimeMillis()));</code>\n<code>   }</code>\n<code>}</code>',answers:["The code does not compile.","The program exits after successfully updating the creation time of files within the directory.","The program exits after successfully updating the last accessed time of files within the directory.","The program compiles but throws an exception at runtime.","The program enters an infinite loop and hangs at runtime."]},{title:"Which command causes the following class to throw an AssertionError at runtime?",code:"<code>public class Watch {</code>\n<code>   private static final short DEFAULT_HOUR = 12;</code>\n<code>   private Watch() {</code>\n<code>      super();</code>\n<code>   }</code>\n<code>   int checkHour() {</code>\n<code>      assert DEFAULT_HOUR &gt; 12;</code>\n<code>      return DEFAULT_HOUR;</code>\n<code>   }</code>\n<code>   public static void main(String... ticks) {</code>\n<code>      new Watch().checkHour();</code>\n<code>   }</code>\n<code>}</code>",answers:["java -da Watch","java -ea:Watch -da Watch","java -ea -da:Watch Watch","java -enableassert Watch","None of the above since the Watch class does not compile."]},{title:"What is the output of the following application?",code:'<code>package rope;</code>\n<code>import java.util.concurrent.*;</code>\n<code>import java.util.stream.IntStream;</code>\n<code>public class Jump {</code>\n<code>   private static void await(CyclicBarrier b) {</code>\n<code>      try {</code>\n<code>         b.await();</code>\n<code>      } catch (InterruptedException | BrokenBarrierException e) {</code>\n<code>         e.printStackTrace();</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] chalk) {</code>\n<code>      ExecutorService s = Executors.newFixedThreadPool(4);</code>\n<code>      final CyclicBarrier b = new CyclicBarrier(4,</code>\n<code>         () -&gt; System.out.print("Jump!"));</code>\n<code>      IntStream</code>\n<code>         .iterate(1, q -&gt; 2)</code>\n<code>         .limit(10)</code>\n<code>         .forEach(q -&gt; s.execute(() \u2010&gt;await(b)));</code>\n<code>      s.shutdown();</code>\n<code>   }</code>\n<code>}</code>',answers:["Jump! is printed and exits.","Jump! is printed twice and exits.","The code does not compile.","The output cannot be determined ahead of time.","The program hangs indefinitely at runtime because the IntStream is not parallel.","None of the above"]},{title:"What is the output of the following code snippet? Assume the two directories referenced both exist and are symbolic links to the same location within the file system.",code:'<code>if(Files.isSameFile("/salad/carrot", "/fruit/apple"))</code>\n<code>   System.out.println("Same!");</code>\n<code>else System.out.println("Different!");</code>',answers:["Same!","Different!","The code does not compile.","The code compiles but throws an exception at runtime.","None of the above"]},{title:"Which can fill in the blank JavaProgrammerCert class to compile and logically complete the code? (Choose two.)",code:"<code>class JavaProgrammerCert extends Exam {</code>\n<code>   private Exam oca;</code>\n<code>   private Exam ocp;</code>\n<code>   // assume getters and setters are here</code>\n<code>   ______________________________________  </code>\n<code>}</code>\n<code>public class Exam {</code>\n<code>   boolean pass;</code>\n<code>   protected boolean passed() {</code>\n<code>     return pass;</code>\n<code>   }</code>\n<code>}</code>",answers:["boolean passed() { return oca.pass && ocp.pass; }","boolean passed() { return oca.passed() && ocp.passed(); }","boolean passed() { return super.passed(); }","public boolean passed() { return oca.passed() && ocp.passed(); }","public boolean passed() { return oca.pass && ocp.pass; }","public boolean passed() { return super.passed(); }"]},{title:"Which statements about overriding a method are correct? (Choose two.)",code:null,answers:["An overridden method must not throw a narrower version of any checked exception thrown by the inherited method.","An overridden method must use a return type that is covariant with the inherited method.","An overridden method must use a different set of input arguments as the inherited method.","Overridden methods must use an access modifier at least as broad as their inherited method.","It is possible to override private and static methods.","The @Override annotation is required anytime a method is overridden."]},{title:"Which of the following can be independently inserted into the blank so the code can run without error for at least one SQL query?",code:"<code>private static void choices(Connection conn, String sql)       throws SQLException {</code>\n<code>   try (Statement stmt = conn.createStatement();</code>\n<code>       ResultSet rs = stmt.executeQuery(sql)) {</code>\n<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;____________________</code>\n<code>       </code>\n<code>   }</code>\n<code>}</code>",answers:["II","III","I and III","II and III","I, II, and III","None of the above"],ol:["System.out.println(rs.getInt(1));","rs.next(); System.out.println(rs.getInt(1));","if (rs.next()) System.out.println(rs.getInt(1));"]},{title:"Starting with DoubleBinaryOperator and going downward, fill in the values for the table.",code:null,answers:["1, 0, 0, 0, 2","1, 2, 1, 0, 1","2, 1, 0, 1, 2","2, 1, 1, 0, 1","2, 1, 2, 0, 2","3, 0, 2, 1, 1"]},{title:"What is a possible output of the following?",code:'<code>LocalDate trainDay = LocalDate.of(2017, 5, 13);</code>\n<code>LocalTime time = LocalTime.of(10, 0);</code>\n<code>ZoneId zone = ZoneId.of("America/Los_Angeles");</code>\n<code>ZonedDateTime zdt = ZonedDateTime.of(trainDay, time, zone);</code>\n<code>Instant instant = zdt.toInstant();</code>\n<code>instant = instant.plus(1, ChronoUnit.YEARS);</code>\n<code>System.out.println(instant);</code>',answers:["2017-05-13T10:00-07:00[America/Los_Angeles]","2017-05-13T17:00:00Z","2018-05-13T10:00-07:00[America/Los_Angeles]","2018-05-13T17:00:00Z","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"How many lines does the following output?",code:'<code>import java.util.stream.*;</code>\n<code>&nbsp;</code>\n<code>class Blankie {</code>\n<code>   String color;</code>\n<code>   boolean isPink() {</code>\n<code>      return "pink".equals(color);</code>\n<code>   }</code>\n<code>}</code>\n<code>public class PreSchool {</code>\n<code>   public static void main(String[] args) {</code>\n<code>     Blankie b1 = new Blankie();</code>\n<code>     Blankie b2 = new Blankie();</code>\n<code>     b1.color = "pink";</code>\n<code>     Stream.of(b1, b2).filter(Blankie::isPink).forEach(System.out::println);</code>\n<code>   }</code>\n<code>}</code>',answers:["None","One","Two","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which are the minimum changes needed to make this class immutable?",code:"<code>1:   public class Tree {</code>\n<code>2:      String species;</code>\n<code>3:      public Tree(String species) {</code>\n<code>4:         this.species = species;</code>\n<code>5:      }</code>\n<code>6:      public String getSpecies() {</code>\n<code>7:        return species;</code>\n<code>8:      }</code>\n<code>9:      private final void setSpecies(String newSpecies) {</code>\n<code>10:        species = newSpecies;</code>\n<code>11:    }</code>\n<code>12:  }</code>",answers:["None. It is already immutable.","I","I and II","I and III","II and III","I, II, and III"],ol:["Make species private and final.","Make the getter method final.","Remove the setter method."]},{title:"Let\u2019s say you needed to write a large List of Student objects to a data file. Which three concrete classes, chained together, would best accomplish this? (Choose three.)",code:null,answers:["BufferedFileOutputStream","BufferedOutputStream","FileOutputStream","FileWriter","ObjectOutputStream","OutputStream"]},{title:"Which statements when inserted independently will throw an exception at runtime? (Choose two.)",code:"<code>ArrayDeque&lt;Integer&gt; d = new ArrayDeque&lt;&gt;();</code>\n<code>d.offer(18);</code>\n<code>// INSERT CODE HERE</code>",answers:["d.peek(); d.peek();","d.poll(); d.poll();","d.pop(); d.pop();","d.remove(); d.remove();"]},{title:"What is the output of the following code snippet?",code:'<code>11: Path x = Paths.get(".","song","..","/note");</code>\n<code>12: Path y = Paths.get("/dance/move.txt");</code>\n<code>13: x.normalize();</code>\n<code>14: System.out.println(x.resolve(y));</code>\n<code>15: System.out.println(y.relativize(x));</code>',answers:[" /./song/../note/dance /move.txt/dance/move.txt"," /dance/move.txt/dance /move.txt/./song/../note"," /dance/move.txt/dance /move.txt/note"," /note/dance/move.txt ../dance/move.txt/song"," The code does not compile."," The code compiles but an exception is thrown at runtime."]},{title:"Given the following class, how many lines contain compilation errors?",code:'<code>package field;</code>\n<code>import java.io.*;</code>\n<code>class StungException extends Exception {}</code>\n<code>class Suit implements Closeable {</code>\n<code>   public void close() throws IOException {}</code>\n<code>}</code>\n<code>public class BeeCatcher {</code>\n<code>   public static void main(String... bees) {</code>\n<code>      try (Suit s = new Suit(), Suit t = new Suit()) {</code>\n<code>         throw new StungException();</code>\n<code><span epub:type="pagebreak" id="Page_405"></span>      } catch (Exception e) {</code>\n<code>      } catch (StungException e) {</code>\n<code>      } finally {</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["One","Two","Three","Four","None. The code compiles as is."]},{title:"What is the output of the following application?",code:'<code>package homework;</code>\n<code>import java.util.*;</code>\n<code>import java.util.stream.*;</code>\n<code>public class QuickSolution {</code>\n<code>   public static int findFast(Stream&lt;Integer&gt; s) {</code>\n<code>      return s.findAny().get();</code>\n<code>   }</code>\n<code>   public static int findSlow(Stream&lt;Integer&gt; s) {</code>\n<code>      return s.parallel().findFirst().get();</code>\n<code>   }</code>\n<code>   public static void main(String[] pencil) {</code>\n<code>      Stream&lt;Integer&gt; s1 = Arrays.asList(1,2,3,4,5).stream();</code>\n<code>      Stream&lt;Integer&gt; s2 = Arrays.asList(1,2,3,4,5).stream();</code>\n<code>      int val1 = findFast(s1);</code>\n<code>      int val2 = findSlow(s2);</code>\n<code>      System.out.print(val1+" "+val2);</code>\n<code>   }</code>\n<code>}</code>',answers:["1 1","3 1","The answer cannot be determined until runtime.","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Given this property file used to load the Properties object props and this code snippet, what is the output?",code:'<code>mystery=bag</code>\n<code>type=paper</code>\n<code>&nbsp;</code>\n<code>18:  System.out.print(props.getDefaultProperty("mystery", "?"));</code>\n<code>19:  System.out.print(" ");</code>\n<code>20:  System.out.print(props.getDefaultProperty("more", "?"));</code>',answers:["bag","bag null","bag ?","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which statements about try-with-resources are true? (Choose two.)",code:null,answers:["Any resource used must implement Closeable.","If more than one resource is used, then the order in which they are closed is the reverse of the order in which they were created.","If the try block and close() method both throw an exception, the one thrown by the try block is suppressed.","Neither a catch nor a finally block is required.","The close() method of the resources must throw a checked exception."]},{title:"How many lines fail to compile?",code:"<code>class Roller&lt;E extends Wheel&gt; {</code>\n<code>   public void roll(E e) { }</code>\n<code>}</code>\n<code>class Wheel { }</code>\n<code>class CartWheel extends Wheel { }</code>\n<code>&nbsp;</code>\n<code>public class RollingContest {</code>\n<code>   Roller&lt;CartWheel&gt; wheel1 = new Roller&lt;CartWheel&gt;();</code>\n<code>   Roller&lt;Wheel&gt; wheel2 = new Roller&lt;CartWheel&gt;();</code>\n<code>   Roller&lt;? extends Wheel&gt; wheel3 = new Roller&lt;CartWheel&gt;();</code>\n<code>   Roller&lt;? extends Wheel&gt; wheel4 = new Roller&lt;Wheel&gt;();</code>\n<code>   Roller&lt;? super Wheel&gt; wheel5 = new Roller&lt;CartWheel&gt;();</code>\n<code>   Roller&lt;? super Wheel&gt; wheel6 = new Roller&lt;Wheel&gt;();</code>\n<code>}</code>",answers:["One","Two","Three","Four","Five","Six"]},{title:"Which are the minimum changes needed to properly implement the singleton pattern?",code:"<code>1:   public class Bookmark {</code>\n<code>2:      private static Bookmark bookmark;</code>\n<code>3:      private int pageNumber;</code>\n<code>4:      static {</code>\n<code>5:        bookmark = new Bookmark();</code>\n<code>6:      }</code>\n<code>7:      public static Bookmark getInstance() {</code>\n<code>8:         return bookmark;</code>\n<code>9:      }</code>\n<code>10:     public int getPageNumber() {</code>\n<code>11:        return pageNumber;</code>\n<code>12:     }</code>\n<code>13:     public void setPageNumber(int newNumber) {</code>\n<code>14:        pageNumber = newNumber;</code>\n<code>15:     }</code>\n<code>16:  }</code>",answers:["None. It is already a singleton.","I","I and II","I and III","II and III","I, II, and III"],ol:["Add a private constructor.","Remove the setter method.","Remove the static block and change line 2 to instantiate Bookmark."]},{title:"Given an updatable ResultSet that contains the following and this code, what does the code snippet output?",code:'<code><span epub:type="pagebreak" id="Page_408"></span>rs.afterLast();</code>\n<code>rs.previous();</code>\n<code>rs.updateInt(2, 10);</code>\n<code>&nbsp;</code>\n<code>rs = stmt.executeQuery("select * from pens where color = \'red\'");</code>\n<code>while (rs.next()) {</code>\n<code>   System.out.println(rs.getInt(2));</code>\n<code>}</code>',answers:["0","10","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which statements describe a java.io stream class and cannot be applied to a  java.util.stream.Stream class? (Choose three.)",code:null,answers:["Can be used with try-with-resources statement","Includes a class or set of classes used solely for working with character data","Requires all data objects to implement Serializable","Some classes contain a flush() method.","Some classes contain a method to skip over data.","Some classes contain a method to sort the data."]},{title:"Bill wants to create a program that reads all of the lines of all of his books using NIO.2. Unfortunately, Bill may have made a few mistakes writing his program. How many lines of the following class contain compilation errors?",code:'<code>1:  package bookworm;</code>\n<code>2:  import java.io.*;</code>\n<code>3:  import java.nio.file.*;</code>\n<code>4:  public class ReadEverything {</code>\n<code>5:     public void readFile(Path p) {</code>\n<code>6:        try {</code>\n<code>7:           Files.readAllLines(p)</code>\n<code>8:           .parallel()</code>\n<code>9:           .forEach(System.out::println);</code>\n<code>10:       } catch (Exception e) {}</code>\n<code>11:    }</code>\n<code>12:    public void read(Path directory) throws Exception {</code>\n<code>13:       Files.walk(directory)</code>\n<code>14:          .filter(p -&gt; File.isRegularFile(p))</code>\n<code>15:          .forEach(x -&gt; readFile(x));</code>\n<code><span epub:type="pagebreak" id="Page_409"></span>16:    }</code>\n<code>17:    public static void main(String... books) throws IOException {</code>\n<code>18:       Path p = Path.get("collection");</code>\n<code>19:       new ReadEverything().read(p);</code>\n<code>20:    }</code>\n<code>21: }</code>',answers:["None. Bill\u2019s implementation is correct.","One","Two","Three","Four","Five"]},{title:"Assuming the following class is concurrently accessed by numerous threads, which statement about the CountSheep class is correct?",code:"<code>package fence;</code>\n<code>import java.util.concurrent.atomic.*;</code>\n<code>public class CountSheep {</code>\n<code>   private static AtomicInteger counter = new AtomicInteger();</code>\n<code>   private Object lock = new Object();</code>\n<code>   public synchronized int increment1() {</code>\n<code>      return counter.incrementAndGet();</code>\n<code>   }</code>\n<code>   public static synchronized int increment2() {</code>\n<code>      return counter.getAndIncrement();</code>\n<code>   }</code>\n<code>   public int increment3() {</code>\n<code>      synchronized(lock) {</code>\n<code>         return counter.getAndIncrement();</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>",answers:["The class is thread-safe only if increment1() is removed.","The class is thread-safe only if increment2() is removed.","The class is thread-safe only if increment3() is removed.","The class is already thread-safe.","The class does not compile.","The class compiles but may throw an exception at runtime."]},{title:"Which of the following are not required parameters for the NIO.2 Files.find() method? (Choose two.)",code:null,answers:["BiPredicate","FileVisitOption...","int","long","Path"]},{title:"Which statements are correct? (Choose two.)",code:null,answers:["A Comparable implementation is often implemented by a lambda.","A Comparable object has a compare() method.","The compare() and compareTo() methods have the same contract for the return value.","There can be multiple Comparator implementations for the same class.","Two objects that return true for equals() will always return 0 when passed to  compareTo()."]},{title:"What is the output of the following code snippet, assuming none of the files referenced exist within the file system?",code:'<code>Path t1 = Paths.get("/sky/.././stars.exe");</code>\n<code>Path t2 = Paths.get("/stars.exe");</code>\n<code>Path t3 = t1.resolve(t2);</code>\n<code>&nbsp;</code>\n<code>boolean b1 = t1.equals(t2);</code>\n<code>boolean b2 = t1.normalize().equals(t2);</code>\n<code>boolean b3 = Files.isSameFile(t1.normalize(),t2);</code>\n<code>boolean b4 = Files.isSameFile(t2,t3);</code>\n<code>&nbsp;</code>\n<code>System.out.print(b1+","+b2+","+b3+","+b4);</code>',answers:["false,false,true,true","false,true,true,false","false,true,true,true","true,false,true,false","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Let\u2019s say we have a Reader instance that will produce the characters with the numeric values {1,2,3,4,5,6,7}. Which of the following are possible outcomes of executing the checkLottoNumbers() method with this Reader instance? (Choose two.)",code:'<code>23: public String checkLottoNumbers(Reader r) throws IOException {</code>\n<code>24:    r.read();r.skip(1);</code>\n<code>25:    r.mark(5);</code>\n<code><span epub:type="pagebreak" id="Page_411"></span>26:    r.skip(1);</code>\n<code>27:    r.reset();</code>\n<code>28:    return r.read()+"-"+r.read(new char[5]);</code>\n<code>29: }</code>',answers:["An IOException on line 25","An IOException on line 27","'c'-4 is returned.","'d'-3 is returned.","3-4 is returned.","4-3 is returned."]},{title:"Fill in the blanks: The name of the abstract method in the Function interface __________ is , while the name of the abstract method in the Consumer  interface is__________\xa0.",code:null,answers:["accept(), apply()","accept(), get()","apply(), accept()","apply(), apply()","apply(), test()"]},{title:"Assuming the following program is executed with assertions enabled, which is the first line to throw an exception at runtime?",code:'<code>1:  package school;</code>\n<code>2:  public class Teacher {</code>\n<code>3:     public int checkClasswork(int choices) {</code>\n<code>4:        assert choices++==10 : 1;</code>\n<code>5:        assert true!=false : new StringBuilder("Answer2");</code>\n<code>6:        assert(null==null) : new Object();</code>\n<code>7:        assert ++choices==11 : "Answer4";</code>\n<code>8:        assert 2==3 : "";</code>\n<code>9:        return choices;</code>\n<code>10:    }</code>\n<code>11:    public final static void main(String... students) {</code>\n<code>12:       try {</code>\n<code>13:          new Teacher().checkClasswork(10);</code>\n<code>14:       } catch (Error e) {</code>\n<code>15:          System.out.print("Bad idea");</code>\n<code>16:          throw e;</code>\n<code>17:       }</code>\n<code>18:    }</code>\n<code>19: }</code>',answers:["Line 4","Line 5","Line 6","Line 7","Line 8","None of the above since the class does not compile"]},{title:"Which of the following are valid functional interfaces in the java.util.function  package? (Choose three.)",code:null,answers:["BooleanSupplier","CharSupplier","DoubleUnaryOperator","ObjectIntConsumer","ToLongBiFunction","TriPredicate"]},{title:"Which statements about the following class are correct? (Choose two.)",code:'<code>package knowledge;</code>\n<code>class InformationException extends Exception {}</code>\n<code>public class LackOfInformationException extends InformationException {</code>\n<code>   public LackOfInformationException() {  // t1</code>\n<code>      super("");</code>\n<code>   }</code>\n<code>   public LackOfInformationException(String s) {  // t2</code>\n<code>      this(new Exception(s));</code>\n<code>   }</code>\n<code>   public LackOfInformationException(Exception c) {  // t3</code>\n<code>      super();</code>\n<code>   }</code>\n<code>   @Override public String getMessage() {</code>\n<code>      return "lackOf";</code>\n<code>   }</code>\n<code>}</code>',answers:["LackOfInformationException compiles without issue.","The constructor declared at line t1 does not compile.","The constructor declared at line t2 does not compile.","The constructor declared at line t3 does not compile.","The getMessage()method does not compile because of the @Override annotation.","LackOfInformationException is a checked exception."]},{title:"How many changes do you need to make in order for this code to compile?",code:"<code>public class Ready {</code>\n<code>   private static double getNumber() {</code>\n<code>      return .007;</code>\n<code>   }</code>\n<code>   public static void math() {</code>\n<code>      Supplier&lt;double&gt; s = Ready:getNumber;</code>\n<code>      double d = s.get();</code>\n<code>      System.out.println(d);</code>\n<code>   }</code>\n<code>}</code>",answers:["None","One","Two","Three","Four"]},{title:"Which statement about the following class is correct?",code:'<code>package robot;</code>\n<code>import java.util.concurrent.*;</code>\n<code>public class PassButter extends RecursiveTask&lt;String&gt; {  // j1</code>\n<code>   final int remainder;</code>\n<code>   public PassButter(int remainder) {  // j2</code>\n<code>      this.remainder = remainder;</code>\n<code>   }</code>\n<code>   @Override</code>\n<code>   protected String compute() {</code>\n<code>      if (remainder &lt;= 1)</code>\n<code>         return "1";</code>\n<code>      else {</code>\n<code>         PassButter otherTask = new PassButter(remainder - 1);</code>\n<code>         String otherValue = otherTask.fork().join();  // j3</code>\n<code>         return otherValue</code>\n<code>            + new PassButter(remainder - 2).compute();</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] purpose) {</code>\n<code>      ForkJoinPool pool = new ForkJoinPool();</code>\n<code>      ForkJoinTask&lt;?&gt; task = new PassButter(10);</code>\n<code><span epub:type="pagebreak" id="Page_414"></span>      System.out.print(pool.invoke(task));</code>\n<code>      pool.shutdown();</code>\n<code>   }</code>\n<code>}</code>',answers:["The code does not compile due to line j1.","The code does not compile due to line j2.","The code does not compile due to line j3.","The code compiles and properly implements the fork/join framework in a multi-threaded manner.","The code compiles but does not implement the fork/join framework in a proper multi-threaded manner.","The class compiles and prints an exception at runtime."]},{title:"Which can fill in the blank so this code outputs true?",code:"<code>import java.util.function.*;</code>\n<code>import java.util.stream.*;</code>\n<code>&nbsp;</code>\n<code>public class HideAndSeek {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Stream&lt;Boolean&gt; hide = Stream.of(true, false, true);</code>\n<code>      Predicate&lt;Boolean&gt; pred = b \u2010&gt; b;</code>\n<code>      boolean found = hide.filter(pred).__________(pred);</code>\n<code>      System.out.println(found);</code>\n<code>   }</code>\n<code>}</code>",answers:["Only anyMatch()","Only allMatch()","Both anyMatch() and allMatch()","Only noneMatch()","The code does not compile with any of these options."]},{title:"Given the following code, Java will try to find a matching resource bundle. Which order will Java search to find a match?",code:'<code>Locale.setDefault(new Locale("en"));</code>\n<code>ResourceBundle.getBundle("AB", new Locale("fr"));</code>',answers:["AB.class, AB.properties, AB_en.properties, AB_fr.properties","AB.properties, AB.class, AB_en.properties, AB_fr.properties","AB_en.properties, AB_fr.properties, AB.class, AB.properties","AB_fr.properties, AB.class, AB.properties, AB_en.properties","AB_fr.properties, AB_en.properties, AB.class, AB.properties","AB_fr.properties, AB_en.properties, AB.properties, AB.class"]},{title:"What is the result of the following?",code:"<code>Set&lt;Integer&gt; dice = new TreeSet&lt;&gt;();</code>\n<code>dice.add(6);</code>\n<code>dice.add(6);</code>\n<code>dice.add(4);</code>\n<code>dice.stream().filter(n -&gt; n != 4).forEach(System.out::println).count();</code>",answers:["It prints just one line.","It prints one line and then the number 3.","There is no output.","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Given the following two property files in the pod package, what does the following class output?",code:'<code>pod.container.properties</code>\n<code>name=generic</code>\n<code>number=2</code>\n<code>pod.container_en.properties</code>\n<code>name=Docker</code>\n<code>type=container</code>\n<code>package pod;</code>\n<code>import java.util.*;</code>\n<code>public class WhatKind {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Locale.setDefault(new Locale("ja"));</code>\n<code>      ResourceBundle rb = ResourceBundle.getBundle("pod.container");</code>\n<code>      String name = rb.getString("name");    // r1</code>\n<code>      String type = rb.getString("type");    // r2</code>\n<code>      System.out.println(name + " " + type);   }</code>\n<code>}</code>',answers:["Docker container","generic container","generic null","The code does not compile.","Line r1 throws an exception.","Line r2 throws an exception."]},{title:"What is the result of the following?",code:"<code>import java.util.stream.*;</code>\n<code>public class StreamOfStreams {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Integer result =</code>\n<code>         Stream.of(getNums(9, 8), getNums(22, 33))  // c1</code>\n<code>         .filter(x -&gt; !x.isEmpty())                 // c2</code>\n<code>         .flatMap(x -&gt; x)                           // c3</code>\n<code>         .max((a, b) -&gt; a \u2010 b)                      // c4</code>\n<code>         .get();</code>\n<code>      System.out.println(result);</code>\n<code>   }</code>\n<code>   private static Stream&lt;Integer&gt; getNums(int num1, int num2) {</code>\n<code>      return Stream.of(num1, num2);</code>\n<code>   }</code>\n<code>}</code>",answers:["The code compiles and outputs 8.","The code compiles and outputs 33.","The code does not compile due to line c1.","The code does not compile due to line c2.","The code does not compile due to line c3.","The code does not compile due to line c4."]},{title:"Which of the following shows a valid Locale format? (Choose two.)",code:null,answers:["de","DE","de_DE","DE_de"]},{title:"What is true of the following if the music database exists and contains a songs table with one row when run using a JDBC 4.0 driver? (Choose two.)",code:'<code>import java.sql.*;</code>\n<code>public class Music {</code>\n<code>   public static void main(String[] args) throws Exception {</code>\n<code>      String url = "jdbc:derby:music";</code>\n<code>      Connection conn = DriverManager.getConnection(url);</code>\n<code>      Statement stmt = conn.createStatement();</code>\n<code>      stmt.execute("update songs set name = \'The New Song\'");</code>\n<code>   }</code>\n<code>}</code>',answers:["The code does not compile.","The code does not update the database because it calls execute() rather than  executeUpdate().","The code does not update the database because the Statement is never closed.","The code runs without error.","The execute() method returns a boolean.","The execute() method returns an int."]},{title:"How many of the following pairs of values can fill in the blanks to comply with the contract of the hashCode() and equals() methods?",code:"<code>class Sticker {</code>\n<code>   @Override</code>\n<code>   public int hashCode() {</code>\n<code>      return _______________ ;</code>\n<code>   }</code>\n<code>   @Override</code>\n<code>   public boolean equals(Sticker o) {</code>\n<code>      return _______________;</code>\n<code>   }</code>\n<code>}</code>",answers:["None","One","Two","Three","Four","None of the above. The code does not compile with any of the options."],ol:["5, false","5, true","new Random().nextInt(), false","new Random().nextInt(), true"]},{title:"What is the output of the following application?",code:'<code>package winter;</code>\n<code>&nbsp;</code>\n<code>abstract class TShirt {</code>\n<code>   abstract int insulate();</code>\n<code>   public TShirt() {</code>\n<code>      System.out.print("Starting...");</code>\n<code>   }</code>\n<code>}</code>\n<code><span epub:type="pagebreak" id="Page_418"></span>public class Wardrobe {</code>\n<code>   abstract class Sweater extends TShirt {</code>\n<code>      int insulate() {return 5;}</code>\n<code>   }</code>\n<code>   private static void dress() {</code>\n<code>      class Jacket extends Sweater {  // v1</code>\n<code>         int insulate() {return 10;}</code>\n<code>      };</code>\n<code>      final TShirt outfit = new Jacket() {  // v2</code>\n<code>         int insulate() {return 20;}</code>\n<code>      };</code>\n<code>      System.out.println("Insulation:"+outfit.insulate());</code>\n<code>   }</code>\n<code>   public static void main(String... snow) {</code>\n<code>      new Wardrobe().dress();</code>\n<code>   }</code>\n<code>}</code>',answers:["Starting...Insulation:20","Starting...Insulation:40","The code does not compile because of line v1.","The code does not compile because of line v2.","The code does not compile for a different reason."]},{title:"Which statements about the following application are true?",code:"<code>1:  package armory;</code>\n<code>2:  import java.util.function.*;</code>\n<code>3:  class Shield {}</code>\n<code>4:  public class Sword {</code>\n<code>5:     public class Armor {</code>\n<code>6:       int count;</code>\n<code>7:        public final Function&lt;Shield,Sword,Armor&gt; dress = (h,w) \u2010&gt; new Armor();</code>\n<code>8:       public final IntSupplier&lt;Integer&gt; addDragon = () \u2010&gt; count++;</code>\n<code>9:     }</code>\n<code>10:    public static void main(String[] knight) {</code>\n<code>11:      final Armor a = new Armor();</code>\n<code>12:      a.dress.apply(new Shield(), new Sword());</code>\n<code>13:      a.addDragon.getAsInt();</code>\n<code>14:    }</code>\n<code>15: }</code>",answers:["I only","I and II only","I, II, and III","II and III only","None of the above"],ol:["The lambda expression for dress on line 7 compiles without issue.","The lambda expression for addDragon on line 8 compiles without issue.","Not counting the lambda expressions on lines 7 and 8, the code does not contain any compilation errors."]},{title:"Which two conditions best describe a thread that appears to be active but is perpetually stuck and never able to finish its task? (Choose two.)",code:null,answers:["Deadlock","Livelock","Loss of precision","Out of memory error","Race condition","Starvation"]},{title:"Which statements are true about the following date/times? (Choose two.)",code:"<code>2017-04-01T17:00+03:00[Africa/Nairobi]</code>\n<code>2017-04-01T10:00-05:00[America/Panama]</code>",answers:["The first date/time is earlier.","The second date/time is earlier.","Both represent the same date/time.","The two date/times are zero hours apart.","The two date/times are one hour apart.","The two date/times are two hours apart."]},{title:"What is true about the following?",code:'<code>import java.util.*;</code>\n<code>public class Yellow {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      List list = Arrays.asList("Sunny");</code>\n<code>      method(list);     // c1</code>\n<code>   }</code>\n<code>   private static void method(Collection&lt;?&gt; x) {    //c2</code>\n<code>      x.forEach(a -&gt; {});   // c3</code>\n<code>  }</code>\n<code>}</code>',answers:["The code doesn\u2019t compile due to line c1.","The code doesn\u2019t compile due to line c2.","The code doesn\u2019t compile due to line c3.","The code compiles and runs without output.","The code compiles but throws an exception at runtime."]},{title:"What is true about the following code? (Choose two.)",code:'<code>public static void main(String[] args) throws Exception {</code>\n<code>   String url = "jdbc:derby:hats;create=true";</code>\n<code>   Connection conn = null;</code>\n<code>   Statement stmt = null;</code>\n<code>&nbsp;</code>\n<code>   try {</code>\n<code>     conn = DriverManager.getConnection(url);</code>\n<code>     stmt = conn.createStatement();</code>\n<code>     stmt.executeUpdate(        "CREATE TABLE caps (name varchar(255), size varchar(1))");</code>\n<code>   } finally {</code>\n<code>       conn.close();</code>\n<code>       stmt.close();</code>\n<code>   }</code>\n<code>}</code>',answers:["If using a JDBC 3.0 driver, this code throws an exception.","If using a JDBC 4.0 driver, this code throws an exception.","The resources are closed in the wrong order.","The resources are closed in the right order.","The Connection is created incorrectly.","The Statement is created incorrectly."]},{title:"How many lines of the following application contain a compilation error?",code:'<code>package puzzle;</code>\n<code>final interface Finder {</code>\n<code>   default long find() {return 20;}</code>\n<code>}</code>\n<code>abstract class Wanda {</code>\n<code>   abstract long find();</code>\n<code>}</code>\n<code>final class Waldo extends Wanda implements Finder {</code>\n<code>   long find() {return 40;}</code>\n<code><span epub:type="pagebreak" id="Page_421"></span>   public static final void main(String[] pictures) {</code>\n<code>      final Finder f = new Waldo();</code>\n<code>      System.out.print(f.find());</code>\n<code>   }</code>\n<code>}</code>',answers:["One","Two","Three","None. The code compiles and prints 20 at runtime.","None. The code compiles and prints 40 at runtime."]},{title:"What is the output of the following?",code:'<code>1:   package reader;</code>\n<code>2:   import java.util.stream.*;</code>\n<code>3:</code>\n<code>4:   public class Books {</code>\n<code>5:      public static void main(String[] args) {</code>\n<code>6:         IntStream pages = IntStream.of(200, 300);</code>\n<code>7:         long total = pages.sum();</code>\n<code>8:         long count = pages.count();</code>\n<code>9:         System.out.println(total + "-" + count);</code>\n<code>10:     }</code>\n<code>11:  }</code>',answers:["2-2","200-1","500-0","500-2","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"What is the output of executing the following code snippet?",code:'<code>30: ExecutorService e = Executors.newSingleThreadExecutor();</code>\n<code>31: Runnable r1 = () -&gt; Stream.of(1,2,3).parallel();</code>\n<code>32: Callable r2 = () -&gt; Stream.of(4,5,6).parallel();</code>\n<code>33:</code>\n<code>34: Future&lt;Stream&gt; f1 = e.submit(r1);</code>\n<code>35: Future&lt;Stream&gt; f2 = e.submit(r2);</code>\n<code>36:</code>\n<code><span epub:type="pagebreak" id="Page_422"></span>37: Stream&lt;Integer&gt; s = Stream.of(f1.get(),f2.get())</code>\n<code>38:       .flatMap(p -&gt; p)</code>\n<code>39:       .parallelStream();</code>\n<code>40:</code>\n<code>41: ConcurrentMap&lt;Boolean,List&lt;Integer&gt;&gt; r =</code>\n<code>42:       s.collect(Collectors.groupingByConcurrent(i -&gt; i%2==0));</code>\n<code>43: System.out.println(r.get(false).size()+" "+r.get(true).size());</code>',answers:["3 3","2 4","The code does not compile due to one error.","The code does not compile due to two errors.","The code does not compile due to three errors.","The code compiles but a NullPointerException is thrown at runtime."]},{title:"Fill in the blanks: If your application is__________ , it must first have been __________ with respect to supporting multiple languages.",code:null,answers:["extracted, internationalized","extracted, localized","internationalized, extracted","internationalized, localized","localized, extracted","localized, internationalized"]},{title:"Which statement about the following class is true? Assume the file system is available and able to be modified.",code:'<code>package forest;</code>\n<code>import java.io.File;</code>\n<code>public class CreateTree {</code>\n<code>   public boolean createTree(String tree) {</code>\n<code>      if(new File(tree).exists()) {</code>\n<code>         return true;</code>\n<code>      } else {</code>\n<code>         return new File(tree).mkdir();</code>\n<code>      }</code>\n<code>   }</code>\n<code>   public static void main(String[] seeds) {</code>\n<code>      final CreateTree creator = new CreateTree();</code>\n<code>      System.out.print(creator.createTree("/woods/forest"));</code>\n<code>   }</code>\n<code>}</code>',answers:["The class compiles and always prints true at runtime.","The class compiles and always prints false at runtime.","The class compiles but the output cannot be determined until runtime.","The class compiles but may throw an exception at runtime.","The class does not compile."]},{title:"What does the following print?",code:'<code>1:    class SmartWatch extends Watch {</code>\n<code>2:      private String getType() { return "smart watch"; }</code>\n<code>3:      public String getName() {</code>\n<code>4:         return getType() + ",";</code>\n<code>5:      }</code>\n<code>6:   }</code>\n<code>7:   public class Watch {</code>\n<code>8:      private String getType() { return "watch"; }</code>\n<code>9:      public String getName(String suffix) {</code>\n<code>10:        return getType() + suffix;</code>\n<code>11:     }</code>\n<code>12:     public static void main(String[] args) {</code>\n<code>13:        Watch watch = new Watch();</code>\n<code>14:        Watch smartWatch = new SmartWatch();</code>\n<code>15:        System.out.print(watch.getName(","));</code>\n<code>16:        System.out.print(smartWatch.getName(""));</code>\n<code>17:     }</code>\n<code>18:  }</code>',answers:["smart watch,smart watch","smart watch,watch","watch,smart watch","watch,watch","None of the above"]},{title:"In most of the United States, daylight savings time ends on November 5, 2017 at 02:00 a.m., and we repeat that hour. What is the output of the following?",code:'<code>import java.time.*;</code>\n<code>&nbsp;</code>\n<code>public class FallBack {</code>\n<code>&nbsp;</code>\n<code>   public static void main(String[] args) {</code>\n<code>      LocalDate localDate = LocalDate.of(2017, Month.NOVEMBER, 5);</code>\n<code>      LocalTime localTime = LocalTime.of(1, 0);</code>\n<code>      ZoneId zone = ZoneId.of("America/New_York");</code>\n<code>      ZonedDateTime z = ZonedDateTime.of(localDate, localTime, zone);</code>\n<code>&nbsp;</code>\n<code><span epub:type="pagebreak" id="Page_424"></span>      for (int i = 0; i &lt; 6; i++)</code>\n<code>         z = z.plusHours(1);</code>\n<code>&nbsp;</code>\n<code>      System.out.println(z.getHour());</code>\n<code>   }</code>\n<code>}</code>',answers:["5","6","7","The code does not compile.","The code compiles but throws an exception at runtime."]},{title:"Which statements about the following application are true?",code:'<code>package party;</code>\n<code>import java.util.concurrent.*;</code>\n<code>public class Plan {</code>\n<code>   private ExecutorService service = Executors.newCachedThreadPool();</code>\n<code>   public void planEvents() {</code>\n<code>      service.scheduleWithFixedDelay(</code>\n<code>            () -&gt; System.out.print("Check food stock"),</code>\n<code>            1, TimeUnit.HOURS);</code>\n<code>      service.scheduleAtFixedRate(</code>\n<code>            () -&gt; System.out.print("Check drink stock"),</code>\n<code>            1, 1000, TimeUnit.SECONDS);</code>\n<code>      service.execute(() -&gt; System.out.print("Take out trash"));</code>\n<code>   }</code>\n<code>}</code>',answers:["I only","II only","III only","I and II","I, II, and III","None of the above"],ol:["The scheduleWithFixedDelay() method call compiles.","The scheduleAtFixedRate() method call compiles.","The execute() method call compiles."]},{title:"Which of the following classes are checked exception? (Choose three.)",code:null,answers:["java.io.NotSerializableException","java.lang.AssertionError","java.lang.IllegalArgumentException","java.sql.SQLException","java.text.ParseException","java.util.MissingResourceException"]},{title:"Which of the following are valid functional interfaces? (Choose two.)",code:null,answers:["interface CanClimb {default void climb() {} \n\n   static void climb(int x) {}}\n","interface CanDance {int dance() { return 5;}}","interface CanFly {abstract void fly();}","interface CanRun {void run();\n\n   static double runFaster() {return 2.0;}}\n","interface CanSwim {abstract Long swim();\n\n   boolean test();}\n"]},{title:"How many of the following could be valid JDBC URL formats for an imaginary driver named magic and a database named box?",code:null,answers:["None","One","Two","Three","Four","Five"],ol:["jdbc;box;magic","jdbc;magic;@127.0.0.1:1234","jdbc;magic;//@127.0.0.1:1234","jdbc;magic;127.0.0.1:1234/box","magic;jdbc;127.0.0.1:1234/box"]},{title:"What is the output of the following?",code:'<code>Stream&lt;String&gt; s = Stream.of("speak", "bark", "meow", "growl");</code>\n<code>Map&lt;Integer, String&gt; map = s.collect(toMap(String::length, k \u2010&gt; k));</code>\n<code>System.out.println(map.size() + " " + map.get(4));</code>',answers:["2 bark","2 meow","4 bark","4 meow","The output is not guaranteed.","The code compiles but throws an exception at runtime."]},{title:"What is the output of the following application?",code:'<code>package music;</code>\n<code>interface DoubleBass {</code>\n<code>   void strum();</code>\n<code>   default int getVolume() {return 5;}</code>\n<code>}</code>\n<code>interface BassGuitar {</code>\n<code>   void strum();</code>\n<code>   default int getVolume() {return 10;}</code>\n<code>}</code>\n<code>class ElectricBass implements DoubleBass, BassGuitar {</code>\n<code>   @Override public void strum() {System.out.print("A");}</code>\n<code>}</code>\n<code>public class RockBand {</code>\n<code>   public static void main(String[] strings) {</code>\n<code>      final class MyElectricBass extends ElectricBass {</code>\n<code>         public void strum() {System.out.print("E");}</code>\n<code>      }</code>\n<code>   }</code>\n<code>}</code>',answers:["A","E","The code compiles and runs without issue but does not print anything.","One line of code does not compile.","Two lines of code do not compile.","Three lines of code do not compile."]},{title:"Which NIO.2 Files methods return a Stream? (Choose three.)",code:null,answers:["find()","lines()","list()","listFiles()","readAllLines()","walkFileTree()"]}].map(function(e,t){return{id:t,title:e.title,code:e.code,imageUrl:null,answerArray:i(e.answers,n[t]),answersIntArray:a(n[t]),explain:n[t],ol:e.ol}});c[30].imageUrl="./images/image-ocp-ch23-31.png",c[43].imageUrl="./images/image-ocp-ch23-44.png",t.default=c},183:function(e,t,o){"use strict";o.r(t);var n=o(0),a=o.n(n),i=o(16),c=o.n(i),s=(o(101),o(6)),r=o(7),d=o(9),l=o(8),h=o(10),u=o(11),p=o(2),m=o(24),f=o(89),b=o(20),g=o(3),w={quizs:[],answerStatus:{},index:0,total:0,score:0,percentage:0,quizsTitle:"",course_id:0},y={isAnswered:!1,isMarked:!1,scored:!1,answer:null},v=function(e){return"app/tasks/".concat(e)},T=function(e){for(var t=0,o=Object.keys(e),n=0;n<o.length;n++){e[o[n]].isAnswered&&(t+=1)}return t};var k=v("GET_QUIZS"),S=v("NEXT_QUIZ"),x=v("BACK_QUIZ"),O=v("ANSWER_QUIZ"),_=v("MARK_QUIZ"),C=v("JUMP_TO_QUIZ"),A=v("RESET_STATE"),I=v("PICK_UP_ANSWER"),B=v("SUBMIT_ANSWER"),E=function(e,t){return{type:k,quizs:e,answerState:t}},D=function(e){return{type:C,id:e}},F=function(){return{type:A}},L="SHOW_ALL",j="SHOW_IMCOMPLETED",W="SHOW_MARKED",N="SHOW_WRONG",P=L;var R="app/tasks/".concat("SET_VISIBILITY_FILTER"),q={selectedCertification:"",selectedChapter:"",ocaProgress:["Java Basic","Working with Java Data Types","Using Operators and Decision Constructs","Creating and Using Arrays","Using Loop Constructs","Working with Methods and Encapsulation","Working with Inheritance","Handling Exceptions","Working with Selected Classes from the Java API"].map(function(e,t){return{title:e,percentage:0,course_ID:t+1,answerState:null}}),ocpProgress:["Java Class Design","Advanced Java Class Design","Generics and Collections","Lambda Built-in Functional Interfaces","Java Stream API","Exceptions and Assertions","Use Java SE 8 Date/Time API","Java I/O Fundamentals","Java File I/O (NIO.2)","Java Concurrency","Building Database Applications with JDBC","Localization"].map(function(e,t){return{title:e,percentage:0,course_ID:t+11,answerState:null}})},M=function(e){return"app/tasks/".concat(e)};var z=M("UPDATE_PERCENTAGE"),H=M("UPDATE_CERTIFICATION"),J=M("UPDATE_ANSWERSTATE"),U=Object(f.createLogger)(),G=Object(m.c)({app:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:w,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};switch(t.type){case k:var o=t.answerState||t.quizs.reduce(function(e,t){return Object(g.a)({},e,Object(b.a)({},t.id,y))},{}),n=T(o)/t.quizs.length*100;return Object(g.a)({},e,{quizs:t.quizs,total:t.quizs.length,answerStatus:o,percentage:n});case S:return e.index>=e.total?e:Object(g.a)({},e,{index:e.index+1});case x:return 0===e.index?e:Object(g.a)({},e,{index:e.index-1});case _:var a=Object(g.a)({},e.answerStatus[t.id],{isMarked:!e.answerStatus[t.id].isMarked});return Object(g.a)({},e,{answerStatus:Object(g.a)({},e.answerStatus,Object(b.a)({},t.id,a))});case O:var i=Object(g.a)({},e.answerStatus[t.id],{isAnswered:!0,scored:t.validate,answer:t.index}),c=T(e.answerStatus);return Object(g.a)({},e,{percentage:(c+1)/e.total*100,answerStatus:Object(g.a)({},e.answerStatus,Object(b.a)({},t.id,i))});case C:return Object(g.a)({},e,{index:t.id});case A:return w;case I:var s=e.answerStatus[t.id].answer,r={id:t.index,correct:t.isCorrect};null===s?s=[r]:s.some(function(e){return e.id===r.id})?s=s.filter(function(e){return e.id!==r.id}):s.push(r);var d=Object(g.a)({},e.answerStatus[t.id],{answer:s});return Object(g.a)({},e,{answerStatus:Object(g.a)({},e.answerStatus,Object(b.a)({},t.id,d))});case B:var l=t.id,h=e.answerStatus[l].answer,u=null!==h&&h.length===e.quizs[l].answersIntArray.length&&h.reduce(function(e,t){return e&&t.correct},!0),p=Object(g.a)({},e.answerStatus[l],{scored:u});return Object(g.a)({},e,{answerStatus:Object(g.a)({},e.answerStatus,Object(b.a)({},l,p)),index:e.index+1,score:e.score+(!0===u?1:0),percentage:(e.index+1)/e.total*100});default:return e}},visibilityFilter:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:P,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};switch(t.type){case R:return t.filter;default:return e}},dashboard:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:q,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};switch(t.type){case J:if(t.id<10){var o=e.ocaProgress.map(function(e){return e.course_ID===parseInt(t.id)?Object(g.a)({},e,{answerState:t.answerState}):e});return Object(g.a)({},e,{ocaProgress:o})}var n=e.ocpProgress.map(function(e){return e.course_ID===parseInt(t.id)?Object(g.a)({},e,{answerState:t.answerState}):e});return Object(g.a)({},e,{ocpProgress:n});case z:if(t.id<10){var a=e.ocaProgress.map(function(e){return e.course_ID===t.id?Object(g.a)({},e,{percentage:t.value}):e});return Object(g.a)({},e,{ocaProgress:a})}var i=e.ocpProgress.map(function(e){return e.course_ID===t.id?Object(g.a)({},e,{percentage:t.value}):e});return Object(g.a)({},e,{ocpProgress:i});case H:return Object(g.a)({},e,{selectedCertification:t.text});default:return e}}}),V=("object"===typeof window&&window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__?window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}):m.d)(Object(m.a)(U)),Y=Object(m.e)(G,{},V),Q=o(31),Z=o.n(Q),X=o(18),K=o(12),$=o(13),ee={getQuizs:E,nextQuiz:function(){return{type:S}},backQuiz:function(){return{type:x}},markQuiz:function(e){return{type:_,id:e}},resetState:F,updateAnswerState:function(e,t){return{type:J,id:e,answerState:t}}},te=Object(p.b)(function(e){return{quizs:e.app.quizs,answerStatus:e.app.answerStatus,index:e.app.index,total:e.app.total,score:e.app.score,percentage:e.app.percentage,cert:e.dashboard.selectedCertification,ocaProgress:e.dashboard.ocaProgress,ocpProgress:e.dashboard.ocpProgress}},ee),oe=function(e){var t=e.orderList;return a.a.createElement("ol",{style:{marginLeft:"30px",fontWeight:700}},t.map(function(e,t){return a.a.createElement("li",{key:t},e)}))},ne=function(e){var t=e.title,o=e.id,n=e.code,i=e.imageUrl,c=e.ol;return a.a.createElement("div",{className:"question-card"},a.a.createElement("p",null,"\u554f\u984c ",o+1," :"),a.a.createElement("h3",null,t),n?a.a.createElement("pre",{dangerouslySetInnerHTML:{__html:n}}):null,i?a.a.createElement("div",{className:"image-container"},a.a.createElement("img",{src:i,alt:"question"})):null,c?a.a.createElement(oe,{orderList:c}):null)},ae=function(e){var t=e.explain;return a.a.createElement("div",{className:"analysis-card"},a.a.createElement("h3",null,"\u984c\u89e3 \uff1a"),a.a.createElement("p",null,a.a.createElement("span",null,t[0]),t.substr(1)))},ie={answerQuiz:function(e,t,o){return{type:O,id:e,validate:t,index:o}}},ce=Object(p.b)(null,ie),se=["A","B","C","D","E","F","G","H"],re=ce(function(e){function t(){var e,o;Object(s.a)(this,t);for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];return(o=Object(d.a)(this,(e=Object(l.a)(t)).call.apply(e,[this].concat(a)))).scroll=Z.a.animateScroll,o.clickedHandler=function(e){var t=o.props,n=t.answerObj,a=t.id,i=t.answerQuiz;t.answered||(i(a,n.isCorrect,e),o.scroll.scrollToBottom())},o}return Object(h.a)(t,e),Object(r.a)(t,[{key:"render",value:function(){var e=this,t=this.props,o=t.answerIndex,n=t.answerObj,i=t.answer;return null===i?a.a.createElement("li",{onClick:function(){return e.clickedHandler(o)}},a.a.createElement("span",null,se[o]),a.a.createElement("p",null,n.answer)):o===i?a.a.createElement("li",{style:n.isCorrect?{backgroundColor:"#b5e7a0",color:"white"}:{backgroundColor:"#d64161",color:"white"}},a.a.createElement("span",null,se[o]),a.a.createElement("p",null,n.answer)):a.a.createElement("li",null,a.a.createElement("span",null,se[o]),a.a.createElement("p",null,n.answer))}}]),t}(a.a.Component)),de=o(4),le=o(5),he=function(e,t,o){switch(o){case L:return e;case j:return e.filter(function(e){return!t[e.id].isAnswered});case W:return e.filter(function(e){return t[e.id].isMarked});case N:return e.filter(function(e){return t[e.id].isAnswered&&!t[e.id].scored});default:throw new Error("Unknown filter: "+o)}},ue=Object(p.b)(function(e){return{quizs:he(e.app.quizs,e.app.answerStatus,e.visibilityFilter),answerStatus:e.app.answerStatus,index:e.app.index,filter:e.visibilityFilter}}),pe={jumpToQuiz:D},me=Object(p.b)(null,pe)(function(e){var t=e.title,o=e.marked,n=e.scored,i=e.answered,c=e.id,s=e.dismissHandler,r=e.jumpToQuiz;return a.a.createElement("li",{onClick:function(){s(),r(c)}},a.a.createElement("div",{className:"marks"},a.a.createElement("div",{style:o?{color:"orange"}:null},a.a.createElement(K.a,{icon:$.h,size:"sm"})),a.a.createElement("div",{style:{fontSize:"14px",fontWeight:700}},a.a.createElement("p",null,"\u554f\u984c",c+1,": ")),a.a.createElement("div",null,i?a.a.createElement("p",{className:"style-area blue"},"\u5df2\u505a\u7b54"):a.a.createElement("p",{className:"style-area grey"},"\u7565\u904e\u7684\u984c\u76ee")),a.a.createElement("div",null,i?n?a.a.createElement("p",{className:"style-area right"},"\u7b54\u5c0d"):a.a.createElement("p",{className:"style-area wrong"},"\u7b54\u932f"):null)),a.a.createElement("div",{className:"description"},a.a.createElement("p",null,t)))}),fe=o(47),be=o.n(fe),ge=function(){return a.a.createElement("header",{className:"App-header"},a.a.createElement(u.a,{to:"/"},a.a.createElement("img",{src:be.a,className:"App-logo",alt:"logo"})))},we=Object(p.b)(function(e,t){return{active:t.filter===e.visibilityFilter}},function(e,t){return{onClick:function(){var o;console.log(t.filter),e((o=t.filter,{type:R,filter:o}))}}});function ye(){var e=Object(de.a)(["\n  background-color: white;\n  border-radius: 3px;\n  border-radius: 1px solid grey;\n"]);return ye=function(){return e},e}var ve=le.b.button(ye()),Te=we(function(e){var t=e.active,o=e.children,n=e.onClick;return a.a.createElement(ve,{onClick:n,disabled:t,style:{marginLeft:"10px"}},o)}),ke=function(){return a.a.createElement("div",{className:"link-control"},a.a.createElement("span",null,"Show: "),a.a.createElement(Te,{filter:L},"\u5168\u90e8"),a.a.createElement(Te,{filter:j},"\u672a\u5b8c\u6210"),a.a.createElement(Te,{filter:N},"\u7b54\u932f"),a.a.createElement(Te,{filter:W},"Marked"))},Se=function(e){var t=e%60,o=Math.floor(e/60)%60,n=Math.floor(e/60/60);return o=1===o.toString().length?"0"+o:o,t=1===t.toString().length?"0"+t:t,(n=1===n.toString().length?"0"+n:n)+" : "+o+" : "+t},xe=function(e,t,o){var n=e.split(" ");if(t>=n.length)return e;var a=n.slice(0,t);return"".concat(a.join(" ")).concat(o)};function Oe(){var e=Object(de.a)(["\n      transform: translate3d(-100vw, 0, 0);\n    "]);return Oe=function(){return e},e}function _e(){var e=Object(de.a)(["\n      transform: translate3d(0vw, 0, 0);\n    "]);return _e=function(){return e},e}function Ce(){var e=Object(de.a)(["\n  width: 100vw;\n  height: 100vh;\n  position: fixed;\n  background-color: #fff;\n  top: 0;\n  left: 0;\n  transition: transform 0.3s cubic-bezier(0, 0.52, 0, 1);\n  overflow: scroll;\n  z-index: 1000;\n  ","\n\n  ","\n    button {\n    border: none;\n    font-size: 16px;\n    color: #0084da;\n    margin: 0;\n  }\n  & .list-item-color li:nth-child(even) {\n    background: #ccc;\n  }\n"]);return Ce=function(){return e},e}var Ae=le.b.div(Ce(),function(e){return e.visible&&Object(le.a)(_e())},function(e){return!e.visible&&Object(le.a)(Oe())}),Ie=ue(function(e){var t=e.visible,o=e.dismissHandler,n=e.quizs,i=e.answerStatus;return a.a.createElement(Ae,{visible:t},a.a.createElement(ge,null),a.a.createElement("div",{className:"App-main-container"},a.a.createElement(ke,null),a.a.createElement("div",{className:"list-container"},a.a.createElement("button",{onClick:o},"BACK"),a.a.createElement("ul",{className:"list-item-color"},n.map(function(e,t){return a.a.createElement(me,{key:e.title+t,title:xe(e.title,12," ..."),marked:i[e.id].isMarked,answered:i[e.id].isAnswered,scored:i[e.id].scored,id:e.id,dismissHandler:o})})))))}),Be=function(e){var t=e.className,o=e.thunk;return a.a.createElement("div",{className:t},a.a.createElement("button",{onClick:o?function(){return o()}:function(){window.history.back()}},a.a.createElement("span",{style:{marginRight:"10px"}},a.a.createElement(K.a,{icon:$.e,size:"lg"})),"Back"))},Ee=Object(p.b)(function(e){return{quizs:e.app.quizs,answerStatus:e.app.answerStatus,index:e.app.index,filter:e.visibilityFilter}}),De={jumpToQuiz:D},Fe=Object(p.b)(null,De);function Le(){var e=Object(de.a)(["\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 24px;\n  height: 24px;\n  margin-right: 8px;\n  margin-top: 8px;\n  border-radius: 50%;\n  border: 2px solid #eee;\n  color: white;\n  font-size: 10px;\n  cursor: pointer;\n  transition: all 0.4s ease-in-out;\n  box-shadow: 0 2px 3px rgba(0, 0, 0, 0.5);\n  &:hover {\n    transform: scale(1.1);\n    color: goldenrod;\n    font-weight: 700;\n  }\n"]);return Le=function(){return e},e}var je=le.b.div(Le()),We=Fe(function(e){var t=e.children,o=e.answerStatus,n=e.jumpToQuiz,i=e.handleMouseOver,c=o.isMarked?"#F5A623":o.scored?"#4a90e2":o.isAnswered?"#d0021b":"#d8d8d8";return a.a.createElement(je,{style:{backgroundColor:"".concat(c)},onClick:function(){return n(t)},onMouseOver:function(){return i(t)}},t+1)});function Ne(){var e=Object(de.a)(['\n  max-width: 200px;\n  height: 120px;\n  background-color: #eee;\n  font-size: 14px;\n  font-family: "Lato", sans-serif;\n  font-weight: 700;\n  padding: 6px 10px;\n  color: teal;\n']);return Ne=function(){return e},e}function Pe(){var e=Object(de.a)(["\n  max-width: 260px;\n  display: flex;\n  flex-flow: row wrap;\n  justify-content: center;\n  align-items: center;\n  flex-shrink: 280px;\n  margin: 0 auto;\n  margin-top: 20px;\n  margin-right: 100px;\n  margin-bottom: 20px;\n"]);return Pe=function(){return e},e}var Re=le.b.div(Pe()),qe=le.b.div(Ne()),Me=Ee(function(e){function t(){var e,o;Object(s.a)(this,t);for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];return(o=Object(d.a)(this,(e=Object(l.a)(t)).call.apply(e,[this].concat(a)))).state={text:""},o.handleMouseOver=function(e){o.setState({text:o.props.quizs[e].title})},o}return Object(h.a)(t,e),Object(r.a)(t,[{key:"render",value:function(){var e=this,t=this.props,o=t.quizs,n=t.answerStatus;return a.a.createElement("div",null,a.a.createElement(Re,null,o.map(function(t){return a.a.createElement(We,{answerStatus:n[t.id],key:t.id,handleMouseOver:e.handleMouseOver},t.id)})),a.a.createElement(qe,null,xe(this.state.text,20,"...")))}}]),t}(a.a.Component)),ze=(o(64),function(e){switch(e){case"1":return o(157).default;case"2":return o(158).default;case"3":return o(159).default;case"4":return o(160).default;case"5":return o(161).default;case"6":return o(162).default;case"7":return o(163).default;case"8":return o(164).default;case"9":return o(165).default;case"11":return o(166).default;case"12":return o(167).default;case"13":return o(168).default;case"14":return o(169).default;case"15":return o(170).default;case"16":return o(171).default;case"17":return o(172).default;case"18":return o(173).default;case"19":return o(174).default;case"20":return o(175).default;case"21":return o(176).default;case"22":return o(177).default;case"OCA":return o(178).default;case"OCP":return o(179).default}}),He=te(function(e){function t(){var e,o;Object(s.a)(this,t);for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];return(o=Object(d.a)(this,(e=Object(l.a)(t)).call.apply(e,[this].concat(a)))).scroll=Z.a.animateScroll,o.state={visible:!1,title:""},o.dismissHandler=function(e){o.indexButtonHanlder()},o.componentDidMount=function(){var e,t=o.props,n=t.id,a=t.ocaProgress,i=t.ocpProgress,c=ze(n);n<10?(e=a[n-1].answerState,o.setState({title:a[n-1].title})):(e=i[n-11].answerState,o.setState({title:i[n-11].title})),o.props.getQuizs(c,e)},o.componentWillUnmount=function(){var e=o.props,t=e.id,n=e.answerStatus;o.props.updateAnswerState(t,n),o.props.resetState()},o.markButtonHandler=function(e){o.props.markQuiz(e)},o.nextButtonHandler=function(){o.props.nextQuiz(),o.scroll.scrollToTop()},o.backButtonHandler=function(){o.props.backQuiz()},o.indexButtonHanlder=function(){o.setState({visible:!o.state.visible})},o}return Object(h.a)(t,e),Object(r.a)(t,[{key:"render",value:function(){var e=this,t=this.props,o=t.quizs,n=t.index,i=t.answerStatus,c=t.total,s=t.percentage,r=o[n];return r?a.a.createElement("div",{className:"App"},a.a.createElement(Ie,{visible:this.state.visible,dismissHandler:this.dismissHandler}),a.a.createElement(ge,null),a.a.createElement("div",{className:"desktop"},a.a.createElement("div",{className:"App-main-container"},a.a.createElement("div",{className:"main-section"},a.a.createElement(Be,{className:"return-icon"}),a.a.createElement("h1",{style:{textAlign:"center"}},this.state.title),a.a.createElement("p",{style:{marginTop:"10px"}},"\u9032\u5ea6\uff1a",s.toFixed(1),"%"),a.a.createElement(X.b,{strokeWidth:"4",percent:s}),a.a.createElement(ne,{title:r.title,id:r.id,code:r.code,imageUrl:r.imageUrl,ol:r.ol}),a.a.createElement("div",{className:"answers"},a.a.createElement("ul",null,r.answerArray.map(function(e,t){return a.a.createElement(re,{key:e.answer+t,answerIndex:t,answerObj:e,id:r.id,answered:i[n].isAnswered,answer:i[n].answer})}))),a.a.createElement("div",{className:"progress-control"},a.a.createElement("div",null,a.a.createElement("button",{onClick:function(){return e.markButtonHandler(r.id)},style:i[r.id].isMarked?{color:"orange"}:null},a.a.createElement(K.a,{icon:$.h,size:"lg"}))),a.a.createElement("div",null,a.a.createElement("button",{onClick:this.backButtonHandler,disabled:0===r.id},a.a.createElement(K.a,{icon:$.c,size:"lg"}))),a.a.createElement("div",null,a.a.createElement("button",{onClick:this.nextButtonHandler,disabled:n===c-1},a.a.createElement(K.a,{icon:$.d,size:"lg"}))),a.a.createElement("div",{className:"list-button"},a.a.createElement("button",{onClick:this.indexButtonHanlder},a.a.createElement(K.a,{icon:$.f,size:"lg"})))),i[r.id].isAnswered?a.a.createElement(ae,{explain:r.explain}):null)),a.a.createElement("div",{className:"ball-list-container"},a.a.createElement("h2",{style:{width:"200px",marginRight:"100px"}},"\u9ede\u9078\u4ee5\u4e0b\u5708\u5708\u53ef\u4ee5\u76f4\u63a5\u8df3\u81f3\u5c0d\u61c9\u984c\u76ee"),a.a.createElement(Me,null)))):null}}]),t}(n.Component)),Je=o(92),Ue=o.n(Je),Ge=function(){return a.a.createElement("div",{className:"landing"},a.a.createElement("header",{className:"landing-header"},a.a.createElement("div",{className:"about"},a.a.createElement(u.a,{to:"/about"},"About this")),a.a.createElement("img",{src:be.a,className:"App-logo",alt:"logo"})),a.a.createElement("div",{className:"landing-main-section"},a.a.createElement("div",{className:"hero"},a.a.createElement("div",{className:"hero-logo-container"},a.a.createElement("img",{src:Ue.a,className:"Hero-logo",alt:"logo for java cafe hero section"})),a.a.createElement("div",{className:"hero-text-box"},a.a.createElement("h1",null,"Java Cafe"),a.a.createElement("p",null,"Taming Java OCA/OCP, the path to the succeed for Java programming"))),a.a.createElement("section",{className:"button-section"},a.a.createElement("h2",null,"Have a cup of Java Cafe?"),a.a.createElement("p",{style:{fontFamily:"Noto Sans TC",fontWeight:700}},"\u4f60\u53ef\u4ee5\u9078\u64c7REVIEW\u8986\u7fd2\u5404\u500b\u7ae0\u7bc0,\u7576\u4f60\u6e96\u5099\u597d\u53ef\u4ee5\u76f4\u63a5\u6309EXAM. Good Luck..."),a.a.createElement("button",{className:"landing-button",onClick:function(e){return Object(u.c)("/categories/REVIEW")}},"REVIEW"),a.a.createElement("button",{className:"landing-button",onClick:function(e){return Object(u.c)("/categories/EXAM")}},"EXAM"))))},Ve=function(e){var t=e.process;return a.a.createElement("div",{className:"categories"},a.a.createElement(ge,null),a.a.createElement("div",{className:"categories-main-section"},a.a.createElement(Be,{className:"return-icon"}),a.a.createElement("div",{className:"categories-textbox"},a.a.createElement("div",{className:"textbox"},a.a.createElement("h2",null,"OCA"),a.a.createElement("p",null,"Oracle Certified Associate for Java Programming")),a.a.createElement("div",{className:"textbox"},a.a.createElement("h2",null,"OCP"),a.a.createElement("p",null,"Oracle Certified Professional for Java Programming")),"EXAM"===t?a.a.createElement("div",{className:"textbox-exam"},a.a.createElement("p",null,"\u8003\u8a66\u6642\u9593 150 \u5206\u9418, "),a.a.createElement("p",null,"OCA 80 \u984c, OCP 85\u984c"),a.a.createElement("h6",null,"\u8003\u5b8c\u5f8c\u6703\u6709\u6210\u7e3e\u548c\u984c\u89e3\u9801\u9762"),a.a.createElement("h6",null,"Are you ready ?")):null),a.a.createElement("div",{className:"categoreis-background"},a.a.createElement("div",{className:"navigation"},a.a.createElement("ul",{className:"navigation__list"},a.a.createElement("li",{className:"navigation__item"},"EXAM"!==t?a.a.createElement(u.a,{to:"/chapters/OCA",className:"navigation__link"},"OCA-808"):a.a.createElement(u.a,{to:"/exam/OCA",className:"navigation__link"},"OCA-808")),a.a.createElement("li",{className:"navigation__item"},"EXAM"!==t?a.a.createElement(u.a,{to:"/chapters/OCP",className:"navigation__link"},"OCP-809"):a.a.createElement(u.a,{to:"/exam/OCP",className:"navigation__link"},"OCP-809")))))))},Ye={updateCertification:function(e){return{type:H,text:e}}},Qe=Object(p.b)(null,Ye),Ze=Object(p.b)(function(e){return{selectedCertification:e.dashboard.selectedCertification,ocaProgress:e.dashboard.ocaProgress,ocpProgress:e.dashboard.ocpProgress}});function Xe(){var e=Object(de.a)(["\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  position: relative;\n  & p.percentage-text {\n    font-size: 12px;\n    position: absolute;\n    z-index: 10;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n  }\n"]);return Xe=function(){return e},e}function Ke(){var e=Object(de.a)(['\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: flex-start;\n  font-family: "Lato", sans-serif;\n  & h2.text-box-primary {\n    padding-left: 20px;\n  }\n\n  & h5.text-box-secondary {\n    padding-left: 20px;\n    color: #666;\n    font-weight: 200;\n  }\n']);return Ke=function(){return e},e}function $e(){var e=Object(de.a)(["\n  width: 280px;\n  height: 80px;\n  margin: 20px auto;\n  background-color: white;\n  border-radius: 5px;\n  display: grid;\n  grid-template-columns: 200px 80px;\n  cursor: pointer;\n\n  border-left: 5px solid ",";\n  box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.4);\n  transition: all 0.5s ease;\n  &:hover {\n    transform: scaleX(1.1);\n  }\n  @media (min-width: 768px) {\n    width: 560px;\n    grid-template-columns: 480px 80px;\n  }\n"]);return $e=function(){return e},e}var et=le.b.div($e(),function(e){return e.inputColor}),tt=le.b.div(Ke()),ot=le.b.div(Xe()),nt=["A2A0BB","FF7187","8380FF","7EA9FF","7100FF"],at=function(e){return e<20?0:e>=20&&e<40?1:e>=40&&e<60?2:e>=60&&e<80?3:4},it=function(e){function t(){var e,o;Object(s.a)(this,t);for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];return(o=Object(d.a)(this,(e=Object(l.a)(t)).call.apply(e,[this].concat(a)))).state={percentage:0,currentColor:""},o.componentDidMount=function(){var e=o.props.percentage,t=at(e);o.setState({percentage:e,currentColor:nt[t]})},o.clickHandler=function(e){Object(u.c)("/main/".concat(e))},o}return Object(h.a)(t,e),Object(r.a)(t,[{key:"render",value:function(){var e=this,t=this.props,o=t.title,n=t.percentage,i=t.course_ID,c=this.state.currentColor;return a.a.createElement(et,{inputColor:"#".concat(c),onClick:function(){return e.clickHandler(i)}},a.a.createElement(tt,null,a.a.createElement("h2",{className:"text-box-primary"},"Chapter",i),a.a.createElement("h5",{className:"text-box-secondary"},o)),a.a.createElement(ot,null,a.a.createElement("p",{className:"percentage-text"},n.toFixed(0),"%"),a.a.createElement(X.a,{style:{width:"50%"},percent:n,strokeWidth:"10",strokeColor:c})))}}],[{key:"getDerivedStateFromProps",value:function(e,t){if(e.percentage!==t.percentage){var o=at(e.percentage);return{percentage:e.percentage,currentColor:nt[o]}}return null}}]),t}(n.Component),ct=function(e){var t,o=0;if(e.answerState){for(var n=Object.keys(e.answerState),a=0;a<n.length;a++){var i=n[a];e.answerState[i].isAnswered&&(o+=1)}t=o/n.length*100}else t=0;return t},st=Ze(function(e){var t=e.selectedCertification,o=e.ocaProgress,n=e.ocpProgress;return a.a.createElement("div",null,"OCA"===t?o.map(function(e){var t=ct(e);return a.a.createElement(it,{title:e.title,course_ID:e.course_ID,percentage:t,key:e.title+e.course_ID})}):n.map(function(e){var t=ct(e);return a.a.createElement(it,{title:e.title,course_ID:e.course_ID,percentage:t,key:e.title+e.course_ID})}))}),rt=o(93),dt=o.n(rt),lt=Qe(function(e){function t(){var e,o;Object(s.a)(this,t);for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];return(o=Object(d.a)(this,(e=Object(l.a)(t)).call.apply(e,[this].concat(a)))).componentDidMount=function(){o.props.updateCertification(o.props.cert)},o}return Object(h.a)(t,e),Object(r.a)(t,[{key:"render",value:function(){return a.a.createElement("div",{className:"chapters"},a.a.createElement(ge,null),a.a.createElement("div",{className:"chapter-main-section"},a.a.createElement(Be,{className:"return-icon"}),a.a.createElement("div",{className:"cate-imagebox"},a.a.createElement("img",{src:dt.a,alt:"study"})),a.a.createElement("section",{className:"chapter-section"},a.a.createElement(st,null))))}}]),t}(n.Component)),ht={getQuizs:E,submitAnswer:function(e){return{type:B,id:e}},resetState:F},ut=Object(p.b)(function(e){return{quizs:e.app.quizs,answerStatus:e.app.answerStatus,index:e.app.index,score:e.app.score,percentage:e.app.percentage,total:e.app.total}},ht),pt={pickUpAnswer:function(e,t,o){return{type:I,index:e,isCorrect:t,id:o}}},mt=Object(p.b)(null,pt),ft=["A","B","C","D","E","F","G","H"],bt=mt(function(e){function t(){var e,o;Object(s.a)(this,t);for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];return(o=Object(d.a)(this,(e=Object(l.a)(t)).call.apply(e,[this].concat(a)))).state={picked:!1},o.clickedHandler=function(){var e=o.props,t=e.answerObj,n=e.pickUpAnswer,a=e.answerIndex,i=e.id;n(a,t.isCorrect,i),o.setState({picked:!o.state.picked})},o}return Object(h.a)(t,e),Object(r.a)(t,[{key:"render",value:function(){var e=this.props,t=e.answerIndex,o=e.answerObj;return a.a.createElement("li",{onClick:this.clickedHandler,style:this.state.picked?{background:"#C0C0C0"}:null},a.a.createElement("span",null,ft[t]),a.a.createElement("p",null,o.answer))}}]),t}(a.a.Component));function gt(){var e=Object(de.a)(["\n  display: flex;\n  width: 120px;\n  justify-content: space-between;\n  align-items: center;\n  & h4 {\n    color: red;\n  }\n\n  & div button {\n    font-size: 20px;\n    border: transparent;\n    background-color: transparent;\n    color: #0084da;\n  }\n"]);return gt=function(){return e},e}var wt=le.b.div(gt()),yt=function(e){var t=e.elapsed,o=e.onToggleTimer;return a.a.createElement(wt,null,a.a.createElement("div",null,a.a.createElement("button",{onClick:o},a.a.createElement(K.a,{icon:$.g,size:"lg"}))),a.a.createElement("h4",{style:{fontSize:"12px"}},Se(t)))},vt=document.getElementById("modal-root"),Tt=function(e){function t(e){var o;return Object(s.a)(this,t),(o=Object(d.a)(this,Object(l.a)(t).call(this,e))).element=document.createElement("div"),o}return Object(h.a)(t,e),Object(r.a)(t,[{key:"componentDidMount",value:function(){vt.appendChild(this.element)}},{key:"componentWillUnmount",value:function(){vt.removeChild(this.element)}},{key:"render",value:function(){return Object(i.createPortal)(this.props.children,this.element)}}]),t}(a.a.Component);function kt(){var e=Object(de.a)(["\n  width: 360px;\n  margin: 20px auto;\n  button {\n    display: block;\n    width: 100%;\n    height: 60px;\n    font-size: 20px;\n    font-weight: 700;\n    border: 1px solid #0084da;\n    background-color: transparent;\n    color: #0084da;\n    border-radius: 20px;\n    transition: all 0.5s ease-in-out;\n  }\n  button:hover {\n    border: 1px solid transparent;\n    background-color: #0084da;\n    color: white;\n  }\n"]);return kt=function(){return e},e}var St=le.b.div(kt()),xt=ut(function(e){function t(){var e,o;Object(s.a)(this,t);for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];return(o=Object(d.a)(this,(e=Object(l.a)(t)).call.apply(e,[this].concat(a)))).scroll=Z.a.animateScroll,o.state={elapsed:9e3,pauseModal:!1,backModal:!1},o.tick=function(){o.timerId=setInterval(function(){o.setState({elapsed:o.state.elapsed-1})},1e3)},o.stopTick=function(){clearInterval(o.timerId)},o.componentDidMount=function(){var e=o.props.id,t=ze(e);o.props.getQuizs(t),o.tick()},o.componentWillUnmount=function(){o.stopTick()},o.submitAnswerHandler=function(e){o.props.submitAnswer(e),o.scroll.scrollToTop(),o.props.index===o.props.total-1&&Object(u.c)("/result",{state:{elapsed:o.state.elapsed}})},o.onToggleTimer=function(){o.setState({pauseModal:!o.state.pauseModal}),o.stopTick()},o.onToggleTimerOn=function(){o.setState({pauseModal:!o.state.pauseModal}),o.tick()},o.toggleBack=function(){o.setState({backModal:!o.state.backModal})},o}return Object(h.a)(t,e),Object(r.a)(t,[{key:"render",value:function(){var e=this,t=this.props,o=t.quizs,n=t.index,i=t.percentage,c=o[n],s=this.state,r=s.pauseModal,d=s.backModal,l=s.elapsed;return c?a.a.createElement("div",{className:"App",style:r||d?{backgroundColor:"white",top:0,left:0,position:"absolute",width:"100%",height:"100vh",filter:"blur(5px)"}:null},a.a.createElement(ge,null),a.a.createElement("div",{className:"App-main-container"},a.a.createElement("div",{className:"main-section"},a.a.createElement("div",{className:"status-bar"},a.a.createElement(Be,{className:"back-icon",thunk:this.toggleBack}),a.a.createElement(yt,{onToggleTimer:this.onToggleTimer,elapsed:l})),a.a.createElement("h1",{style:{textAlign:"center"}},"OCA"===this.props.id?"OCA":"OCP"),a.a.createElement("p",{style:{marginTop:"10px"}},"\u9032\u5ea6\uff1a",i.toFixed(1),"%"),a.a.createElement(X.b,{strokeWidth:"4",percent:i}),a.a.createElement(ne,{title:c.title,id:c.id,code:c.code,imageUrl:c.imageUrl,ol:c.ol}),a.a.createElement("div",{className:"prompt-textbox"},1===c.answersIntArray.length?a.a.createElement("h2",null,"\u55ae\u9078\u984c"):a.a.createElement("h2",null,"\b","\u8907\u9078\u984c \u53ef\u9078 ".concat(c.answersIntArray.length)," \u500b\u7b54\u6848")),a.a.createElement("div",{className:"answers"},a.a.createElement("ul",null,c.answerArray.map(function(e,t){return a.a.createElement(bt,{key:e.answer+t,answerIndex:t,answerObj:e,id:c.id})}))),a.a.createElement(St,null,a.a.createElement("button",{onClick:function(){return e.submitAnswerHandler(c.id)}},"SUBMIT ANSWER")),this.state.pauseModal?a.a.createElement(Tt,null,a.a.createElement("h1",null,"\u6ce8\u610f,\u6b63\u898f\u8003\u8a66\u4e26\u6c92\u6709\u66ab\u505c\u6642\u9593\u7684\u529f\u80fd"),a.a.createElement("div",{className:"timer-resume"},a.a.createElement("button",{onClick:this.onToggleTimerOn},"RESUME"))):null,this.state.backModal?a.a.createElement(Tt,null,a.a.createElement("h1",null,"\u73fe\u5728\u6309 BACK \u8003\u8a66\u9032\u5ea6\u5c07\u6703\u907a\u5931!!"),a.a.createElement("div",{className:"back-resume"},a.a.createElement("button",{onClick:this.toggleBack},"\u7e7c\u7e8c\u8003\u8a66"),a.a.createElement("button",{onClick:function(){window.history.back(),e.props.resetState()}},"\u96e2\u958b,\u4e0b\u6b21\u518d\u4f86"))):null))):null}}]),t}(n.Component)),Ot=Object(p.b)(function(e){return{total:e.app.total,score:e.app.score,percentage:e.app.percentage}});function _t(){var e=Object(de.a)(["\n  font-size: 70px;\n  font-weight: 700;\n  position: absolute;\n  z-index: 10;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  color: white;\n"]);return _t=function(){return e},e}function Ct(){var e=Object(de.a)(["\n  width: 360px;\n  height: 360px;\n  margin: 20px auto;\n  display: flex;\n  flex-direction: column;\n  background-color: rgba(240, 240, 240, 0.8);\n  @media (min-width: 1200px) {\n    transform: scale(1.2);\n  }\n\n  & div.container-title {\n    width: 100%;\n    height: 60px;\n    background: #323a45;\n    color: white;\n    display: flex;\n    align-items: center;\n    h2 {\n      margin-left: 28px;\n    }\n  }\n  & .container-graph {\n    display: flex;\n    width: 100%;\n    height: 360px;\n    justify-content: center;\n    align-items: center;\n    position: relative;\n  }\n  & div.container-content {\n    width: 100%;\n    height: 60px;\n    display: flex;\n    background-color: white;\n    margin: 4px;\n    align-items: center;\n    justify-content: space-between;\n    h2 {\n      margin-left: 28px;\n    }\n    p {\n      margin-right: 28px;\n    }\n    button {\n      width: 95%;\n      display: block;\n      background-color: #f49c11;\n      margin: 0 auto;\n      color: white;\n      height: 60px;\n      font-size: 32px;\n      animation: changeColor 2s infinite;\n    }\n\n    @keyframes changeColor {\n      0% {\n        background-color: #19b5fe;\n      }\n      50.0% {\n        background-color: #f45711;\n      }\n      100.0% {\n        background-color: #19b5fe;\n      }\n    }\n  }\n"]);return Ct=function(){return e},e}function At(){var e=Object(de.a)(['\n  height: 100vh;\n  font-family: "Noto Sans TC", sans-serif;\n  & div.main-content {\n    display: flex;\n    margin-top: 20px;\n    flex-direction: column;\n    @media (min-width: 768px) {\n      flex-direction: row;\n    }\n  }\n']);return At=function(){return e},e}var It=le.b.div(At()),Bt=le.b.div(Ct()),Et=le.b.p(_t()),Dt=Ot(function(e){var t=e.score,o=e.total,n=e.location,i=Se(9e3-n.state.elapsed).split(" : ").map(function(e){return"0"===e[0]?e[1]:e}),c=t/o*100;return a.a.createElement(It,null,a.a.createElement(ge,null),a.a.createElement("div",{className:"main-content"},a.a.createElement(Bt,null,a.a.createElement("div",{className:"container-title"},a.a.createElement("h2",null,"PASS RATE:")),a.a.createElement("div",{className:"container-graph"},a.a.createElement(Et,null,c.toFixed(1),"%"),a.a.createElement(X.a,{style:{width:"80%",backgroundColor:"#F49C11",borderRadius:"50%"},percent:c,strokeWidth:"10",strokeColor:c>65?"#19b5fe":"#F45711",gapDegree:70,gapPosition:"top"}))),a.a.createElement(Bt,null,a.a.createElement("div",{className:"container-title"},a.a.createElement("h2",null,"SUMMARY:")),a.a.createElement("div",{className:"container-content"},a.a.createElement("h2",null,"\u4f7f\u7528\u6642\u9593"),a.a.createElement("p",null,i[0]," \u5c0f\u6642 ",i[1]," \u5206 ",i[2]," \u79d2")),a.a.createElement("div",{className:"container-content"},a.a.createElement("h2",null,"\u7b54\u5c0d\u984c\u6578"),a.a.createElement("p",null,t," of ",o)),a.a.createElement("div",{className:"container-content"},a.a.createElement("h2",null,"\u6e2c\u8a66\u7d50\u679c"),a.a.createElement("p",{style:c>65?{color:"#19b5fe"}:{color:"#F45711"}},c>65?"\xa0\u5408\u683c":"\u672a\u901a\u904e")),a.a.createElement("div",{className:"container-content"},a.a.createElement("button",{onClick:function(){return Object(u.c)("/review-exam")}},"\u6aa2\u8a66\u8003\u984c\u8207\u7b54\u6848")))))}),Ft=o(94),Lt=o.n(Ft),jt={resetState:F},Wt=Object(p.b)(function(e){return{quizs:e.app.quizs,answerStatus:e.app.answerStatus,index:e.app.index,total:e.app.total}},jt),Nt=function(e){var t=e.explain;return a.a.createElement("div",{className:"analysis-card"},a.a.createElement("h3",null,"\u984c\u89e3 \uff1a"),a.a.createElement("p",null,t.split(".")[0].split(", ").map(function(e,t){return a.a.createElement("span",{style:{marginRight:"5px"},key:t},e)}),t.substring(t.split(".")[0].length,t.length)))},Pt=["A","B","C","D","E","F","G","H"],Rt=function(e){return null===e?"\u672a\u505a\u7b54":e.map(function(e){return Pt[e]}).reduce(function(e,t){return e+t},"")},qt=function(e){var t=e.quiz,o=e.userAnswer;return t?a.a.createElement("div",{className:"main-section"},a.a.createElement(ne,{title:t.title,id:t.id,code:t.code,imageUrl:t.imageUrl}),a.a.createElement("div",{className:"exam-list"},a.a.createElement("ol",{type:"A"},t.answerArray.map(function(e,t){return a.a.createElement("li",{key:t},e.answer)})),a.a.createElement("p",null,"\u4f60(\u59b3)\u7684\u7b54\u6848"," ",Rt(o.answer&&o.answer.map(function(e){return e.id}))),a.a.createElement("p",null,"\u6b63\u78ba\u7b54\u6848 ",Rt(t.answersIntArray))),a.a.createElement(Nt,{explain:t.explain})):null},Mt=Wt(function(e){function t(){var e,o;Object(s.a)(this,t);for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];return(o=Object(d.a)(this,(e=Object(l.a)(t)).call.apply(e,[this].concat(a)))).state={count:0},o.componentWillUnmount=function(){o.props.resetState()},o.handlePageClick=function(e){var t=e.selected;o.setState({count:t})},o}return Object(h.a)(t,e),Object(r.a)(t,[{key:"render",value:function(){var e=this.props,t=e.quizs,o=e.answerStatus,n=e.total,i=this.state.count;return a.a.createElement("div",{className:"App"},a.a.createElement(ge,null),a.a.createElement("div",{className:"App-main-container"},a.a.createElement("div",{className:"main-section"},a.a.createElement(qt,{quiz:t[i],userAnswer:o[i]}),a.a.createElement(Lt.a,{previousLabel:a.a.createElement(K.a,{icon:$.a,size:"lg"}),nextLabel:a.a.createElement(K.a,{icon:$.b,size:"lg"}),breakLabel:"...",breakClassName:"break-me",pageCount:n,marginPagesDisplayed:1,pageRangeDisplayed:2,onPageChange:this.handlePageClick,containerClassName:"pagination",subContainerClassName:"pages pagination",activeClassName:"active"}))))}}]),t}(a.a.Component)),zt=function(){return a.a.createElement("div",{className:"categories"},a.a.createElement(ge,null),a.a.createElement("div",{className:"categories-main-section"},a.a.createElement(Be,{className:"return-icon"}),a.a.createElement("div",{className:"categories-textbox"},a.a.createElement("h1",null,"Declaration"),a.a.createElement("p",{style:{textAlign:"left"}},"This App doesn't have any business intent, it's just React/Redux practice and demo on anonymous server which no one will search for this app. The copyright of Java knowledge content are belong to Jeanne Boyarsky, Scott Selikoff the book's writter. Whoever finds the app accidentally please do not use it and distribute it to any people, this app will be no longer exist when I find a job and pass the OCA OCP certication."),a.a.createElement("p",{style:{textAlign:"left"}},"Yours sincerely"),a.a.createElement("p",{style:{textAlign:"left"}},"Vic Huang"))))},Ht=function(){return a.a.createElement(p.a,{store:Y},a.a.createElement(u.b,null,a.a.createElement(Ge,{path:"/"}),a.a.createElement(Ve,{path:"/categories/:process"}),a.a.createElement(lt,{path:"/chapters/:cert"}),a.a.createElement(He,{path:"/main/:id"}),a.a.createElement(xt,{path:"/exam/:id"}),a.a.createElement(Dt,{path:"/result"}),a.a.createElement(Mt,{path:"/review-exam"}),a.a.createElement(zt,{path:"/about"})))},Jt=function(e){function t(){return Object(s.a)(this,t),Object(d.a)(this,Object(l.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(r.a)(t,[{key:"render",value:function(){return a.a.createElement("div",{className:"App"},a.a.createElement(Ht,null))}}]),t}(n.Component);Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));c.a.render(a.a.createElement(Jt,null),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then(function(e){e.unregister()})},47:function(e,t,o){e.exports=o.p+"static/media/java-awesome.10311930.svg"},64:function(e,t,o){},92:function(e,t,o){e.exports=o.p+"static/media/java-cafe.29af3ace.svg"},93:function(e,t,o){e.exports=o.p+"static/media/study.02f2d714.svg"},96:function(e,t,o){e.exports=o(183)}},[[96,1,2]]]);
//# sourceMappingURL=main.a17b367d.chunk.js.map