const qzString = [
  {
    title:
      "Which of the following can fill in the blank to make the code compile?",
    code: "<code>public class News&lt;________&gt; {}</code>",
    answers: ["None of them", "I", "II and III", "I, II, and III"],
    ol: ["?", "News", "Object"]
  },
  {
    title: "Which method is available on both List and Stream implementations?",
    code: null,
    answers: ["filter()", "forEach()", "replace()", "sort()"]
  },
  {
    title:
      "We are running a library. Patrons select books by name. They get at the back of the checkout line. When they get to the front, they scan the book’s ISBN. The checkout system finds the book based on this number and marks the book as checked out. Of these choices, which data structures best represent the line to check out the book and the book lookup to mark it as checked out, respectively?",
    code: null,
    answers: [
      "ArrayDeque, TreeMap",
      "ArrayDeque, TreeSet",
      "ArrayList, TreeMap",
      "ArrayList, TreeSet"
    ]
  },
  {
    title: "Which cannot fill in the blank for this code to compile?",
    code:
      '<code>Collection&lt;String&gt; c = new ____________&lt;&gt;();</code>\n<code>c.add("pen");</code>\n<code>c.remove("pen");</code>\n<code>System.out.println(c.isEmpty());</code>',
    answers: [
      "ArrayDeque",
      "TreeMap",
      "TreeSet",
      "All of these can fill in the blank."
    ]
  },
  {
    title:
      "Suppose we want to implement a Comparator<String> so that it sorts the longest strings first. You may assume there are no nulls. Which method could implement such a comparator?",
    code: null,
    answers: [
      "\n\n  \n\npublic int compare(String s1, String s2) { \n\n   return s1.length() - s2.length(); \n\n}\n",
      "\n\n  \n\npublic int compare(String s1, String s2) { \n\n   return s2.length() – s1.length(); \n\n}\n",
      "\n\n  \n\npublic int compare(Object obj1, object obj2) { \n\n   String s1 = (String) obj1; \n\n   String s2 = (String) obj2; \n\n   return s1.length() - s2.length(); \n\n}\n",
      "\n\n  \n\npublic int compare(Object obj1, object obj2) { \n\n   String s1 = (String) obj1; \n\n   String s2 = (String) obj2; \n\n   return s2.length() – s1.length(); \n\n}\n"
    ]
  },
  {
    title:
      "Suppose we want to store JellyBean objects. Which of the following pairs require  JellyBean to implement the Comparable interface or create a Comparator in order to add them to the Collection?",
    code: null,
    answers: [
      "ArrayList and ArrayDeque",
      "HashMap and HashSet",
      "HashMap and TreeMap",
      "TreeMap and TreeSet"
    ]
  },
  {
    title: "What is a common reason for a stream pipeline not to run?",
    code: null,
    answers: [
      "The source doesn’t generate any items.",
      "There are no intermediate operations.",
      "The terminal operation is missing.",
      "None of the above"
    ]
  },
  {
    title:
      "We want this code to print the titles of each book twice. Why doesn’t it?",
    code:
      '<code>LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();</code>\n<code>list.add("Grapes of Wrath");</code>\n<code>list.add("1984");</code>\n<code>&nbsp;</code>\n<code>list.forEach(System.out::println);</code>\n<code>&nbsp;</code>\n<code>Iterator it = list.iterator();</code>\n<code>while (it.hasMore())</code>\n<code>  System.out.println(it.next());</code>',
    answers: [
      "The generic type of Iterator is missing.",
      "The hasMore() method should be changed to hasNext().",
      "The iteration code needs to be moved before the forEach() since the stream is used up.",
      "None of the above. The code does print each book title twice."
    ]
  },
  {
    title: "What is the result of the following?",
    code:
      '<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code>\n<code>list.add(56);</code>\n<code>list.add(56);</code>\n<code>list.add(3);</code>\n<code>&nbsp;</code>\n<code>TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(list);</code>\n<code>System.out.print(set.size());</code>\n<code>System.out.print(" " );</code>\n<code>System.out.print(set.iterator().next());</code>',
    answers: ["2 3", "2 56", "3 3", "3 56"]
  },
  {
    title: "What best describes a reduction?",
    code: null,
    answers: [
      "An intermediate operation where it filters the stream it receives",
      "An intermediate operation where it mathematically divides each element in the stream",
      "A terminal operation where a single value is generated by reading each element in the prior step in a stream pipeline",
      "A terminal operation where one element is returned from the prior step in a stream pipeline without reading all the elements"
    ]
  },
  {
    title: "What is the output of the following?",
    code:
      '<code>5:   ArrayDeque&lt;Integer&gt; d = new ArrayDeque&lt;&gt;();</code>\n<code>6:   d.offer(18);</code>\n<code>7:   d.offer(5);</code>\n<code>8:   d.push(13);</code>\n<code>9:   System.out.println(d.poll() + " " + d.poll());</code>',
    answers: ["13 18", "18 5", "18 13", "None of the above"]
  },
  {
    title: "What is the output of the following?",
    code:
      '<code>class Magazine {</code>\n<code>   private String name;</code>\n<code>   public Magazine(String name) {</code>\n<code>      this.name = name;</code>\n<code>   }</code>\n<code>   public int compareTo(Magazine m) {</code>\n<code>      return name.compareTo(m.name);</code>\n<code>   }</code>\n<code>   public String toString() {</code>\n<code>      return name;</code>\n<code>   }</code>\n<code>}</code>\n<code>public class Newstand {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Set&lt;Magazine&gt; set = new TreeSet&lt;&gt;();</code>\n<code>      set.add(new Magazine("highlights"));</code>\n<code>      set.add(new Magazine("Newsweek"));</code>\n<code>      set.add(new Magazine("highlights"));</code>\n<code>      System.out.println(set.iterator().next());</code>\n<code>   }</code>\n<code>}</code>',
    answers: [
      "highlights",
      "Newsweek",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ]
  },
  {
    title: "What is the result of the following?",
    code:
      '<code>6:   List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>\n<code>7:   list.add("Monday");</code>\n<code>8:   list.add(String::new);</code>\n<code>9:   list.add("Tuesday");</code>\n<code>10:  list.remove(0);</code>\n<code>11:  System.out.println(list.get(0));</code>',
    answers: [
      "An empty String",
      "Monday",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ]
  },
  {
    title: "How many lines does this code output?",
    code:
      '<code>List&lt;String&gt; list = new LinkedList&lt;&gt;();</code>\n<code>list.add("Archie");</code>\n<code>list.add("X-Men");</code>\n<code>&nbsp;</code>\n<code>list.stream().forEach(s -&gt; System.out.println(s));</code>\n<code>list.stream().forEach(s -&gt; System.out.println(s));</code>',
    answers: [
      "Two",
      "Four",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ]
  },
  {
    title:
      "Which line in the main() method doesn’t compile or points to a class that doesn’t compile?",
    code:
      '<code>1:   interface Comic&lt;C&gt; {</code>\n<code>2:      void draw(C c);</code>\n<code>3:   }</code>\n<code>4:   class ComicClass&lt;C&gt; implements Comic&lt;C&gt; {</code>\n<code>5:      public void draw(C c) {</code>\n<code>6:         System.out.println(c);</code>\n<code>7:      }</code>\n<code>8:   }</code>\n<code>9:   class SnoopyClass implements Comic&lt;Snoopy&gt; {</code>\n<code>10:     public void draw(Snoopy c) {</code>\n<code>11:        System.out.println(c);</code>\n<code><span epub:type="pagebreak" id="Page_229"></span>12:     }</code>\n<code>13:  }</code>\n<code>14:  class SnoopyComic implements Comic&lt;Snoopy&gt; {</code>\n<code>15:     public void draw(C c) {</code>\n<code>16:        System.out.println(c);</code>\n<code>17:     }</code>\n<code>18:  }</code>\n<code>19:  public class Snoopy {</code>\n<code>20:     public static void main(String[] args) {</code>\n<code>21:       Comic&lt;Snoopy&gt; c1 = c ‐&gt; System.out.println(c);</code>\n<code>22:       Comic&lt;Snoopy&gt; c2 = new ComicClass&lt;&gt;();</code>\n<code>23:       Comic&lt;Snoopy&gt; c3 = new SnoopyClass();</code>\n<code>24:       Comic&lt;Snoopy&gt; c4 = new SnoopyComic();</code>\n<code>25:     }</code>\n<code>26:  }</code>',
    answers: ["Line 21", "Line 22", "Line 23", "Line 24"]
  },
  {
    title: "What is the output of the following?",
    code:
      '<code>Stream&lt;String&gt; s = Stream.of("Atlanta", "Chicago", "New York");</code>\n<code>long count = s.filter(c -&gt; c.startsWith("C")).count();</code>\n<code>System.out.print(count);</code>',
    answers: [
      "1",
      "2",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ]
  },
  {
    title: "Fill in the blank to make this code compile:",
    code:
      '<code>public class Truck implements Comparable&lt;Truck&gt; {</code>\n<code>   private int id;</code>\n<code>   public Truck(int id) {</code>\n<code>      this.id = id;</code>\n<code>   }</code>\n<code>   @Override</code>\n<code>      ____________________ {</code>\n<code><span epub:type="pagebreak" id="Page_230"></span>      return id - t.id;</code>\n<code>   }</code>\n<code>}</code>',
    answers: [
      "public int compare(Truck t)",
      "public int compare(Truck t1, Truck t2)",
      "public int compareTo(Truck t)",
      "public int compareTo(Truck t1, Truck t2)"
    ]
  },
  {
    title:
      "In a stream pipeline, which can return a value other than a Stream?",
    code: null,
    answers: [
      "Source",
      "Intermediate operation",
      "Terminal operation",
      "None of the above"
    ]
  },
  {
    title: "Rewrite this lambda using a constructor reference:",
    code: "<code>n -&gt; new ArrayList&lt;&gt;(n)</code>",
    answers: [
      "ArrayList::new;",
      "ArrayList::new();",
      "ArrayList::new(n);",
      "ArrayList::new[n];"
    ]
  },
  {
    title: "What is the result of the following?",
    code:
      "<code>Comparator&lt;Integer&gt; c = (x, y) ‐&gt; y‐x;</code>\n<code>List&lt;Integer&gt; ints = Arrays.asList(3, 1, 4);</code>\n<code>Collections.sort(ints, c);</code>\n<code>System.out.println(Collections.binarySearch(ints, 1));</code>",
    answers: [
      "0",
      "1",
      "The code does not compile.",
      "The result is not defined."
    ]
  },
  {
    title: "How many lines does this code output?",
    code:
      '<code>List&lt;String&gt; list = new LinkedList&lt;&gt;();</code>\n<code>list.add("Archie");</code>\n<code>list.add("X-Men");</code>\n<code>&nbsp;</code>\n<code>Stream&lt;String&gt; s = list.stream();</code>\n<code>s.forEach(System.out::println);</code>\n<code>s.forEach(System.out::println);</code>',
    answers: [
      "Two",
      "Four",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ]
  },
  {
    title: "Which option cannot fill in the blank to print Clean socks?",
    code:
      '<code>class Wash&lt;T&gt; {</code>\n<code>   T item;</code>\n<code>   public void clean(T item) {</code>\n<code>      System.out.println("Clean " + item);</code>\n<code>   }</code>\n<code>}</code>\n<code>public class LaundryTime {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      ________________________</code>\n<code>      wash.clean("socks");</code>\n<code>   }</code>\n<code>}</code>',
    answers: [
      "Wash wash = new Wash();",
      "Wash wash = new Wash<String>();",
      "Wash<String> wash = new Wash<>();",
      "All three can fill in the blank."
    ]
  },
  {
    title:
      "We want this code to print the titles of each book twice. Why doesn’t it?",
    code:
      '<code>LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();</code>\n<code>list.add("Grapes of Wrath");</code>\n<code>list.add("1984");</code>\n<code>&nbsp;</code>\n<code>list.stream().forEach(System.out::println);</code>\n<code>&nbsp;</code>\n<code>Iterator it = list.iterator();</code>\n<code>while (it.hasNext())</code>\n<code>   System.out.println(it.next());</code>',
    answers: [
      "The generic type of Iterator is missing.",
      "The hasNext() method should be changed to isNext().",
      "The iteration code needs to be moved before the forEach() since the stream is used up.",
      "None of the above. The code does print each book title twice."
    ]
  },
  {
    title: "Rewrite this lambda using a method reference:",
    code: "<code>() -&gt; Math.random()</code>",
    answers: [
      "Math.random",
      "Math::random",
      "Math::random()",
      "None of the above"
    ]
  },
  {
    title: "Which operation can occur more than once in a stream pipeline?",
    code: null,
    answers: [
      "Source",
      "Intermediate operation",
      "Terminal operation",
      "None of the above"
    ]
  },
  {
    title: "Which type allows inserting a null value?",
    code: null,
    answers: ["ArrayDeque", "ArrayList", "TreeSet", "All of these allow nulls."]
  },
  {
    title: "Fill in the blank so this code outputs three lines:",
    code:
      '<code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>\n<code>list.add("Atlanta");</code>\n<code>list.add("Chicago");</code>\n<code>list.add("New York");</code>\n<code>&nbsp;</code>\n<code>list.stream().filter(____________).forEach(System.out::println);</code>',
    answers: [
      "String::isEmpty",
      "! String::isEmpty",
      "String::! isEmpty",
      "None of the above"
    ]
  },
  {
    title: "What is the output of the following?",
    code:
      '<code>TreeMap&lt;String, Integer&gt; map = new TreeMap&lt;&gt;();</code>\n<code>map.put("3", 3);</code>\n<code>map.put("three", 3);</code>\n<code><span epub:type="pagebreak" id="Page_233"></span>map.put("THREE", 3);</code>\n<code>System.out.println(map.firstKey() + " " + map.lastKey());</code>',
    answers: ["3 three", "3 THREE", "three 3", "THREE 3"]
  },
  {
    title:
      "Which fills in the blank in the method signature to allow this code to compile?",
    code:
      '<code>import java.util.*;</code>\n<code>public class ExtendingGenerics {</code>\n<code>   private static &lt;_____________ , U&gt; U add(T list, U element) {</code>\n<code>      list.add(element);</code>\n<code>      return element;</code>\n<code>   }</code>\n<code>   public static void main(String[] args) {</code>\n<code>      List&lt;String&gt; values = new ArrayList&lt;&gt;();</code>\n<code>      add(values, "duck");</code>\n<code>      add(values, "duck");</code>\n<code>      add(values, "goose");</code>\n<code>      System.out.println(values);</code>\n<code>   }</code>\n<code>}</code>\n<code>&nbsp;</code>',
    answers: [
      "? extends Collection<U>",
      "? implements Collection<U>",
      "T extends Collection<U>",
      "T implements Collection<U>"
    ]
  },
  {
    title: "What is the result of the following?",
    code:
      '<code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>\n<code>list.add("Austin");</code>\n<code>list.add("Boston");</code>\n<code>list.add("San Francisco");</code>\n<code>&nbsp;</code>\n<code>list.removeIf(a -&gt; a.length() &gt; 10);</code>\n<code>System.out.println(list.size());</code>',
    answers: ["1", "2", "3", "None of the above"]
  },
  {
    title: "What does the following output?",
    code:
      "<code>ArrayDeque&lt;Integer&gt; dice = new ArrayDeque&lt;&gt;();</code>\n<code>dice.offer(3);</code>\n<code>dice.offer(2);</code>\n<code>dice.offer(4);</code>\n<code>System.out.print(dice.stream().filter(n -&gt; n != 4));</code>",
    answers: ["2", "3", "The code does not compile.", "None of the above"]
  },
  {
    title:
      "Which of the following cannot fill in the blank to make the code compile?",
    code:
      "<code>private void output(____________&lt;?&gt; x) {</code>\n<code>   x.forEach(System.out::println);</code>\n<code>}</code>",
    answers: ["ArrayDeque", "Collection", "TreeMap", "None of the above"]
  },
  {
    title: "How many lines does this code output?",
    code:
      '<code>List&lt;String&gt; list = new LinkedList&lt;&gt;();</code>\n<code>list.add("Archie");</code>\n<code>list.add("X-Men");</code>\n<code>&nbsp;</code>\n<code>list.stream().forEach(System.out.println);</code>\n<code>list.stream().forEach(System.out.println);</code>',
    answers: [
      "Two",
      "Four",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ]
  },
  {
    title: "What is the output of the following?",
    code:
      '<code>class Magazine implements Comparable&lt;Magazine&gt; {</code>\n<code>   private String name;</code>\n<code>   public Magazine(String name) {</code>\n<code>      this.name = name;</code>\n<code>   }</code>\n<code>   @Override</code>\n<code>   public int compareTo(Magazine m) {</code>\n<code><span epub:type="pagebreak" id="Page_235"></span>      return name.compareTo(m.name);</code>\n<code>   }</code>\n<code>   @Override</code>\n<code>   public String toString() {</code>\n<code>      return name;</code>\n<code>   }</code>\n<code>}</code>\n<code>public class Newstand {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Set&lt;Magazine&gt; set = new TreeSet&lt;&gt;();</code>\n<code>      set.add(new Magazine("highlights"));</code>\n<code>      set.add(new Magazine("Newsweek"));</code>\n<code>      set.add(new Magazine("highlights"));</code>\n<code>      System.out.println(set.iterator().next());</code>\n<code>   }</code>\n<code>}</code>',
    answers: [
      "highlights",
      "Newsweek",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ]
  },
  {
    title: "How many lines does the following code output?",
    code:
      '<code>import java.util.*;</code>\n<code>class Blankie {</code>\n<code>   String color;</code>\n<code>   String getColor() {</code>\n<code>      return color;</code>\n<code>   }</code>\n<code>}</code>\n<code>public class PreSchool {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Blankie b1 = new Blankie();</code>\n<code>      Blankie b2 = new Blankie();</code>\n<code>      b1.color = "pink";</code>\n<code>      List&lt;Blankie&gt; list = Arrays.asList(b1, b2);</code>\n<code>      list.stream().filter(Blankie::getColor).forEach(System.out::println);</code>\n<code>   }</code>\n<code>}</code>',
    answers: [
      "One",
      "Two",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ]
  },
  {
    title: "Which statement about a source in a Stream is true?",
    code: null,
    answers: [
      "The source is mandatory in a stream pipeline.",
      "The source is only allowed to return primitives.",
      "The source must be retrieved by calling the stream() method.",
      "The source must return a finite number of elements."
    ]
  },
  {
    title: "What does the following output?",
    code:
      '<code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>\n<code>list.add("Austin");</code>\n<code>list.add("Boston");</code>\n<code>list.add("San Francisco");</code>\n<code>&nbsp;</code>\n<code>long c = list.stream().filter(a -&gt; a.length() &gt; 10).count();</code>\n<code>System.out.println(c + " " + list.size());</code>',
    answers: ["1 1", "1 3", "2 3", "None of the above"]
  },
  {
    title: "Which options can fill in the blanks to print Cleaned 2 items?",
    code:
      '<code>import java.util.*;</code>\n<code>class Wash&lt;T  ____________ Collection&gt; {</code>\n<code>   T item;</code>\n<code>   public void clean(T items) {</code>\n<code>      System.out.println("Cleaned " + items.size() + " items");</code>\n<code>   }</code>\n<code>}</code>\n<code>public class LaundryTime {</code>\n<code>   public static void main(String[] args) {</code>\n<code>      Wash&lt;List&gt; wash = new ____________</code>\n<code>      wash.clean(Arrays.asList("sock", "tie"));   }</code>\n<code>}</code>',
    answers: [
      "extends, Wash<ArrayList>();",
      "extends, Wash<List>();",
      "super, Wash<ArrayList>();",
      "super, Wash<List>();"
    ]
  },
  {
    title:
      "Which of the following declares a Comparator where all objects are treated as equal?",
    code: null,
    answers: [
      "Comparator<Character> comp = (c1)-> 0;",
      "Comparator<Character> comp = (c1)-> {0};",
      "Comparator<Character> comp = (c1, c2)-> 0;",
      "Comparator<Character> comp = (c1, c2)-> {0};"
    ]
  },
  {
    title: "Why can’t String::charAt be used as a method reference?",
    code: null,
    answers: [
      "Method references can only be used on static methods.",
      "Method references can pass either the instance or the parameter from the lambda, but not both.",
      "The charAt() method takes an int rather than Integer parameter.",
      "There is no charAt() method in the String class."
    ]
  }
];

const a13 = [
  "C. When declaring a class that uses generics, you must specify a name for the formal type parameter. Java uses the standard rules for naming a variable or class. A question mark is not allowed in a variable name, making I incorrect. While it is common practice to use a single uppercase letter for the type parameter, this is not required. It certainly isn’t a good idea to use existing class names like the News class being declared here or the Object class built into java. However, this is allowed, and Option C is correct.",
  "B. Option A is incorrect because the filter() method is available on Stream, but not List. Option C is incorrect because the replace() method is available on List, but not Stream. Option D is tricky because there is a sort() method on List and a sorted() method on Stream. These are different method names though, so Option D is incorrect. Option B is the answer because both interfaces have a forEach() method.",
  "A. Notice how there is unnecessary information in this description. The fact that patrons select books by name is irrelevant. The checkout line is a perfect example of a double-ended queue. We need easy access to one end of the queue for patrons to add themselves to the queue. We also need easy access to the other end of the queue for patrons to get off the queue when it is their turn. The book lookup by ISBN is a lookup by key. We need a map for this. A HashMap is probably better here, but it isn’t a choice. So the answer is Option A, which does include both a double-ended queue and a map.",
  "B. Java talks about the collections framework, but the Map interface does not actually implement the Collection interface. TreeMap has different methods than ArrayDeque and TreeSet. It cannot fill in the blank, so Option B is correct.",
  "B. Options C and D are incorrect because the method signature is incorrect. Unlike the equals() method, the method in Comparator takes the type being compared as the parameters when using generics. Option A is a valid Comparator. However, it sorts in ascending order by length. Option B is correct. If s1 is three characters and s2 is one character, it returns -2. The negative value says that s1 should sort first, which is correct, because we want the longest String first.",
  "D. TreeMap and TreeSet keep track of sort order when you insert elements. TreeMap sorts the keys and TreeSet sorts the objects in the set. This makes Option D correct. Note that you have the option of having JellyBean implement Comparable, or you can pass a Comparator to the constructor of TreeMap or TreeSet.",
  "C. Option A is incorrect because a pipeline still runs if the source doesn’t generate any items and the rest of the pipeline is correct. Granted some of the operations have nothing to do, but control still passes to the terminal operation. Option B is incorrect because intermediate operations are optional. Option C is the answer. The terminal operation triggers the pipeline to run.",
  "B. The Iterator interface uses the hasNext() and next() methods to iterate. Since there is not a hasMore() method, it should be changed to hasNext(), making Option B the answer. With respect to Option A, the missing generic type gives a warning, but the code still runs. For Option C, iterators can run as many times as you want, as can the forEach() method on list.",
  "A. First the code creates an ArrayList of three elements. Then the list is transformed into a TreeSet. Since sets are not allowed to have duplicates, the set only has two elements. Remember that a TreeSet is sorted, which means that the first element in the TreeSet is 3. Therefore, Option A is correct.",
  "C. The word reduction is used with streams for a terminal operation, so Options A and B are incorrect. Option D describes a valid terminal operation like anyMatch(), but is not a reduction. Option C is correct because a reduction has to look at each element in the stream in order to determine the result.",
  "A. The offer() method adds an element to the back of the queue. After line 7 completes, the queue contains 18 and 5 in that order. The push() method adds an element to the front of the queue. How rude! The element 13 pushes past everyone on the line. After line 8 completes, the queue now contains 13, 18, and 5, in that order. Then we get the first two elements from the front, which are 13 and 18, making Option A correct.",
  "D. The Magazine class doesn’t implement Comparable<Magazine>. It happens to implement the compareTo() method properly, but it is missing actually writing implements Comparable. Since TreeSet doesn’t look to see if the object can be compared until runtime, this code throws a ClassCastException when TreeSet calls add(), so Option D is correct.",
  "C. Line 8 does not compile. String::new is a constructor reference. A constructor or method reference is equivalent to a lambda. It participates in deferred execution. When it is executed later, it returns a String. It does not return a String on line 8. It actually returns a Supplier<String>, which cannot be stored in list. Since the code does not compile, Option C is correct.",
  "B. This code adds two elements to a list. It then gets a stream and iterates through the list, printing two lines. The last line does the same thing again. Since a fresh stream is created, we are allowed to iterate through it, and Option B is correct.",
  "D. The Comic interface declares a formal type parameter. This means that a class implementing it needs to specify this type. The code on line 21 compiles because the lambda reference supplies the necessary context making Option A incorrect. Option B declares a generic class. While this doesn’t tell us the type is Snoopy, it punts the problem to the caller of the class. The declaration of c2 on line 22 compiles because it supplies the type, making Option B incorrect. The code on line 23 compiles because the SnoopyClass itself supplies the type making Option C incorrect. Option D has a problem. SnoopyClass and SnoopyComic appear similar. However, SnoopyComic refers to C. This type parameter exists in the interface. It isn’t available in the class because the class has said it is using Snoopy as the type. Since the SnoopyComic class itself doesn’t compile, the line with c4 can’t instantiate it, and Option D is the answer.",
  "A. In streams, the filter() method filters out any values that do not match. This means the only value to make it to the terminal operator count() is Chicago, and Option A is correct.",
  "C. When implementing Comparable, you implement the compareTo() method. Since this is an instance method, it already has a reference to itself and only needs the item it is comparing. Only one parameter is specified, and Option C is correct. By contrast, the Comparator interface uses the compare() method and the method takes two parameters.",
  "C. The source and any intermediate operations are chained and eventually passed to the terminal operation. The terminal operation is where a non-stream result is generated, making Option C correct.",
  "A. A constructor reference uses the new keyword where a method name would normally go in a method reference. It can implicitly take zero or one parameters just like a method reference. In this case, we have one parameter, which gets passed to the constructor. Option A is correct.",
  "D. A custom sort order is specified using a Comparator to sort in descending order. However, this Comparator is not passed when searching. When a different sort order is used for searching and sorting, the result is undefined. Therefore, Option D is correct.",
  "D. Java only allows you to operate on a stream once. The final line of code throws an IllegalStateException because the stream has already been used up. Option D is the correct answer.",
  "D. The Wash class takes a formal type parameter named T. Option C shows the best way to call it. This option declares a generic reference type that specifies the type is String. It also uses the diamond syntax to avoid redundantly specifying the type on the right-hand side of the assignment. Options A and B show that you can omit the generic type in the reference and still have the code compile. You do get a compiler warning scolding you for having a raw type. But compiler warnings do not prevent compilation. With the raw type, the compiler treats T as if it is of type Object. That is OK in this example because the only method we call is toString() implicitly when printing the value. Since toString() is defined on the Object class, we are safe, and Options A and B work. Since all three can fill in the blank, Option D is the answer.",
  "D. The missing generic type gives a warning, but the code still runs, so Option A is incorrect. The Iterator interface uses hasNext() and next() methods to iterate, so Option B is incorrect. Option C applies to calling the same stream twice. One of our calls is to an Iterator anyway, so Option C is incorrect. This code is in fact correct, making the answer Option D.",
  "B. This is a static method reference. It uses :: to separate the class name and method name. Option B is correct.",
  "B. A source and the terminal operation are required parts of a stream pipeline and must occur exactly once. The intermediate operation is optional. It can appear zero or more times. Since more than once falls within zero or more, Option B is correct.",
  "B. ArrayList allows null elements, making Option B correct. TreeSet does not allow nulls because they need to compare the values. ArrayDeque uses null for a special meaning, so it doesn’t allow it in the data structure either.",
  "D. Option A is the only one of the three options to compile. However, it results in no lines being output since none of the three strings are empty. Options B and C do not even compile because a method reference cannot have an operator next to it. Therefore, Option D is correct.",
  "A. Unfortunately you do have to memorize two facts about sort order. First, numbers sort before letters. Second, uppercase sorts before lowercase. Since TreeMap orders by key, the first key is 3 and the last is three, making Option A correct.",
  "C. The ? is an unbounded wildcard. It is used in variable references but is not allowed in declarations. In a static method, the type parameter specified inside the <> is used in the rest of the variable declaration. Since it needs an actual name, Options A and B are incorrect. We need to specify a type constraint so we can call the add() method. Regardless of whether the type is a class or interface, Java uses the extends keyword for generics. Therefore, Option D is incorrect, and Option C is the answer.",
  "B. On a stream, the filter() method only keeps values matching the lambda. The removeIf() does the reverse on a Collection and keeps the elements that do not match. In this case, that is Austin and Boston so Option B is correct.",
  "D. The code correctly creates an ArrayDeque with three elements. The stream pipeline does compile. However, there is no terminal operation, which means the stream is never evaluated and the output is something like java.util.stream.ReferencePipeline$2@404b9385. This is definitely not one of the listed choices, so Option D is correct.",
  "C. The forEach() method that takes one parameter is defined on the Collection interface. However, a map is not a Collection. There is a version of forEach() defined on the Map interface, but it uses two parameters. Since two parameters can’t be used with a method reference, Option C is the answer.",
  "C. This code is almost correct. Calling two different streams is allowed. The code attempts to use a method reference when calling the forEach() method. However, it does not use the right syntax for a method reference. A double colon needs to be used. The code would need to be changed to System.out::println to work and print two lines for each call. Since it does not compile, Option C is correct.",
  "B. This code shows a proper implementation of Comparable. It has the correct method signature. It compares the magazine names in alphabetical order. Remember that uppercase letters sort before lowercase letters. Since Newsweek is uppercase, Option B is correct.",
  "C. The filter() method requires a boolean returned from the lambda or method reference. The getColor() method returns a String and is not compatible. This causes the code to not compile and Option C to be correct.",
  "A. Option A is correct as the source and terminal operation are mandatory parts of a stream pipeline. Option B is incorrect because a Stream must return non-primitives. Specialized interfaces like IntStream are needed to return primitives. Option C is incorrect because Stream has methods such as of() and iterate() that return a Stream. Option D is incorrect because infinite streams are possible.",
  "B. The stream pipeline is correct and filters all values out that are 10 characters or smaller. Only San Francisco is long enough, so c is 1. The stream() call creates a new object, so stream operations do not affect the original list. Since the original list is still 3 elements, Option B is correct.",
  "B. Options A and C are incorrect because a generic type cannot be assigned to another direct type unless you are using upper or lower bounds in that statement. Now, we just have to decide whether a lower or upper bound is correct for the T formal type parameter in Wash. The clue is that the method calls size(). This method is available on Collection and all classes that extend/implement it. Therefore, Option B is correct.",
  "C. A Comparator takes two parameters, so Options A and B are incorrect. Option D doesn’t compile. When using brackets, a return keyword and semicolon are required. Option C is a correct implementation.",
  "B. Option D is incorrect because there is a charAt() instance method. While Option C is correct that the method takes in an int parameter, autoboxing would take care of conversion for us if there were no other problems. So Option C is not the answer. Option A is not true because there are constructor and instance method references. Option B is the answer. With method references, only one item can be supplied at runtime. Here, we need either a String instance with no parameters in the method or a static method with a single parameter. The charAt() method is an instance method with a single parameter so does not meet this requirement."
];

const convertCorrectIndex = string => {
  switch (string[0]) {
    case "A":
      return 0;
    case "B":
      return 1;
    case "C":
      return 2;
    case "D":
      return 3;
    case "E":
      return 4;
    case "F":
      return 5;
    case "G":
      return 6;
    case "H":
      return 7;
    case "I":
      return 8;
    default:
      throw new Error("no match character");
  }
};

const mapAnswers = (answers, string) => {
  const correctIndex = convertCorrectIndex(string);
  if (!Array.isArray(answers)) {
    console.log(answers);
    return;
  }
  return answers.map((answer, index) => {
    return {
      answer,
      isCorrect: index === correctIndex
    };
  });
};

const quizs = qzString.map((qz, index) => {
  return {
    id: index,
    title: qz["title"],
    code: qz["code"],
    imageUrl: null,
    answerArray: mapAnswers(qz["answers"], a13[index]),
    explain: a13[index],
    ol: qz["ol"]
  };
});
// window.quizs = quizs
quizs[24].imageUrl = "./images/image-ocp-ch13-25.png";
//   quizs[9].imageUrl = "./images/image-oca-ch1-10.png";
//   quizs[48].imageUrl = "./images/image-oca-ch1-49.png";

export default quizs;
